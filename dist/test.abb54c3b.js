// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/@stringsync/musicxml/dist/MusicXMLError.js":[function(require,module,exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.MusicXMLError = void 0;
var MusicXMLError = /** @class */ (function (_super) {
    __extends(MusicXMLError, _super);
    function MusicXMLError(message, ctx) {
        if (ctx === void 0) { ctx = {}; }
        return _super.call(this, "message:\n\t".concat(message, "\n\ncontext:\n\t").concat(Object.entries(ctx)
            .map(function (_a) {
            var k = _a[0], v = _a[1];
            return "".concat(k, "=").concat(JSON.stringify(v));
        })
            .join('\n\t') || '(None)')) || this;
    }
    return MusicXMLError;
}(Error));
exports.MusicXMLError = MusicXMLError;

},{}],"node_modules/@stringsync/musicxml/dist/lib/util/Cursor.js":[function(require,module,exports) {
"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cursor = void 0;
var Cursor = /** @class */ (function () {
    function Cursor(array, index) {
        this.array = array;
        this.index = index;
    }
    Cursor.from = function (array) {
        return new Cursor(__spreadArray([], array, true), 0);
    };
    Cursor.prototype.dup = function () {
        return new Cursor(this.array, this.index);
    };
    Cursor.prototype.done = function () {
        return this.index >= this.array.length;
    };
    Cursor.prototype.next = function () {
        if (this.done()) {
            throw new Error('the cursor is done');
        }
        this.index++;
    };
    Cursor.prototype.get = function () {
        if (this.done()) {
            throw new Error('the cursor is done');
        }
        return this.array[this.index];
    };
    Cursor.prototype.getIndex = function () {
        return this.index;
    };
    Cursor.prototype.sync = function (cursor) {
        var index = cursor.getIndex();
        if (index > this.array.length) {
            throw new Error("index must be <= ".concat(this.array.length));
        }
        this.index = index;
    };
    return Cursor;
}());
exports.Cursor = Cursor;

},{}],"node_modules/@stringsync/musicxml/dist/lib/schema/schema.js":[function(require,module,exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
/**
 * Creates an XMLElementSchema object.
 *
 * @param name the element name
 * @param attributes the attributes as a key-value mapping of descriptors
 * @param contents the contents as an array of descriptors
 * @returns an XMLElementSchema object
 */
var schema = function (name, attributes, contents, opts) {
    if (opts === void 0) { opts = {}; }
    return (__assign({ name: name, attributes: attributes, contents: contents }, opts));
};
exports.schema = schema;

},{}],"node_modules/@stringsync/musicxml/dist/lib/schema/t.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.t = void 0;
var MusicXMLError_1 = require("../../MusicXMLError");
var t = /** @class */ (function () {
    function t() {
        throw new MusicXMLError_1.MusicXMLError('t is not instantiable');
    }
    t.string = function () {
        return {
            type: 'string',
        };
    };
    t.regex = function (opts) {
        var zero = opts.zero, pattern = opts.pattern;
        if (!zero.match(pattern)) {
            throw new MusicXMLError_1.MusicXMLError('invalid zero value', { zero: zero, pattern: pattern });
        }
        return {
            type: 'regex',
            pattern: pattern,
            zero: zero,
        };
    };
    t.int = function (opts) {
        var _a, _b;
        var min = (_a = opts === null || opts === void 0 ? void 0 : opts.min) !== null && _a !== void 0 ? _a : Number.NEGATIVE_INFINITY;
        var max = (_b = opts === null || opts === void 0 ? void 0 : opts.max) !== null && _b !== void 0 ? _b : Number.POSITIVE_INFINITY;
        if (Number.isFinite(min) && (!Number.isInteger(min) || isNaN(min))) {
            throw new MusicXMLError_1.MusicXMLError('invalid min value', { min: min });
        }
        if (Number.isFinite(max) && (!Number.isInteger(max) || isNaN(max))) {
            throw new MusicXMLError_1.MusicXMLError('invalid max value', { max: max });
        }
        if (min >= max) {
            throw new MusicXMLError_1.MusicXMLError('invalid min and max values', { min: min, max: max });
        }
        return {
            type: 'int',
            min: min,
            max: max,
        };
    };
    t.float = function (opts) {
        var _a, _b;
        var min = (_a = opts === null || opts === void 0 ? void 0 : opts.min) !== null && _a !== void 0 ? _a : Number.NEGATIVE_INFINITY;
        var max = (_b = opts === null || opts === void 0 ? void 0 : opts.max) !== null && _b !== void 0 ? _b : Number.POSITIVE_INFINITY;
        if (isNaN(min)) {
            throw new MusicXMLError_1.MusicXMLError('invalid min value', { min: min });
        }
        if (isNaN(max)) {
            throw new MusicXMLError_1.MusicXMLError('invalid max value', { max: max });
        }
        if (min >= max) {
            throw new MusicXMLError_1.MusicXMLError('invalid min and max values', { min: min, max: max });
        }
        return {
            type: 'float',
            min: min,
            max: max,
        };
    };
    t.date = function () {
        return {
            type: 'date',
        };
    };
    t.constant = function (value) {
        return {
            type: 'constant',
            value: value,
        };
    };
    t.choices = function () {
        var choices = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            choices[_i] = arguments[_i];
        }
        return {
            type: 'choices',
            choices: choices,
        };
    };
    t.optional = function (value) {
        return {
            type: 'optional',
            value: value,
        };
    };
    t.required = function (value) {
        return {
            type: 'required',
            value: value,
        };
    };
    t.label = function (opts) {
        return {
            type: 'label',
            label: opts.label,
            value: opts.value,
        };
    };
    t.comment = function (opts) {
        return {
            type: 'comment',
            comment: opts.comment,
            value: opts.value,
        };
    };
    t.zeroOrMore = function (value) {
        return {
            type: 'zeroOrMore',
            value: value,
        };
    };
    t.oneOrMore = function (value) {
        return {
            type: 'oneOrMore',
            value: value,
        };
    };
    t.not = function (opts) {
        return {
            type: 'not',
            include: opts.include,
            exclude: opts.exclude,
        };
    };
    return t;
}());
exports.t = t;

},{"../../MusicXMLError":"node_modules/@stringsync/musicxml/dist/MusicXMLError.js"}],"node_modules/@stringsync/musicxml/dist/lib/schema/types.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],"node_modules/@stringsync/musicxml/dist/lib/schema/index.js":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./schema"), exports);
__exportStar(require("./t"), exports);
__exportStar(require("./types"), exports);

},{"./schema":"node_modules/@stringsync/musicxml/dist/lib/schema/schema.js","./t":"node_modules/@stringsync/musicxml/dist/lib/schema/t.js","./types":"node_modules/@stringsync/musicxml/dist/lib/schema/types.js"}],"node_modules/@stringsync/musicxml/dist/lib/util/typeGuards.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isXMLElementCtor = exports.isXMLElement = exports.isXMLElementSchema = exports.isDescriptor = exports.isObject = exports.isArray = exports.isFunction = exports.isUndefined = exports.isNull = exports.isNumber = exports.isString = void 0;
var schema_1 = require("../schema");
var isString = function (value) {
    return typeof value === 'string';
};
exports.isString = isString;
var isNumber = function (value) {
    return typeof value === 'number' && !isNaN(value);
};
exports.isNumber = isNumber;
var isNull = function (value) {
    return value === null;
};
exports.isNull = isNull;
var isUndefined = function (value) {
    return typeof value === 'undefined';
};
exports.isUndefined = isUndefined;
var isFunction = function (value) {
    return typeof value === 'function';
};
exports.isFunction = isFunction;
var isArray = function (value) {
    return Array.isArray(value);
};
exports.isArray = isArray;
var isObject = function (value) {
    return !!value && typeof value === 'object';
};
exports.isObject = isObject;
var isDescriptor = function (value) {
    return (0, exports.isObject)(value) && value.type in schema_1.t;
};
exports.isDescriptor = isDescriptor;
var isXMLElementSchema = function (value) {
    return (0, exports.isObject)(value) && (0, exports.isString)(value.name) && (0, exports.isObject)(value.attributes) && (0, exports.isArray)(value.contents);
};
exports.isXMLElementSchema = isXMLElementSchema;
var isXMLElement = function (value) {
    return (0, exports.isObject)(value) && (0, exports.isXMLElementSchema)(value.schema) && (0, exports.isObject)(value.attributes) && (0, exports.isArray)(value.contents);
};
exports.isXMLElement = isXMLElement;
var isXMLElementCtor = function (value) {
    return !(0, exports.isUndefined)(value) && 'schema' in value && (0, exports.isXMLElementSchema)(value.schema) && (0, exports.isFunction)(value);
};
exports.isXMLElementCtor = isXMLElementCtor;

},{"../schema":"node_modules/@stringsync/musicxml/dist/lib/schema/index.js"}],"node_modules/@stringsync/musicxml/dist/lib/util/types.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],"node_modules/@stringsync/musicxml/dist/lib/util/index.js":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Cursor"), exports);
__exportStar(require("./typeGuards"), exports);
__exportStar(require("./types"), exports);

},{"./Cursor":"node_modules/@stringsync/musicxml/dist/lib/util/Cursor.js","./typeGuards":"node_modules/@stringsync/musicxml/dist/lib/util/typeGuards.js","./types":"node_modules/@stringsync/musicxml/dist/lib/util/types.js"}],"node_modules/@stringsync/musicxml/dist/lib/operations/validate.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = void 0;
var MusicXMLError_1 = require("../../MusicXMLError");
var util = require("../util");
/**
 * Validates if a value is compatible with a descriptor child.
 *
 * @param value any value to test
 * @param child a descriptor child to validate against
 * @returns {boolean}
 */
var validate = function (value, child) {
    if (util.isString(child)) {
        return value === child;
    }
    if (util.isNumber(child)) {
        return value === child;
    }
    if (util.isDescriptor(child)) {
        switch (child.type) {
            case 'string':
                return util.isString(value);
            case 'regex':
                return util.isString(value) && !!value.match(child.pattern);
            case 'int':
                return Number.isInteger(value) && !isNaN(value) && child.min <= value && value <= child.max;
            case 'float':
                return util.isNumber(value) && !isNaN(value) && child.min <= value && value <= child.max;
            case 'constant':
                return value === child.value;
            case 'date':
                return value instanceof Date;
            case 'choices':
                return child.choices.some(function (choice) { return (0, exports.validate)(value, choice); });
            case 'label':
                return (0, exports.validate)(value, child.value);
            case 'optional':
                return util.isNull(value) || (0, exports.validate)(value, child.value);
            case 'required':
                return (0, exports.validate)(value, child.value);
            case 'zeroOrMore':
                return util.isArray(value) && value.every(function (v) { return (0, exports.validate)(v, child.value); });
            case 'oneOrMore':
                return util.isArray(value) && value.length >= 1 && value.every(function (v) { return (0, exports.validate)(v, child.value); });
            case 'not':
                return (0, exports.validate)(value, child.include) && !(0, exports.validate)(value, child.exclude);
        }
    }
    if (util.isXMLElementSchema(child)) {
        if (!util.isXMLElement(value)) {
            return false;
        }
        if (value.schema.name !== child.name) {
            return false;
        }
        return (0, exports.validate)(value.contents, child.contents);
    }
    if (util.isXMLElementCtor(child)) {
        return (0, exports.validate)(value, child.schema);
    }
    if (util.isFunction(child)) {
        return (0, exports.validate)(value, child());
    }
    if (util.isArray(child)) {
        return Array.isArray(value) && value.length === child.length && child.every(function (c, ndx) { return (0, exports.validate)(value[ndx], c); });
    }
    throw new MusicXMLError_1.MusicXMLError('cannot validate', { value: value, child: child });
};
exports.validate = validate;

},{"../../MusicXMLError":"node_modules/@stringsync/musicxml/dist/MusicXMLError.js","../util":"node_modules/@stringsync/musicxml/dist/lib/util/index.js"}],"node_modules/@stringsync/musicxml/dist/lib/operations/zero.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zero = void 0;
var MusicXMLError_1 = require("../../MusicXMLError");
var util = require("../util");
var zero = function (child) {
    if (util.isString(child)) {
        return child;
    }
    if (util.isNumber(child)) {
        return child;
    }
    if (util.isDescriptor(child)) {
        switch (child.type) {
            case 'string':
                return '';
            case 'regex':
                return child.zero;
            case 'int':
                return Number.isFinite(child.min) ? child.min : 0;
            case 'float':
                return Number.isFinite(child.min) ? child.min : 0;
            case 'constant':
                return child.value;
            case 'date':
                return new Date(1970, 0, 1, 0, 0, 0, 0);
            case 'choices':
                return (0, exports.zero)(child.choices[0]);
            case 'optional':
                return null;
            case 'label':
                return (0, exports.zero)(child.value);
            case 'required':
                return (0, exports.zero)(child.value);
            case 'zeroOrMore':
                return [];
            case 'oneOrMore':
                return [(0, exports.zero)(child.value)];
            case 'not':
                return (0, exports.zero)(child.include);
        }
    }
    if (util.isXMLElementCtor(child)) {
        return new child();
    }
    if (util.isFunction(child)) {
        return (0, exports.zero)(child());
    }
    if (util.isArray(child)) {
        return child.map(function (c) { return (0, exports.zero)(c); });
    }
    throw new MusicXMLError_1.MusicXMLError('cannot compute zero value', { child: child });
};
exports.zero = zero;

},{"../../MusicXMLError":"node_modules/@stringsync/musicxml/dist/MusicXMLError.js","../util":"node_modules/@stringsync/musicxml/dist/lib/util/index.js"}],"node_modules/@stringsync/musicxml/dist/lib/operations/merge.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.merge = void 0;
var validate_1 = require("./validate");
var zero_1 = require("./zero");
/**
 * Merges a object of attributes into the zero value of a schema's attributes.
 *
 * @param attributes a object of attributes to merge into the zero value
 * @param schema the schema of the element
 */
var merge = function (attributes, schema) {
    var result = {};
    for (var _i = 0, _a = Object.entries(schema.attributes); _i < _a.length; _i++) {
        var _b = _a[_i], name_1 = _b[0], descriptor = _b[1];
        if (name_1 in attributes && (0, validate_1.validate)(attributes[name_1], descriptor)) {
            result[name_1] = attributes[name_1];
        }
        else {
            result[name_1] = (0, zero_1.zero)(descriptor);
        }
    }
    return result;
};
exports.merge = merge;

},{"./validate":"node_modules/@stringsync/musicxml/dist/lib/operations/validate.js","./zero":"node_modules/@stringsync/musicxml/dist/lib/operations/zero.js"}],"node_modules/@stringsync/musicxml/dist/lib/operations/index.js":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./merge"), exports);
__exportStar(require("./validate"), exports);
__exportStar(require("./zero"), exports);

},{"./merge":"node_modules/@stringsync/musicxml/dist/lib/operations/merge.js","./validate":"node_modules/@stringsync/musicxml/dist/lib/operations/validate.js","./zero":"node_modules/@stringsync/musicxml/dist/lib/operations/zero.js"}],"node_modules/@stringsync/musicxml/dist/generated/elements.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Link = exports.CreditType = exports.Defaults = exports.LyricLanguage = exports.LyricFont = exports.WordFont = exports.MusicFont = exports.Appearance = exports.OtherAppearance = exports.Glyph = exports.Distance = exports.NoteSize = exports.LineWidth = exports.StaffLayout = exports.StaffDistance = exports.SystemLayout = exports.TopSystemDistance = exports.SystemDistance = exports.SystemMargins = exports.PageLayout = exports.PageMargins = exports.BottomMargin = exports.TopMargin = exports.RightMargin = exports.LeftMargin = exports.PageWidth = exports.PageHeight = exports.ConcertScore = exports.Scaling = exports.Tenths = exports.Millimeters = exports.Identification = exports.Miscellaneous = exports.MiscellaneousField = exports.Relation = exports.Source = exports.Encoding = exports.Supports = exports.EncodingDescription = exports.Software = exports.Encoder = exports.EncodingDate = exports.Rights = exports.Creator = exports.MovementTitle = exports.MovementNumber = exports.Work = exports.Opus = exports.WorkTitle = exports.WorkNumber = void 0;
exports.Alter = exports.Step = exports.Chord = exports.PartList = exports.ScorePart = exports.MidiInstrument = exports.Elevation = exports.Pan = exports.Volume = exports.MidiUnpitched = exports.MidiProgram = exports.MidiBank = exports.MidiName = exports.MidiChannel = exports.MidiDevice = exports.Player = exports.ScoreInstrument = exports.VirtualInstrument = exports.VirtualName = exports.VirtualLibrary = exports.Ensemble = exports.Solo = exports.InstrumentSound = exports.InstrumentAbbreviation = exports.InstrumentName = exports.Group = exports.PartAbbreviationDisplay = exports.PartAbbreviation = exports.PartNameDisplay = exports.PartName = exports.PartLink = exports.GroupLink = exports.InstrumentLink = exports.PartGroup = exports.Level = exports.Footnote = exports.GroupTime = exports.GroupBarline = exports.GroupSymbol = exports.GroupAbbreviationDisplay = exports.GroupAbbreviation = exports.GroupNameDisplay = exports.AccidentalText = exports.DisplayText = exports.GroupName = exports.Credit = exports.CreditSymbol = exports.CreditWords = exports.CreditImage = exports.Bookmark = void 0;
exports.OtherOrnament = exports.Haydn = exports.Tremolo = exports.Schleifer = exports.InvertedMordent = exports.Mordent = exports.WavyLine = exports.Shake = exports.InvertedVerticalTurn = exports.VerticalTurn = exports.DelayedInvertedTurn = exports.InvertedTurn = exports.DelayedTurn = exports.Turn = exports.TrillMark = exports.Slide = exports.Glissando = exports.Tuplet = exports.TupletNormal = exports.TupletActual = exports.TupletDot = exports.TupletType = exports.TupletNumber = exports.Slur = exports.Tied = exports.Beam = exports.Staff = exports.NoteheadText = exports.Notehead = exports.Stem = exports.TimeModification = exports.NormalDot = exports.NormalType = exports.NormalNotes = exports.ActualNotes = exports.Accidental = exports.Dot = exports.Type = exports.Voice = exports.Instrument = exports.Grace = exports.Cue = exports.Tie = exports.Duration = exports.Rest = exports.Unpitched = exports.DisplayOctave = exports.DisplayStep = exports.Pitch = exports.Octave = void 0;
exports.OtherTechnical = exports.Golpe = exports.HarmonMute = exports.HarmonClosed = exports.HalfMuted = exports.Open = exports.Smear = exports.Flip = exports.BrassBend = exports.Handbell = exports.Arrow = exports.CircularArrow = exports.Arrowhead = exports.ArrowStyle = exports.ArrowDirection = exports.Hole = exports.HoleShape = exports.HoleClosed = exports.HoleType = exports.Fingernails = exports.Toe = exports.Heel = exports.Tap = exports.Bend = exports.WithBar = exports.Release = exports.PreBend = exports.BendAlter = exports.PullOff = exports.HammerOn = exports.String = exports.Fret = exports.SnapPizzicato = exports.Stopped = exports.TripleTongue = exports.DoubleTongue = exports.Pluck = exports.Fingering = exports.ThumbPosition = exports.OpenString = exports.Harmonic = exports.SoundingPitch = exports.TouchingPitch = exports.BasePitch = exports.Artificial = exports.Natural = exports.DownBow = exports.UpBow = exports.Ornaments = exports.AccidentalMark = void 0;
exports.NonArpeggiate = exports.Arpeggiate = exports.Fermata = exports.Dynamics = exports.OtherDynamics = exports.Sfzp = exports.Pf = exports.N = exports.Fz = exports.Sffz = exports.Sfz = exports.Rfz = exports.Rf = exports.Fp = exports.Sfpp = exports.Sfp = exports.Sf = exports.Mf = exports.Mp = exports.Ffffff = exports.Fffff = exports.Ffff = exports.Fff = exports.Ff = exports.F = exports.Pppppp = exports.Ppppp = exports.Pppp = exports.Ppp = exports.Pp = exports.P = exports.Articulations = exports.OtherArticulation = exports.SoftAccent = exports.Unstress = exports.Stress = exports.Caesura = exports.BreathMark = exports.Falloff = exports.Doit = exports.Plop = exports.Scoop = exports.Spiccato = exports.Staccatissimo = exports.DetachedLegato = exports.Tenuto = exports.Staccato = exports.StrongAccent = exports.Accent = exports.Technical = void 0;
exports.HarpPedals = exports.PedalTuning = exports.PedalAlter = exports.PedalStep = exports.OctaveShift = exports.Metronome = exports.MetronomeRelation = exports.MetronomeNote = exports.MetronomeTuplet = exports.MetronomeTied = exports.MetronomeBeam = exports.MetronomeDot = exports.MetronomeType = exports.MetronomeArrows = exports.PerMinute = exports.BeatUnitTied = exports.BeatUnitDot = exports.BeatUnit = exports.Pedal = exports.Bracket = exports.Dashes = exports.Wedge = exports.Symbol = exports.Words = exports.Coda = exports.Segno = exports.Rehearsal = exports.Forward = exports.Backup = exports.Note = exports.Listen = exports.OtherListen = exports.Wait = exports.Assess = exports.Play = exports.OtherPlay = exports.SemiPitched = exports.Mute = exports.Ipa = exports.Lyric = exports.EndParagraph = exports.EndLine = exports.Humming = exports.Laughing = exports.Extend = exports.Elision = exports.Text = exports.Syllabic = exports.Notations = exports.OtherNotation = void 0;
exports.KeyStep = exports.Mode = exports.Fifths = exports.Cancel = exports.Divisions = exports.Direction = exports.Listening = exports.OtherListening = exports.Sync = exports.Sound = exports.Swing = exports.SwingStyle = exports.SwingType = exports.Second = exports.First = exports.Straight = exports.InstrumentChange = exports.Offset = exports.DirectionType = exports.OtherDirection = exports.StaffDivide = exports.AccordionRegistration = exports.AccordionLow = exports.AccordionMiddle = exports.AccordionHigh = exports.Percussion = exports.OtherPercussion = exports.StickLocation = exports.Stick = exports.StickMaterial = exports.StickType = exports.Beater = exports.Timpani = exports.Effect = exports.Membrane = exports.Pitched = exports.Wood = exports.Metal = exports.Glass = exports.PrincipalVoice = exports.Image = exports.Scordatura = exports.Accord = exports.TuningOctave = exports.TuningAlter = exports.TuningStep = exports.StringMute = exports.Eyeglasses = exports.DampAll = exports.Damp = void 0;
exports.NumeralKey = exports.NumeralMode = exports.NumeralFifths = exports.NumeralAlter = exports.NumeralRoot = exports.Root = exports.RootAlter = exports.RootStep = exports.Attributes = exports.MeasureStyle = exports.Slash = exports.BeatRepeat = exports.ExceptVoice = exports.SlashDot = exports.SlashType = exports.MeasureRepeat = exports.MultipleRest = exports.Directive = exports.ForPart = exports.PartTranspose = exports.PartClef = exports.Transpose = exports.Double = exports.OctaveChange = exports.Chromatic = exports.Diatonic = exports.StaffDetails = exports.StaffSize = exports.Capo = exports.StaffTuning = exports.LineDetail = exports.StaffLines = exports.StaffType = exports.Clef = exports.ClefOctaveChange = exports.Line = exports.Sign = exports.Instruments = exports.PartSymbol = exports.Staves = exports.Time = exports.SenzaMisura = exports.Interchangeable = exports.TimeRelation = exports.BeatType = exports.Beats = exports.Key = exports.KeyOctave = exports.KeyAccidental = exports.KeyAlter = void 0;
exports.ScoreTimewise = exports.MeasureTimewise = exports.PartTimewise = exports.ScorePartwise = exports.PartPartwise = exports.MeasurePartwise = exports.Grouping = exports.Feature = exports.Barline = exports.Repeat = exports.Ending = exports.BarStyle = exports.Print = exports.MeasureNumbering = exports.MeasureLayout = exports.MeasureDistance = exports.FiguredBass = exports.Figure = exports.Suffix = exports.FigureNumber = exports.Prefix = exports.Harmony = exports.Frame = exports.FrameNote = exports.Barre = exports.FirstFret = exports.FrameFrets = exports.FrameStrings = exports.Degree = exports.DegreeType = exports.DegreeAlter = exports.DegreeValue = exports.Bass = exports.BassAlter = exports.BassStep = exports.BassSeparator = exports.Inversion = exports.Kind = exports.Function = exports.Numeral = void 0;
/* eslint-disable @typescript-eslint/ban-types */
var operations = require("../lib/operations");
/**
 * The `<work-number>` element
 *
 * Parent element: `<work>`
 *
 * The `<work-number>` element specifies the number of a work, such as its opus number.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/work-number/}
 */
var WorkNumber = /** @class */ (function () {
    function WorkNumber(opts) {
        var _a;
        this.schema = WorkNumber.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, WorkNumber.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(WorkNumber.schema.contents);
    }
    /** Gets @type {string}. */
    WorkNumber.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    WorkNumber.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    WorkNumber.schema = { name: 'work-number', attributes: {}, contents: [{ type: 'string' }] };
    return WorkNumber;
}());
exports.WorkNumber = WorkNumber;
/**
 * The `<work-title>` element
 *
 * Parent element: `<work>`
 *
 * The `<work-title>` element specifies the title of a work, not including its opus or other work number.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/work-title/}
 */
var WorkTitle = /** @class */ (function () {
    function WorkTitle(opts) {
        var _a;
        this.schema = WorkTitle.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, WorkTitle.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(WorkTitle.schema.contents);
    }
    /** Gets @type {string}. */
    WorkTitle.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    WorkTitle.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    WorkTitle.schema = { name: 'work-title', attributes: {}, contents: [{ type: 'string' }] };
    return WorkTitle;
}());
exports.WorkTitle = WorkTitle;
/**
 * The `<opus>` element
 *
 * Parent element: `<work>`
 *
 * The `<opus>` element represents a link to a MusicXML opus document that composes multiple MusicXML scores into a
 * collection.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/opus-reference/}
 */
var Opus = /** @class */ (function () {
    function Opus(opts) {
        var _a;
        this.schema = Opus.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Opus.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Opus.schema.contents);
    }
    /** Gets @type {OpusAttributes['xlink:href']}. */
    Opus.prototype.getXlinkHref = function () {
        return this.attributes['xlink:href'];
    };
    /** Sets @type {OpusAttributes['xlink:href']}. */
    Opus.prototype.setXlinkHref = function (xlinkHref) {
        this.attributes['xlink:href'] = xlinkHref;
        return this;
    };
    /** Gets @type {OpusAttributes['xlink:actuate']}. */
    Opus.prototype.getXlinkActuate = function () {
        return this.attributes['xlink:actuate'];
    };
    /** Sets @type {OpusAttributes['xlink:actuate']}. */
    Opus.prototype.setXlinkActuate = function (xlinkActuate) {
        this.attributes['xlink:actuate'] = xlinkActuate;
        return this;
    };
    /** Gets @type {OpusAttributes['xlink:role']}. */
    Opus.prototype.getXlinkRole = function () {
        return this.attributes['xlink:role'];
    };
    /** Sets @type {OpusAttributes['xlink:role']}. */
    Opus.prototype.setXlinkRole = function (xlinkRole) {
        this.attributes['xlink:role'] = xlinkRole;
        return this;
    };
    /** Gets @type {OpusAttributes['xlink:show']}. */
    Opus.prototype.getXlinkShow = function () {
        return this.attributes['xlink:show'];
    };
    /** Sets @type {OpusAttributes['xlink:show']}. */
    Opus.prototype.setXlinkShow = function (xlinkShow) {
        this.attributes['xlink:show'] = xlinkShow;
        return this;
    };
    /** Gets @type {OpusAttributes['xlink:title']}. */
    Opus.prototype.getXlinkTitle = function () {
        return this.attributes['xlink:title'];
    };
    /** Sets @type {OpusAttributes['xlink:title']}. */
    Opus.prototype.setXlinkTitle = function (xlinkTitle) {
        this.attributes['xlink:title'] = xlinkTitle;
        return this;
    };
    /** Gets @type {OpusAttributes['xlink:type']}. */
    Opus.prototype.getXlinkType = function () {
        return this.attributes['xlink:type'];
    };
    /** Sets @type {OpusAttributes['xlink:type']}. */
    Opus.prototype.setXlinkType = function (xlinkType) {
        this.attributes['xlink:type'] = xlinkType;
        return this;
    };
    Opus.schema = {
        name: 'opus',
        attributes: {
            'xlink:href': { type: 'required', value: { type: 'string' } },
            'xlink:actuate': {
                type: 'optional',
                value: { type: 'choices', choices: ['none', 'onRequest', 'onLoad', 'other'] },
            },
            'xlink:role': { type: 'optional', value: { type: 'string' } },
            'xlink:show': {
                type: 'optional',
                value: { type: 'choices', choices: ['none', 'new', 'replace', 'embed', 'other'] },
            },
            'xlink:title': { type: 'optional', value: { type: 'string' } },
            'xlink:type': { type: 'optional', value: { type: 'choices', choices: ['simple'] } },
        },
        contents: [],
    };
    return Opus;
}());
exports.Opus = Opus;
/**
 * The `<work>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * Works are optionally identified by number and title. The `<work>` element also may indicate a link to the `<opus>`
 * document that composes multiple scores into a collection.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/work/}
 */
var Work = /** @class */ (function () {
    function Work(opts) {
        var _a;
        this.schema = Work.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Work.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Work.schema.contents);
    }
    /** Gets @type {WorkNumber | null}. */
    Work.prototype.getWorkNumber = function () {
        return this.contents[0];
    };
    /** Sets @type {WorkNumber | null}. */
    Work.prototype.setWorkNumber = function (workNumber) {
        this.contents[0] = workNumber;
        return this;
    };
    /** Gets @type {WorkTitle | null}. */
    Work.prototype.getWorkTitle = function () {
        return this.contents[1];
    };
    /** Sets @type {WorkTitle | null}. */
    Work.prototype.setWorkTitle = function (workTitle) {
        this.contents[1] = workTitle;
        return this;
    };
    /** Gets @type {Opus | null}. */
    Work.prototype.getOpus = function () {
        return this.contents[2];
    };
    /** Sets @type {Opus | null}. */
    Work.prototype.setOpus = function (opus) {
        this.contents[2] = opus;
        return this;
    };
    Work.schema = {
        name: 'work',
        attributes: {},
        contents: [
            { type: 'optional', value: WorkNumber },
            { type: 'optional', value: WorkTitle },
            { type: 'optional', value: Opus },
        ],
    };
    return Work;
}());
exports.Work = Work;
/**
 * The `<movement-number>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<movement-number>` element specifies the number of a movement.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/movement-number/}
 */
var MovementNumber = /** @class */ (function () {
    function MovementNumber(opts) {
        var _a;
        this.schema = MovementNumber.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MovementNumber.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MovementNumber.schema.contents);
    }
    /** Gets @type {string}. */
    MovementNumber.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    MovementNumber.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    MovementNumber.schema = { name: 'movement-number', attributes: {}, contents: [{ type: 'string' }] };
    return MovementNumber;
}());
exports.MovementNumber = MovementNumber;
/**
 * The `<movement-title>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<movement-title>` element specifies the title of a movement, not including its number.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/movement-title/}
 */
var MovementTitle = /** @class */ (function () {
    function MovementTitle(opts) {
        var _a;
        this.schema = MovementTitle.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MovementTitle.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MovementTitle.schema.contents);
    }
    /** Gets @type {string}. */
    MovementTitle.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    MovementTitle.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    MovementTitle.schema = { name: 'movement-title', attributes: {}, contents: [{ type: 'string' }] };
    return MovementTitle;
}());
exports.MovementTitle = MovementTitle;
/**
 * The `<creator>` element
 *
 * Parent elements: `<score-part>`, `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<identification>` element contains basic metadata about the score. It includes information that may apply at a
 * score-wide, movement-wide, or part-wide level. The `<creator>`, `<rights>`, `<source>`, and `<relation>` elements are
 * based on Dublin Core.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/identification/}
 */
var Creator = /** @class */ (function () {
    function Creator(opts) {
        var _a;
        this.schema = Creator.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Creator.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Creator.schema.contents);
    }
    /** Gets @type {CreatorAttributes['type']}. */
    Creator.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {CreatorAttributes['type']}. */
    Creator.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {string}. */
    Creator.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Creator.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Creator.schema = {
        name: 'creator',
        attributes: { type: { type: 'optional', value: { type: 'string' } } },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Creator;
}());
exports.Creator = Creator;
/**
 * The `<rights>` element
 *
 * Parent element: `<identification>`
 *
 * The `<rights>` element contains copyright and other intellectual property notices. This is similar to the Dublin
 * Core rights element. Words, music, and derivatives can have different types, so multiple <rights> elements with
 * different type attributes are supported.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/rights/}
 */
var Rights = /** @class */ (function () {
    function Rights(opts) {
        var _a;
        this.schema = Rights.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Rights.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Rights.schema.contents);
    }
    /** Gets @type {RightsAttributes['type']}. */
    Rights.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {RightsAttributes['type']}. */
    Rights.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {string}. */
    Rights.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Rights.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Rights.schema = {
        name: 'rights',
        attributes: { type: { type: 'optional', value: { type: 'string' } } },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Rights;
}());
exports.Rights = Rights;
/**
 * The `<encoding-date>` element
 *
 * Parent element: `<encoding>`
 *
 * The `<encoding-date>` element specifies the date of the digital encoding.
 */
var EncodingDate = /** @class */ (function () {
    function EncodingDate(opts) {
        var _a;
        this.schema = EncodingDate.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, EncodingDate.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(EncodingDate.schema.contents);
    }
    /** Gets @type {Date}. */
    EncodingDate.prototype.getYyyyMmDd = function () {
        return this.contents[0];
    };
    /** Sets @type {Date}. */
    EncodingDate.prototype.setYyyyMmDd = function (yyyyMmDd) {
        this.contents[0] = yyyyMmDd;
        return this;
    };
    EncodingDate.schema = {
        name: 'encoding-date',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'label', label: 'yyyy-mm-dd', value: { type: 'date' } } }],
    };
    return EncodingDate;
}());
exports.EncodingDate = EncodingDate;
/**
 * The `<encoder>` element
 *
 * Parent element: `<encoding>`
 *
 * The `<encoder>` element contains information about who did the digital encoding.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/encoder/}
 */
var Encoder = /** @class */ (function () {
    function Encoder(opts) {
        var _a;
        this.schema = Encoder.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Encoder.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Encoder.schema.contents);
    }
    /** Gets @type {EncoderAttributes['type']}. */
    Encoder.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {EncoderAttributes['type']}. */
    Encoder.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {string}. */
    Encoder.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Encoder.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Encoder.schema = {
        name: 'encoder',
        attributes: { type: { type: 'optional', value: { type: 'string' } } },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Encoder;
}());
exports.Encoder = Encoder;
/**
 * The `<software>` element
 *
 * Parent element: `<encoding>`
 *
 * The `<software>` element specifies what software created the digital encoding.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/software/}
 */
var Software = /** @class */ (function () {
    function Software(opts) {
        var _a;
        this.schema = Software.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Software.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Software.schema.contents);
    }
    /** Gets @type {string}. */
    Software.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Software.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Software.schema = { name: 'software', attributes: {}, contents: [{ type: 'string' }] };
    return Software;
}());
exports.Software = Software;
/**
 * The `<encoding-description>` element
 *
 * Parent element: `<encoding>`
 *
 * The `<encoding-description>` element contains descriptive information about the digital encoding that is not
 * provided in the other `<encoding>` child elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/encoding-description/}
 */
var EncodingDescription = /** @class */ (function () {
    function EncodingDescription(opts) {
        var _a;
        this.schema = EncodingDescription.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, EncodingDescription.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(EncodingDescription.schema.contents);
    }
    /** Gets @type {string}. */
    EncodingDescription.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    EncodingDescription.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    EncodingDescription.schema = {
        name: 'encoding-description',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return EncodingDescription;
}());
exports.EncodingDescription = EncodingDescription;
/**
 * The `<supports>` element
 *
 * Parent element: `<encoding>`
 *
 * The `<supports>` element indicates if a MusicXML encoding supports a particular MusicXML element. This is recommended
 * for elements like `<beam>`, `<stem>`, and `<accidental>`, where the absence of an element is ambiguous if you do not
 * know if the encoding supports that element. It also allows programs to indicate support for specific attributes, or
 * specific attributes with specific values. This lets applications communicate, for example, that all system and/or
 * page breaks are contained in the MusicXML file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/supports/}
 */
var Supports = /** @class */ (function () {
    function Supports(opts) {
        var _a;
        this.schema = Supports.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Supports.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Supports.schema.contents);
    }
    /** Gets @type {SupportsAttributes['element']}. */
    Supports.prototype.getElement = function () {
        return this.attributes['element'];
    };
    /** Sets @type {SupportsAttributes['element']}. */
    Supports.prototype.setElement = function (element) {
        this.attributes['element'] = element;
        return this;
    };
    /** Gets @type {SupportsAttributes['type']}. */
    Supports.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {SupportsAttributes['type']}. */
    Supports.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {SupportsAttributes['attribute']}. */
    Supports.prototype.getAttribute = function () {
        return this.attributes['attribute'];
    };
    /** Sets @type {SupportsAttributes['attribute']}. */
    Supports.prototype.setAttribute = function (attribute) {
        this.attributes['attribute'] = attribute;
        return this;
    };
    /** Gets @type {SupportsAttributes['value']}. */
    Supports.prototype.getValue = function () {
        return this.attributes['value'];
    };
    /** Sets @type {SupportsAttributes['value']}. */
    Supports.prototype.setValue = function (value) {
        this.attributes['value'] = value;
        return this;
    };
    Supports.schema = {
        name: 'supports',
        attributes: {
            element: { type: 'required', value: { type: 'string' } },
            type: { type: 'required', value: { type: 'choices', choices: ['yes', 'no'] } },
            attribute: { type: 'optional', value: { type: 'string' } },
            value: { type: 'optional', value: { type: 'string' } },
        },
        contents: [],
    };
    return Supports;
}());
exports.Supports = Supports;
/**
 * The `<encoding>` element
 *
 * Parent element: `<identification>`
 *
 * The `<encoding>` element contains information about who did the digital encoding, when, with what software, and in
 * what aspects.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/encoding/}
 */
var Encoding = /** @class */ (function () {
    function Encoding(opts) {
        var _a;
        this.schema = Encoding.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Encoding.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Encoding.schema.contents);
    }
    /** Gets @type {Array<[EncodingDate | null, Encoder | null, Software | null, EncodingDescription | null, Supports | null]>}. */
    Encoding.prototype.getEncodings = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<[EncodingDate | null, Encoder | null, Software | null, EncodingDescription | null, Supports | null]>}. */
    Encoding.prototype.setEncodings = function (encodings) {
        this.contents[0] = encodings;
        return this;
    };
    Encoding.schema = {
        name: 'encoding',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'encodings',
                value: {
                    type: 'zeroOrMore',
                    value: [
                        { type: 'optional', value: EncodingDate },
                        { type: 'optional', value: Encoder },
                        { type: 'optional', value: Software },
                        { type: 'optional', value: EncodingDescription },
                        { type: 'optional', value: Supports },
                    ],
                },
            },
        ],
    };
    return Encoding;
}());
exports.Encoding = Encoding;
/**
 * The `<source>` element
 *
 * Parent element: `<identification>`
 *
 * The `<source>` element describes the source for the music that is encoded. This is similar to the [Dublin Core source
 * element](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/source/).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/source/}
 */
var Source = /** @class */ (function () {
    function Source(opts) {
        var _a;
        this.schema = Source.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Source.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Source.schema.contents);
    }
    /** Gets @type {string | null}. */
    Source.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string | null}. */
    Source.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Source.schema = {
        name: 'source',
        attributes: {},
        contents: [{ type: 'optional', value: { type: 'string' } }],
    };
    return Source;
}());
exports.Source = Source;
/**
 * The `<relation>` element
 *
 * Parent element: `<identification>`
 *
 * The `<relation>` element describes a related resource for the music that is encoded. This is similar to the [Dublin
 * Core relation element](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/relation/).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/relation/}
 */
var Relation = /** @class */ (function () {
    function Relation(opts) {
        var _a;
        this.schema = Relation.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Relation.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Relation.schema.contents);
    }
    /** Gets @type {RelationAttributes['type']}. */
    Relation.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {RelationAttributes['type']}. */
    Relation.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {string}. */
    Relation.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Relation.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Relation.schema = {
        name: 'relation',
        attributes: { type: { type: 'optional', value: { type: 'string' } } },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Relation;
}());
exports.Relation = Relation;
/**
 * The `<miscellaneous-field>` element
 *
 * Parent element: `<miscellaneous>`
 *
 * If a program has other metadata not yet supported in the MusicXML format, each type of metadata can go in a'
 * `<miscellaneous-field>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/miscellaneous-field/}
 */
var MiscellaneousField = /** @class */ (function () {
    function MiscellaneousField(opts) {
        var _a;
        this.schema = MiscellaneousField.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MiscellaneousField.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MiscellaneousField.schema.contents);
    }
    /** Gets @type {MiscellaneousFieldAttributes['name']}. */
    MiscellaneousField.prototype.getName = function () {
        return this.attributes['name'];
    };
    /** Sets @type {MiscellaneousFieldAttributes['name']}. */
    MiscellaneousField.prototype.setName = function (name) {
        this.attributes['name'] = name;
        return this;
    };
    /** Gets @type {string}. */
    MiscellaneousField.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    MiscellaneousField.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    MiscellaneousField.schema = {
        name: 'miscellaneous-field',
        attributes: { name: { type: 'required', value: { type: 'string' } } },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return MiscellaneousField;
}());
exports.MiscellaneousField = MiscellaneousField;
/**
 * The `<miscellaneous>` element
 *
 * Parent element: `<identification>`
 *
 * If a program has other metadata not yet supported in the MusicXML format, it can go in the `<miscellaneous>` element.
 * The `<miscellaneous>` element puts each separate part of metadata into its own `<miscellaneous-field>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/miscellaneous/}
 */
var Miscellaneous = /** @class */ (function () {
    function Miscellaneous(opts) {
        var _a;
        this.schema = Miscellaneous.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Miscellaneous.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Miscellaneous.schema.contents);
    }
    /** Gets @type {Array<MiscellaneousField>}. */
    Miscellaneous.prototype.getMiscellaneousFields = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<MiscellaneousField>}. */
    Miscellaneous.prototype.setMiscellaneousFields = function (miscellaneousFields) {
        this.contents[0] = miscellaneousFields;
        return this;
    };
    Miscellaneous.schema = {
        name: 'miscellaneous',
        attributes: {},
        contents: [
            { type: 'label', label: 'miscellaneous-fields', value: { type: 'zeroOrMore', value: MiscellaneousField } },
        ],
    };
    return Miscellaneous;
}());
exports.Miscellaneous = Miscellaneous;
/**
 * The `<identification>` element
 *
 * Parent elements: `<score-part>`, `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<identification>` element contains basic metadata about the score. It includes information that may apply at a
 * score-wide, movement-wide, or part-wide level. The `<creator>`, `<rights>`, `<source>`, and `<relation>` elements are
 * based on Dublin Core.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/identification/}
 */
var Identification = /** @class */ (function () {
    function Identification(opts) {
        var _a;
        this.schema = Identification.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Identification.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Identification.schema.contents);
    }
    /** Gets @type {Array<Creator>}. */
    Identification.prototype.getCreators = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Creator>}. */
    Identification.prototype.setCreators = function (creators) {
        this.contents[0] = creators;
        return this;
    };
    /** Gets @type {Array<Rights>}. */
    Identification.prototype.getRights = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<Rights>}. */
    Identification.prototype.setRights = function (rights) {
        this.contents[1] = rights;
        return this;
    };
    /** Gets @type {Encoding | null}. */
    Identification.prototype.getEncoding = function () {
        return this.contents[2];
    };
    /** Sets @type {Encoding | null}. */
    Identification.prototype.setEncoding = function (encoding) {
        this.contents[2] = encoding;
        return this;
    };
    /** Gets @type {Source | null}. */
    Identification.prototype.getSource = function () {
        return this.contents[3];
    };
    /** Sets @type {Source | null}. */
    Identification.prototype.setSource = function (source) {
        this.contents[3] = source;
        return this;
    };
    /** Gets @type {Array<Relation>}. */
    Identification.prototype.getRelations = function () {
        return this.contents[4];
    };
    /** Sets @type {Array<Relation>}. */
    Identification.prototype.setRelations = function (relations) {
        this.contents[4] = relations;
        return this;
    };
    /** Gets @type {Miscellaneous | null}. */
    Identification.prototype.getMiscellaneous = function () {
        return this.contents[5];
    };
    /** Sets @type {Miscellaneous | null}. */
    Identification.prototype.setMiscellaneous = function (miscellaneous) {
        this.contents[5] = miscellaneous;
        return this;
    };
    Identification.schema = {
        name: 'identification',
        attributes: {},
        contents: [
            { type: 'label', label: 'creators', value: { type: 'zeroOrMore', value: Creator } },
            { type: 'label', label: 'rights', value: { type: 'zeroOrMore', value: Rights } },
            { type: 'optional', value: Encoding },
            { type: 'optional', value: Source },
            { type: 'label', label: 'relations', value: { type: 'zeroOrMore', value: Relation } },
            { type: 'optional', value: Miscellaneous },
        ],
    };
    return Identification;
}());
exports.Identification = Identification;
/**
 * The `<millimeters>` element
 *
 * Parent element: `<scaling>`
 *
 * The `<millimeters>` element contains the number of millimeters that correspond to the given number of tenths within
 * the `<scaling>` element formula.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/millimeters/}
 */
var Millimeters = /** @class */ (function () {
    function Millimeters(opts) {
        var _a;
        this.schema = Millimeters.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Millimeters.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Millimeters.schema.contents);
    }
    /** Gets @type {number}. */
    Millimeters.prototype.getMillimeters = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Millimeters.prototype.setMillimeters = function (millimeters) {
        this.contents[0] = millimeters;
        return this;
    };
    Millimeters.schema = {
        name: 'millimeters',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'millimeters', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return Millimeters;
}());
exports.Millimeters = Millimeters;
/**
 * The `<tenths>` element
 *
 * Parent element: `<scaling>`
 *
 * The `<tenths>` element contains the number of tenths that correspond to the given number of millimeters within the
 * `<scaling>` element formula. Setting this to 40 allows the `<millimeters>` element to specify the size of a 5-line
 * staff.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tenths/}
 */
var Tenths = /** @class */ (function () {
    function Tenths(opts) {
        var _a;
        this.schema = Tenths.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Tenths.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Tenths.schema.contents);
    }
    /** Gets @type {number}. */
    Tenths.prototype.getTenthsValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Tenths.prototype.setTenthsValue = function (tenthsValue) {
        this.contents[0] = tenthsValue;
        return this;
    };
    Tenths.schema = {
        name: 'tenths',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'tenths-value',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return Tenths;
}());
exports.Tenths = Tenths;
/**
 * The `<scaling>` element
 *
 * Parent element: `<defaults>`
 *
 * Margins, page sizes, and distances are all measured in tenths to keep MusicXML data in a consistent coordinate system
 * as much as possible. The translation to absolute units is done with the `<scaling>` element, which specifies how many
 * millimeters are equal to how many tenths. For a staff height of 7 mm, `<millimeters>` would be set to 7 while
 * `<tenths>` is set to 40. The ability to set a formula rather than a single scaling factor helps avoid roundoff errors.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/scaling/}
 */
var Scaling = /** @class */ (function () {
    function Scaling(opts) {
        var _a;
        this.schema = Scaling.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Scaling.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Scaling.schema.contents);
    }
    /** Gets @type {Millimeters}. */
    Scaling.prototype.getMillimeters = function () {
        return this.contents[0];
    };
    /** Sets @type {Millimeters}. */
    Scaling.prototype.setMillimeters = function (millimeters) {
        this.contents[0] = millimeters;
        return this;
    };
    /** Gets @type {Tenths}. */
    Scaling.prototype.getTenths = function () {
        return this.contents[1];
    };
    /** Sets @type {Tenths}. */
    Scaling.prototype.setTenths = function (tenths) {
        this.contents[1] = tenths;
        return this;
    };
    Scaling.schema = {
        name: 'scaling',
        attributes: {},
        contents: [
            { type: 'required', value: Millimeters },
            { type: 'required', value: Tenths },
        ],
    };
    return Scaling;
}());
exports.Scaling = Scaling;
/**
 * The `<concert-score>` element
 *
 * Parent element: `<defaults>`
 *
 * The presence of a `<concert-score>` element indicates that a score is displayed in concert pitch. It is used for
 * scores that contain parts for transposing instruments.
 *
 * A document with a `<concert-score>` element may not contain any `<transpose>` elements that have non-zero values for
 * either the `<diatonic>` or `<chromatic>` elements. Concert scores may include octave transpositions, so `<transpose>`
 * elements with a `<double>` element or a non-zero `<octave-change>` element value are permitted.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/concert-score/}
 */
var ConcertScore = /** @class */ (function () {
    function ConcertScore(opts) {
        var _a;
        this.schema = ConcertScore.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ConcertScore.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ConcertScore.schema.contents);
    }
    ConcertScore.schema = { name: 'concert-score', attributes: {}, contents: [] };
    return ConcertScore;
}());
exports.ConcertScore = ConcertScore;
/**
 * The `<page-height>` element
 *
 * Parent element: `<page-layout>`
 *
 * The `<page-height>` element specifies the page height in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/page-height/}
 */
var PageHeight = /** @class */ (function () {
    function PageHeight(opts) {
        var _a;
        this.schema = PageHeight.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PageHeight.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PageHeight.schema.contents);
    }
    /** Gets @type {number}. */
    PageHeight.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    PageHeight.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    PageHeight.schema = {
        name: 'page-height',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return PageHeight;
}());
exports.PageHeight = PageHeight;
/**
 * The `<page-width>` element
 *
 * Parent element: `<page-layout>`
 *
 * The `<page-width>` element specifies the page width in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/page-width/}
 */
var PageWidth = /** @class */ (function () {
    function PageWidth(opts) {
        var _a;
        this.schema = PageWidth.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PageWidth.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PageWidth.schema.contents);
    }
    /** Gets @type {number}. */
    PageWidth.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    PageWidth.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    PageWidth.schema = {
        name: 'page-width',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return PageWidth;
}());
exports.PageWidth = PageWidth;
/**
 * The `<left-margin>` element
 *
 * Parent elements: `<page-margins>`, `<system-margins>`
 *
 * The `<left-margin>` element specifies the left margin for the parent element in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/left-margin/}
 */
var LeftMargin = /** @class */ (function () {
    function LeftMargin(opts) {
        var _a;
        this.schema = LeftMargin.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, LeftMargin.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(LeftMargin.schema.contents);
    }
    /** Gets @type {number}. */
    LeftMargin.prototype.getLeftMargin = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    LeftMargin.prototype.setLeftMargin = function (leftMargin) {
        this.contents[0] = leftMargin;
        return this;
    };
    LeftMargin.schema = {
        name: 'left-margin',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'left-margin',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return LeftMargin;
}());
exports.LeftMargin = LeftMargin;
/**
 * The `<right-margin>` element
 *
 * Parent elements: `<page-margins>`, `<system-margins>`
 *
 * The `<right-margin>` element specifies the right margin for the parent element in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/right-margin/}
 */
var RightMargin = /** @class */ (function () {
    function RightMargin(opts) {
        var _a;
        this.schema = RightMargin.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, RightMargin.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(RightMargin.schema.contents);
    }
    /** Gets @type {number}. */
    RightMargin.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    RightMargin.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    RightMargin.schema = {
        name: 'right-margin',
        attributes: {},
        contents: [{ type: 'label', label: 'value', value: { type: 'float', min: -Infinity, max: Infinity } }],
    };
    return RightMargin;
}());
exports.RightMargin = RightMargin;
/**
 * The `<top-margin>` element
 *
 * Parent element: `<page-margins>`
 *
 * The `<top-margin>` element specifies the top page margin in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/top-margin/}
 */
var TopMargin = /** @class */ (function () {
    function TopMargin(opts) {
        var _a;
        this.schema = TopMargin.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TopMargin.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TopMargin.schema.contents);
    }
    /** Gets @type {number}. */
    TopMargin.prototype.getTopMarginValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    TopMargin.prototype.setTopMarginValue = function (topMarginValue) {
        this.contents[0] = topMarginValue;
        return this;
    };
    TopMargin.schema = {
        name: 'top-margin',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'top-margin-value',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return TopMargin;
}());
exports.TopMargin = TopMargin;
/**
 * The `<bottom-margin>` element
 *
 * Parent element: `<page-margins>`
 *
 * The `<bottom-margin>` element specifies the bottom page margin in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bottom-margin/}
 */
var BottomMargin = /** @class */ (function () {
    function BottomMargin(opts) {
        var _a;
        this.schema = BottomMargin.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BottomMargin.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BottomMargin.schema.contents);
    }
    /** Gets @type {number}. */
    BottomMargin.prototype.getBottomMargin = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    BottomMargin.prototype.setBottomMargin = function (bottomMargin) {
        this.contents[0] = bottomMargin;
        return this;
    };
    BottomMargin.schema = {
        name: 'bottom-margin',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'bottom-margin',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return BottomMargin;
}());
exports.BottomMargin = BottomMargin;
/**
 * The `<page-margins>` element
 *
 * Parent element: `<page-layout>`
 *
 * The `<page-margins>` element specifies page margins in tenths either for both even and odd pages, or via separate odd
 * and even page number values.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/page-margins/}
 */
var PageMargins = /** @class */ (function () {
    function PageMargins(opts) {
        var _a;
        this.schema = PageMargins.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PageMargins.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PageMargins.schema.contents);
    }
    /** Gets @type {PageMarginsAttributes['type']}. */
    PageMargins.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {PageMarginsAttributes['type']}. */
    PageMargins.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {LeftMargin}. */
    PageMargins.prototype.getLeftMargin = function () {
        return this.contents[0];
    };
    /** Sets @type {LeftMargin}. */
    PageMargins.prototype.setLeftMargin = function (leftMargin) {
        this.contents[0] = leftMargin;
        return this;
    };
    /** Gets @type {RightMargin}. */
    PageMargins.prototype.getRightMargin = function () {
        return this.contents[1];
    };
    /** Sets @type {RightMargin}. */
    PageMargins.prototype.setRightMargin = function (rightMargin) {
        this.contents[1] = rightMargin;
        return this;
    };
    /** Gets @type {TopMargin}. */
    PageMargins.prototype.getTopMargin = function () {
        return this.contents[2];
    };
    /** Sets @type {TopMargin}. */
    PageMargins.prototype.setTopMargin = function (topMargin) {
        this.contents[2] = topMargin;
        return this;
    };
    /** Gets @type {BottomMargin}. */
    PageMargins.prototype.getBottomMargin = function () {
        return this.contents[3];
    };
    /** Sets @type {BottomMargin}. */
    PageMargins.prototype.setBottomMargin = function (bottomMargin) {
        this.contents[3] = bottomMargin;
        return this;
    };
    PageMargins.schema = {
        name: 'page-margins',
        attributes: { type: { type: 'optional', value: { type: 'choices', choices: ['both', 'even', 'odd'] } } },
        contents: [
            { type: 'required', value: LeftMargin },
            { type: 'required', value: RightMargin },
            { type: 'required', value: TopMargin },
            { type: 'required', value: BottomMargin },
        ],
    };
    return PageMargins;
}());
exports.PageMargins = PageMargins;
/**
 * The `<page-layout>` element
 *
 * Parent elements: `<defaults>`, `<print>`
 *
 * Page layout can be defined both in score-wide `<defaults>` and in the `<print>` element. If no `<page-layout>`
 * element is present in the `<defaults>` element, default page layout values are chosen by the application.
 *
 * When used in the `<print>` element, the `<page-layout>` element affects the appearance of the current page only. All
 * other pages use the default values as determined by the `<defaults>` element. If any child elements are missing from
 * the `<page-layout>` element in a `<print>` element, the values determined by the <defaults> element are used there
 * as well.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/page-layout/}
 */
var PageLayout = /** @class */ (function () {
    function PageLayout(opts) {
        var _a;
        this.schema = PageLayout.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PageLayout.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PageLayout.schema.contents);
    }
    /** Gets @type {PageHeight | null}. */
    PageLayout.prototype.getPageHeight = function () {
        return this.contents[0];
    };
    /** Sets @type {PageHeight | null}. */
    PageLayout.prototype.setPageHeight = function (pageHeight) {
        this.contents[0] = pageHeight;
        return this;
    };
    /** Gets @type {PageWidth | null}. */
    PageLayout.prototype.getPageWidth = function () {
        return this.contents[1];
    };
    /** Sets @type {PageWidth | null}. */
    PageLayout.prototype.setPageWidth = function (pageWidth) {
        this.contents[1] = pageWidth;
        return this;
    };
    /** Gets @type {[] | [PageMargins] | [PageMargins, PageMargins]}. */
    PageLayout.prototype.getPageMargins = function () {
        return this.contents[2];
    };
    /** Sets @type {[] | [PageMargins] | [PageMargins, PageMargins]}. */
    PageLayout.prototype.setPageMargins = function (pageMargins) {
        this.contents[2] = pageMargins;
        return this;
    };
    PageLayout.schema = {
        name: 'page-layout',
        attributes: {},
        contents: [
            { type: 'optional', value: PageHeight },
            { type: 'optional', value: PageWidth },
            {
                type: 'label',
                label: 'page-margins',
                value: { type: 'choices', choices: [[], [PageMargins], [PageMargins, PageMargins]] },
            },
        ],
    };
    return PageLayout;
}());
exports.PageLayout = PageLayout;
/**
 * The `<system-margins>` element
 *
 * Parent element: `<system-layout>`
 *
 * System margins are relative to the page margins. Positive values indent and negative values reduce the margin size.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/system-margins/}
 */
var SystemMargins = /** @class */ (function () {
    function SystemMargins(opts) {
        var _a;
        this.schema = SystemMargins.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SystemMargins.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SystemMargins.schema.contents);
    }
    /** Gets @type {LeftMargin}. */
    SystemMargins.prototype.getLeftMargin = function () {
        return this.contents[0];
    };
    /** Sets @type {LeftMargin}. */
    SystemMargins.prototype.setLeftMargin = function (leftMargin) {
        this.contents[0] = leftMargin;
        return this;
    };
    /** Gets @type {RightMargin}. */
    SystemMargins.prototype.getRightMargin = function () {
        return this.contents[1];
    };
    /** Sets @type {RightMargin}. */
    SystemMargins.prototype.setRightMargin = function (rightMargin) {
        this.contents[1] = rightMargin;
        return this;
    };
    SystemMargins.schema = {
        name: 'system-margins',
        attributes: {},
        contents: [
            { type: 'required', value: LeftMargin },
            { type: 'required', value: RightMargin },
        ],
    };
    return SystemMargins;
}());
exports.SystemMargins = SystemMargins;
/**
 * The `<system-distance>` element
 *
 * Parent element: `<system-layout>`
 *
 * The `<system-distance>` is measured from the bottom line of the previous system to the top line of the current
 * system. It is ignored for the first system on a page.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/system-distance/}
 */
var SystemDistance = /** @class */ (function () {
    function SystemDistance(opts) {
        var _a;
        this.schema = SystemDistance.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SystemDistance.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SystemDistance.schema.contents);
    }
    /** Gets @type {number}. */
    SystemDistance.prototype.getSystemDistanceValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    SystemDistance.prototype.setSystemDistanceValue = function (systemDistanceValue) {
        this.contents[0] = systemDistanceValue;
        return this;
    };
    SystemDistance.schema = {
        name: 'system-distance',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'system-distance-value',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return SystemDistance;
}());
exports.SystemDistance = SystemDistance;
/**
 * The `<top-system-distance>` element
 *
 * Parent element: `<system-layout>`
 *
 * The `<top-system-distance>` is measured from the page's top margin to the top line of the first system. It is ignored
 * for all but the first system on a page.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/top-system-distance/}
 */
var TopSystemDistance = /** @class */ (function () {
    function TopSystemDistance(opts) {
        var _a;
        this.schema = TopSystemDistance.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TopSystemDistance.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TopSystemDistance.schema.contents);
    }
    /** Gets @type {number}. */
    TopSystemDistance.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    TopSystemDistance.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    TopSystemDistance.schema = {
        name: 'top-system-distance',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return TopSystemDistance;
}());
exports.TopSystemDistance = TopSystemDistance;
/**
 * The `<system-layout>` element
 *
 * Parent elements: `<defaults>`, `<print>`
 *
 * A system is a group of staves that are read and played simultaneously. The `<system-layout>` element includes left
 * and right margins and the vertical distance from the previous system.
 *
 * Sometimes the sum of measure widths in a system may not equal the system width specified by the layout elements due
 * to roundoff or other errors. The behavior when reading MusicXML files in these cases is application-dependent. For
 * instance, applications may find that the system layout data is more reliable than the sum of the measure widths, and
 * adjust the measure widths accordingly.
 *
 * When used in the `<defaults>` element, the `<system-layout>` element defines a default appearance for all systems in
 * the score. If no `<system-layout>` element is present in the `<defaults>` element, default system layout values are
 * chosen by the application.
 *
 * When used in the `<print>` element, the `<system-layout>` element affects the appearance of the current system only.
 * All other systems use the default values as determined by the `<defaults>` element. If any child elements are missing
 * from the `<system-layout>` element in a `<print>` element, the values determined by the `<defaults>` element are used
 * there as well. This type of `<system-layout>` element need only be read from or written to the first visible part in
 * the score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/system-layout/}
 */
var SystemLayout = /** @class */ (function () {
    function SystemLayout(opts) {
        var _a;
        this.schema = SystemLayout.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SystemLayout.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SystemLayout.schema.contents);
    }
    /** Gets @type {SystemMargins | null}. */
    SystemLayout.prototype.getSystemMargins = function () {
        return this.contents[0];
    };
    /** Sets @type {SystemMargins | null}. */
    SystemLayout.prototype.setSystemMargins = function (systemMargins) {
        this.contents[0] = systemMargins;
        return this;
    };
    /** Gets @type {SystemDistance | null}. */
    SystemLayout.prototype.getSystemDistance = function () {
        return this.contents[1];
    };
    /** Sets @type {SystemDistance | null}. */
    SystemLayout.prototype.setSystemDistance = function (systemDistance) {
        this.contents[1] = systemDistance;
        return this;
    };
    /** Gets @type {TopSystemDistance | null}. */
    SystemLayout.prototype.getTopSystemDistance = function () {
        return this.contents[2];
    };
    /** Sets @type {TopSystemDistance | null}. */
    SystemLayout.prototype.setTopSystemDistance = function (topSystemDistance) {
        this.contents[2] = topSystemDistance;
        return this;
    };
    SystemLayout.schema = {
        name: 'system-layout',
        attributes: {},
        contents: [
            { type: 'optional', value: SystemMargins },
            { type: 'optional', value: SystemDistance },
            { type: 'optional', value: TopSystemDistance },
        ],
    };
    return SystemLayout;
}());
exports.SystemLayout = SystemLayout;
/**
 * The `<staff-distance>` element
 *
 * Parent element: `<staff-layout>`
 *
 * The `<staff-distance> element represents the vertical distance from the bottom line of the previous staff in this
 * system to the top line of the current staff.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-distance/}
 */
var StaffDistance = /** @class */ (function () {
    function StaffDistance(opts) {
        var _a;
        this.schema = StaffDistance.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StaffDistance.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StaffDistance.schema.contents);
    }
    /** Gets @type {number}. */
    StaffDistance.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    StaffDistance.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    StaffDistance.schema = {
        name: 'staff-distance',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return StaffDistance;
}());
exports.StaffDistance = StaffDistance;
/**
 * The `<defaults>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<defaults>` element specifies score-wide defaults for scaling; whether or not the file is a concert score;
 * layout; and default values for the music font, word font, lyric font, and lyric language. Except for the
 * `<concert-score>` element, if any defaults are missing, the choice of what to use is determined by the application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/defaults/}
 */
var StaffLayout = /** @class */ (function () {
    function StaffLayout(opts) {
        var _a;
        this.schema = StaffLayout.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StaffLayout.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StaffLayout.schema.contents);
    }
    /** Gets @type {StaffLayoutAttributes['number']}. */
    StaffLayout.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {StaffLayoutAttributes['number']}. */
    StaffLayout.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {StaffDistance | null}. */
    StaffLayout.prototype.getStaffDistance = function () {
        return this.contents[0];
    };
    /** Sets @type {StaffDistance | null}. */
    StaffLayout.prototype.setStaffDistance = function (staffDistance) {
        this.contents[0] = staffDistance;
        return this;
    };
    StaffLayout.schema = {
        name: 'staff-layout',
        attributes: { number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } } },
        contents: [{ type: 'optional', value: StaffDistance }],
    };
    return StaffLayout;
}());
exports.StaffLayout = StaffLayout;
/**
 * The `<line-width>` element
 *
 * Parent element: `<appearance>`
 *
 * The `<line-width>` element indicates the width of a specific line type in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/line-width/}
 */
var LineWidth = /** @class */ (function () {
    function LineWidth(opts) {
        var _a;
        this.schema = LineWidth.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, LineWidth.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(LineWidth.schema.contents);
    }
    /** Gets @type {LineWidthAttributes['type']}. */
    LineWidth.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {LineWidthAttributes['type']}. */
    LineWidth.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {number}. */
    LineWidth.prototype.getLineWidth = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    LineWidth.prototype.setLineWidth = function (lineWidth) {
        this.contents[0] = lineWidth;
        return this;
    };
    LineWidth.schema = {
        name: 'line-width',
        attributes: {
            type: {
                type: 'required',
                value: {
                    type: 'choices',
                    choices: [
                        'beam',
                        'bracket',
                        'dashes',
                        'enclosure',
                        'ending',
                        'extend',
                        'heavy barline',
                        'leger',
                        'light barline',
                        'octave shift',
                        'pedal',
                        'slur middle',
                        'slur tip',
                        'staff',
                        'stem',
                        'tie middle',
                        'tie tip',
                        'tuplet bracket',
                        'wedge',
                    ],
                },
            },
        },
        contents: [
            {
                type: 'label',
                label: 'line-width',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return LineWidth;
}());
exports.LineWidth = LineWidth;
/**
 * The `<note-size>` element
 *
 * Parent element: `<appearance>`
 *
 * The `<note-size>` element indicates the numeric percentage of the regular note size to use for notes with cue and
 * large size, as defined in the `<type>` element. A value of 100 would be identical to the size of a regular note as
 * defined by the music font.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/note-size/}
 */
var NoteSize = /** @class */ (function () {
    function NoteSize(opts) {
        var _a;
        this.schema = NoteSize.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NoteSize.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NoteSize.schema.contents);
    }
    /** Gets @type {NoteSizeAttributes['type']}. */
    NoteSize.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {NoteSizeAttributes['type']}. */
    NoteSize.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {number}. */
    NoteSize.prototype.getNoteSize = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    NoteSize.prototype.setNoteSize = function (noteSize) {
        this.contents[0] = noteSize;
        return this;
    };
    NoteSize.schema = {
        name: 'note-size',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['cue', 'grace', 'grace-cue', 'large'] } },
        },
        contents: [{ type: 'label', label: 'note-size', value: { type: 'float', min: 0, max: Infinity } }],
    };
    return NoteSize;
}());
exports.NoteSize = NoteSize;
/**
 * The `<distance>` element
 *
 * Parent element: `<appearance>`
 *
 * The `<distance>` element represents standard distances between notation elements in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/distance/}
 */
var Distance = /** @class */ (function () {
    function Distance(opts) {
        var _a;
        this.schema = Distance.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Distance.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Distance.schema.contents);
    }
    /** Gets @type {DistanceAttributes['type']}. */
    Distance.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {DistanceAttributes['type']}. */
    Distance.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {number}. */
    Distance.prototype.getDistance = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Distance.prototype.setDistance = function (distance) {
        this.contents[0] = distance;
        return this;
    };
    Distance.schema = {
        name: 'distance',
        attributes: { type: { type: 'required', value: { type: 'choices', choices: ['beam', 'hyphen'] } } },
        contents: [
            {
                type: 'label',
                label: 'distance',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return Distance;
}());
exports.Distance = Distance;
/**
 * The `<glyph>` element
 *
 * Parent element: `<appearance>`
 *
 * The `<glyph>` element represents what Standard Music Font Layout (SMuFL) glyph should be used for different
 * variations of symbols that are semantically identical. The type attribute specifies what type of glyph is being
 * defined. The element value specifies what SMuFL canonical glyph name to use, including recommended stylistic
 * alternates.
 *
 * The SMuFL canonical glyph name should match the type. For instance, a type of quarter-rest would use values
 * restQuarter, restQuarterOld, or restQuarterZ. A type of g-clef-ottava-bassa would use values gClef8vb, gClef8vbOld,
 * or gClef8vbCClef. A type of octave-shift-up-8 would use values ottava, ottavaBassa, ottavaBassaBa, ottavaBassaVb, or
 * octaveBassa.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/glyph/}
 */
var Glyph = /** @class */ (function () {
    function Glyph(opts) {
        var _a;
        this.schema = Glyph.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Glyph.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Glyph.schema.contents);
    }
    /** Gets @type {GlyphAttributes['type']}. */
    Glyph.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {GlyphAttributes['type']}. */
    Glyph.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {string}. */
    Glyph.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Glyph.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Glyph.schema = {
        name: 'glyph',
        attributes: {
            type: {
                type: 'required',
                value: {
                    type: 'choices',
                    choices: [
                        'quarter-rest',
                        'g-clef-ottava-bassa',
                        'c-clef',
                        'f-clef',
                        'percussion-clef',
                        'octave-shift-up-8',
                        'octave-shift-down-8',
                        'octave-shift-down-15',
                        'octave-shift-continue-15',
                        'octave-shift-down-22',
                        'octave-shift-up-22',
                        'octave-shift-continue-22',
                    ],
                },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Glyph;
}());
exports.Glyph = Glyph;
/**
 * The `<other-appearance>` element
 *
 * Parent element: `<appearance>`
 *
 * The `<other-appearance>` element is used to define any graphical settings not yet in the current version of the
 * MusicXML format. This allows extended representation, though without application interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-appearance/}
 */
var OtherAppearance = /** @class */ (function () {
    function OtherAppearance(opts) {
        var _a;
        this.schema = OtherAppearance.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherAppearance.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherAppearance.schema.contents);
    }
    /** Gets @type {OtherAppearanceAttributes['type']}. */
    OtherAppearance.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {OtherAppearanceAttributes['type']}. */
    OtherAppearance.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {string}. */
    OtherAppearance.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    OtherAppearance.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    OtherAppearance.schema = {
        name: 'other-appearance',
        attributes: { type: { type: 'required', value: { type: 'string' } } },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return OtherAppearance;
}());
exports.OtherAppearance = OtherAppearance;
/**
 * The `<appearance>` element
 *
 * Parent element: `<defaults>`
 *
 * The `<appearance>` element controls general graphical settings for the music's final form appearance on a printed
 * page of display. This includes support for line widths, definitions for note sizes, standard distances between
 * notation elements, and Standard Music Font Layout (SMuFL) glyphs, plus an extension element for other aspects of
 * appearance.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/appearance/}
 */
var Appearance = /** @class */ (function () {
    function Appearance(opts) {
        var _a;
        this.schema = Appearance.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Appearance.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Appearance.schema.contents);
    }
    /** Gets @type {Array<LineWidth>}. */
    Appearance.prototype.getLineWidths = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<LineWidth>}. */
    Appearance.prototype.setLineWidths = function (lineWidths) {
        this.contents[0] = lineWidths;
        return this;
    };
    /** Gets @type {Array<NoteSize>}. */
    Appearance.prototype.getNoteSizes = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<NoteSize>}. */
    Appearance.prototype.setNoteSizes = function (noteSizes) {
        this.contents[1] = noteSizes;
        return this;
    };
    /** Gets @type {Array<Distance>}. */
    Appearance.prototype.getDistances = function () {
        return this.contents[2];
    };
    /** Sets @type {Array<Distance>}. */
    Appearance.prototype.setDistances = function (distances) {
        this.contents[2] = distances;
        return this;
    };
    /** Gets @type {Array<Glyph>}. */
    Appearance.prototype.getGlyphs = function () {
        return this.contents[3];
    };
    /** Sets @type {Array<Glyph>}. */
    Appearance.prototype.setGlyphs = function (glyphs) {
        this.contents[3] = glyphs;
        return this;
    };
    /** Gets @type {Array<OtherAppearance>}. */
    Appearance.prototype.getOtherAppearances = function () {
        return this.contents[4];
    };
    /** Sets @type {Array<OtherAppearance>}. */
    Appearance.prototype.setOtherAppearances = function (otherAppearances) {
        this.contents[4] = otherAppearances;
        return this;
    };
    Appearance.schema = {
        name: 'appearance',
        attributes: {},
        contents: [
            { type: 'label', label: 'line-widths', value: { type: 'zeroOrMore', value: LineWidth } },
            { type: 'label', label: 'note-sizes', value: { type: 'zeroOrMore', value: NoteSize } },
            { type: 'label', label: 'distances', value: { type: 'zeroOrMore', value: Distance } },
            { type: 'label', label: 'glyphs', value: { type: 'zeroOrMore', value: Glyph } },
            { type: 'label', label: 'other-appearances', value: { type: 'zeroOrMore', value: OtherAppearance } },
        ],
    };
    return Appearance;
}());
exports.Appearance = Appearance;
/**
 * The `<music-font>` element
 *
 * Parent element: `<defaults>`
 *
 * The `<music-font>` element represents the default values for the music font in the score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/music-font/}
 */
var MusicFont = /** @class */ (function () {
    function MusicFont(opts) {
        var _a;
        this.schema = MusicFont.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MusicFont.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MusicFont.schema.contents);
    }
    /** Gets @type {MusicFontAttributes['font-family']}. */
    MusicFont.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {MusicFontAttributes['font-family']}. */
    MusicFont.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {MusicFontAttributes['font-size']}. */
    MusicFont.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {MusicFontAttributes['font-size']}. */
    MusicFont.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {MusicFontAttributes['font-style']}. */
    MusicFont.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {MusicFontAttributes['font-style']}. */
    MusicFont.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {MusicFontAttributes['font-weight']}. */
    MusicFont.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {MusicFontAttributes['font-weight']}. */
    MusicFont.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    MusicFont.schema = {
        name: 'music-font',
        attributes: {
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
        },
        contents: [],
    };
    return MusicFont;
}());
exports.MusicFont = MusicFont;
/**
 * The `<defaults>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<defaults>` element specifies score-wide defaults for scaling; whether or not the file is a concert score;
 * layout; and default values for the music font, word font, lyric font, and lyric language. Except for the
 * `<concert-score>` element, if any defaults are missing, the choice of what to use is determined by the application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/defaults/}
 */
var WordFont = /** @class */ (function () {
    function WordFont(opts) {
        var _a;
        this.schema = WordFont.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, WordFont.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(WordFont.schema.contents);
    }
    /** Gets @type {WordFontAttributes['font-family']}. */
    WordFont.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {WordFontAttributes['font-family']}. */
    WordFont.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {WordFontAttributes['font-size']}. */
    WordFont.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {WordFontAttributes['font-size']}. */
    WordFont.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {WordFontAttributes['font-style']}. */
    WordFont.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {WordFontAttributes['font-style']}. */
    WordFont.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {WordFontAttributes['font-weight']}. */
    WordFont.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {WordFontAttributes['font-weight']}. */
    WordFont.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    WordFont.schema = {
        name: 'word-font',
        attributes: {
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
        },
        contents: [],
    };
    return WordFont;
}());
exports.WordFont = WordFont;
/**
 * The `<defaults>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<defaults>` element specifies score-wide defaults for scaling; whether or not the file is a concert score;
 * layout; and default values for the music font, word font, lyric font, and lyric language. Except for the
 * `<concert-score>` element, if any defaults are missing, the choice of what to use is determined by the application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/defaults/}
 */
var LyricFont = /** @class */ (function () {
    function LyricFont(opts) {
        var _a;
        this.schema = LyricFont.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, LyricFont.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(LyricFont.schema.contents);
    }
    /** Gets @type {LyricFontAttributes['font-family']}. */
    LyricFont.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {LyricFontAttributes['font-family']}. */
    LyricFont.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {LyricFontAttributes['font-size']}. */
    LyricFont.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {LyricFontAttributes['font-size']}. */
    LyricFont.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {LyricFontAttributes['font-style']}. */
    LyricFont.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {LyricFontAttributes['font-style']}. */
    LyricFont.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {LyricFontAttributes['font-weight']}. */
    LyricFont.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {LyricFontAttributes['font-weight']}. */
    LyricFont.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {LyricFontAttributes['name']}. */
    LyricFont.prototype.getName = function () {
        return this.attributes['name'];
    };
    /** Sets @type {LyricFontAttributes['name']}. */
    LyricFont.prototype.setName = function (name) {
        this.attributes['name'] = name;
        return this;
    };
    /** Gets @type {LyricFontAttributes['number']}. */
    LyricFont.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {LyricFontAttributes['number']}. */
    LyricFont.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    LyricFont.schema = {
        name: 'lyric-font',
        attributes: {
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            name: { type: 'optional', value: { type: 'string' } },
            number: { type: 'optional', value: { type: 'string' } },
        },
        contents: [],
    };
    return LyricFont;
}());
exports.LyricFont = LyricFont;
/**
 * The `<lyric-language>` element
 *
 * Parent element: `<defaults>`
 *
 * The `<lyric-language>` element specifies the default language for a particular name and number of lyric.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/lyric-language/}
 */
var LyricLanguage = /** @class */ (function () {
    function LyricLanguage(opts) {
        var _a;
        this.schema = LyricLanguage.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, LyricLanguage.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(LyricLanguage.schema.contents);
    }
    /** Gets @type {LyricLanguageAttributes['xml:lang']}. */
    LyricLanguage.prototype.getXmlLang = function () {
        return this.attributes['xml:lang'];
    };
    /** Sets @type {LyricLanguageAttributes['xml:lang']}. */
    LyricLanguage.prototype.setXmlLang = function (xmlLang) {
        this.attributes['xml:lang'] = xmlLang;
        return this;
    };
    /** Gets @type {LyricLanguageAttributes['name']}. */
    LyricLanguage.prototype.getName = function () {
        return this.attributes['name'];
    };
    /** Sets @type {LyricLanguageAttributes['name']}. */
    LyricLanguage.prototype.setName = function (name) {
        this.attributes['name'] = name;
        return this;
    };
    /** Gets @type {LyricLanguageAttributes['number']}. */
    LyricLanguage.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {LyricLanguageAttributes['number']}. */
    LyricLanguage.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    LyricLanguage.schema = {
        name: 'lyric-language',
        attributes: {
            'xml:lang': { type: 'required', value: { type: 'string' } },
            name: { type: 'optional', value: { type: 'string' } },
            number: { type: 'optional', value: { type: 'string' } },
        },
        contents: [],
    };
    return LyricLanguage;
}());
exports.LyricLanguage = LyricLanguage;
/**
 * The `<defautls>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<defaults>` element specifies score-wide defaults for scaling; whether or not the file is a concert score;
 * layout; and default values for the music font, word font, lyric font, and lyric language. Except for the
 * `<concert-score>` element, if any defaults are missing, the choice of what to use is determined by the application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/defaults/}
 */
var Defaults = /** @class */ (function () {
    function Defaults(opts) {
        var _a;
        this.schema = Defaults.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Defaults.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Defaults.schema.contents);
    }
    /** Gets @type {Scaling | null}. */
    Defaults.prototype.getScaling = function () {
        return this.contents[0];
    };
    /** Sets @type {Scaling | null}. */
    Defaults.prototype.setScaling = function (scaling) {
        this.contents[0] = scaling;
        return this;
    };
    /** Gets @type {ConcertScore | null}. */
    Defaults.prototype.getConcertScore = function () {
        return this.contents[1];
    };
    /** Sets @type {ConcertScore | null}. */
    Defaults.prototype.setConcertScore = function (concertScore) {
        this.contents[1] = concertScore;
        return this;
    };
    /** Gets @type {PageLayout | null}. */
    Defaults.prototype.getPageLayout = function () {
        return this.contents[2];
    };
    /** Sets @type {PageLayout | null}. */
    Defaults.prototype.setPageLayout = function (pageLayout) {
        this.contents[2] = pageLayout;
        return this;
    };
    /** Gets @type {SystemLayout | null}. */
    Defaults.prototype.getSystemLayout = function () {
        return this.contents[3];
    };
    /** Sets @type {SystemLayout | null}. */
    Defaults.prototype.setSystemLayout = function (systemLayout) {
        this.contents[3] = systemLayout;
        return this;
    };
    /** Gets @type {Array<StaffLayout>}. */
    Defaults.prototype.getStaffLayouts = function () {
        return this.contents[4];
    };
    /** Sets @type {Array<StaffLayout>}. */
    Defaults.prototype.setStaffLayouts = function (staffLayouts) {
        this.contents[4] = staffLayouts;
        return this;
    };
    /** Gets @type {Appearance | null}. */
    Defaults.prototype.getAppearance = function () {
        return this.contents[5];
    };
    /** Sets @type {Appearance | null}. */
    Defaults.prototype.setAppearance = function (appearance) {
        this.contents[5] = appearance;
        return this;
    };
    /** Gets @type {MusicFont | null}. */
    Defaults.prototype.getMusicFont = function () {
        return this.contents[6];
    };
    /** Sets @type {MusicFont | null}. */
    Defaults.prototype.setMusicFont = function (musicFont) {
        this.contents[6] = musicFont;
        return this;
    };
    /** Gets @type {WordFont | null}. */
    Defaults.prototype.getWordFont = function () {
        return this.contents[7];
    };
    /** Sets @type {WordFont | null}. */
    Defaults.prototype.setWordFont = function (wordFont) {
        this.contents[7] = wordFont;
        return this;
    };
    /** Gets @type {Array<LyricFont>}. */
    Defaults.prototype.getLyricFonts = function () {
        return this.contents[8];
    };
    /** Sets @type {Array<LyricFont>}. */
    Defaults.prototype.setLyricFonts = function (lyricFonts) {
        this.contents[8] = lyricFonts;
        return this;
    };
    /** Gets @type {Array<LyricLanguage>}. */
    Defaults.prototype.getLyricLanguages = function () {
        return this.contents[9];
    };
    /** Sets @type {Array<LyricLanguage>}. */
    Defaults.prototype.setLyricLanguages = function (lyricLanguages) {
        this.contents[9] = lyricLanguages;
        return this;
    };
    Defaults.schema = {
        name: 'defaults',
        attributes: {},
        contents: [
            { type: 'optional', value: Scaling },
            { type: 'optional', value: ConcertScore },
            { type: 'optional', value: PageLayout },
            { type: 'optional', value: SystemLayout },
            { type: 'label', label: 'staff-layouts', value: { type: 'zeroOrMore', value: StaffLayout } },
            { type: 'optional', value: Appearance },
            { type: 'optional', value: MusicFont },
            { type: 'optional', value: WordFont },
            { type: 'label', label: 'lyric-fonts', value: { type: 'zeroOrMore', value: LyricFont } },
            { type: 'label', label: 'lyric-languages', value: { type: 'zeroOrMore', value: LyricLanguage } },
        ],
    };
    return Defaults;
}());
exports.Defaults = Defaults;
/**
 * The `<credit-type>` element
 *
 * Parent element: `<credit>`
 *
 * The `<credit-type>` element indicates the purpose behind a credit. Multiple types of data may be combined in a single
 * credit, so multiple elements may be used. Standard values include:
 *
 * - page number
 * - title
 * - subtitle
 * - composer
 * - arranger
 * - lyricist
 * - rights
 * - part name
 *
 * Other values may also be used.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/credit-type/}
 */
var CreditType = /** @class */ (function () {
    function CreditType(opts) {
        var _a;
        this.schema = CreditType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, CreditType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(CreditType.schema.contents);
    }
    /** Gets @type {string}. */
    CreditType.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    CreditType.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    CreditType.schema = {
        name: 'credit-type',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return CreditType;
}());
exports.CreditType = CreditType;
/**
 * The `<link>` element
 *
 * Parent elements: `<credit>`, `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<link>` element serves as an outgoing simple XLink. If a relative link is used within a document that is part of
 * a compressed MusicXML file, the link is relative to the root folder of the zip file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/link/}
 */
var Link = /** @class */ (function () {
    function Link(opts) {
        var _a;
        this.schema = Link.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Link.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Link.schema.contents);
    }
    /** Gets @type {LinkAttributes['xlink:href']}. */
    Link.prototype.getXlinkHref = function () {
        return this.attributes['xlink:href'];
    };
    /** Sets @type {LinkAttributes['xlink:href']}. */
    Link.prototype.setXlinkHref = function (xlinkHref) {
        this.attributes['xlink:href'] = xlinkHref;
        return this;
    };
    /** Gets @type {LinkAttributes['default-x']}. */
    Link.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {LinkAttributes['default-x']}. */
    Link.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {LinkAttributes['default-y']}. */
    Link.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {LinkAttributes['default-y']}. */
    Link.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {LinkAttributes['element']}. */
    Link.prototype.getElement = function () {
        return this.attributes['element'];
    };
    /** Sets @type {LinkAttributes['element']}. */
    Link.prototype.setElement = function (element) {
        this.attributes['element'] = element;
        return this;
    };
    /** Gets @type {LinkAttributes['name']}. */
    Link.prototype.getName = function () {
        return this.attributes['name'];
    };
    /** Sets @type {LinkAttributes['name']}. */
    Link.prototype.setName = function (name) {
        this.attributes['name'] = name;
        return this;
    };
    /** Gets @type {LinkAttributes['position']}. */
    Link.prototype.getPosition = function () {
        return this.attributes['position'];
    };
    /** Sets @type {LinkAttributes['position']}. */
    Link.prototype.setPosition = function (position) {
        this.attributes['position'] = position;
        return this;
    };
    /** Gets @type {LinkAttributes['relative-x']}. */
    Link.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {LinkAttributes['relative-x']}. */
    Link.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {LinkAttributes['relative-y']}. */
    Link.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {LinkAttributes['relative-y']}. */
    Link.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {LinkAttributes['xlink:actuate']}. */
    Link.prototype.getXlinkActuate = function () {
        return this.attributes['xlink:actuate'];
    };
    /** Sets @type {LinkAttributes['xlink:actuate']}. */
    Link.prototype.setXlinkActuate = function (xlinkActuate) {
        this.attributes['xlink:actuate'] = xlinkActuate;
        return this;
    };
    /** Gets @type {LinkAttributes['xlink:role']}. */
    Link.prototype.getXlinkRole = function () {
        return this.attributes['xlink:role'];
    };
    /** Sets @type {LinkAttributes['xlink:role']}. */
    Link.prototype.setXlinkRole = function (xlinkRole) {
        this.attributes['xlink:role'] = xlinkRole;
        return this;
    };
    /** Gets @type {LinkAttributes['xlink:show']}. */
    Link.prototype.getXlinkShow = function () {
        return this.attributes['xlink:show'];
    };
    /** Sets @type {LinkAttributes['xlink:show']}. */
    Link.prototype.setXlinkShow = function (xlinkShow) {
        this.attributes['xlink:show'] = xlinkShow;
        return this;
    };
    /** Gets @type {LinkAttributes['xlink:title']}. */
    Link.prototype.getXlinkTitle = function () {
        return this.attributes['xlink:title'];
    };
    /** Sets @type {LinkAttributes['xlink:title']}. */
    Link.prototype.setXlinkTitle = function (xlinkTitle) {
        this.attributes['xlink:title'] = xlinkTitle;
        return this;
    };
    /** Gets @type {LinkAttributes['xlink:type']}. */
    Link.prototype.getXlinkType = function () {
        return this.attributes['xlink:type'];
    };
    /** Sets @type {LinkAttributes['xlink:type']}. */
    Link.prototype.setXlinkType = function (xlinkType) {
        this.attributes['xlink:type'] = xlinkType;
        return this;
    };
    Link.schema = {
        name: 'link',
        attributes: {
            'xlink:href': { type: 'required', value: { type: 'string' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            element: { type: 'optional', value: { type: 'string' } },
            name: { type: 'optional', value: { type: 'string' } },
            position: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'xlink:actuate': {
                type: 'optional',
                value: { type: 'choices', choices: ['none', 'onRequest', 'onLoad', 'other'] },
            },
            'xlink:role': { type: 'optional', value: { type: 'string' } },
            'xlink:show': {
                type: 'optional',
                value: { type: 'choices', choices: ['none', 'new', 'replace', 'embed', 'other'] },
            },
            'xlink:title': { type: 'optional', value: { type: 'string' } },
            'xlink:type': { type: 'optional', value: { type: 'choices', choices: ['simple'] } },
        },
        contents: [],
    };
    return Link;
}());
exports.Link = Link;
/**
 * The `<bookmark>` element
 *
 * Parent elements: `<credit>`, `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<bookmark>` element serves as a well-defined target for an incoming simple XLink.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bookmark/}
 */
var Bookmark = /** @class */ (function () {
    function Bookmark(opts) {
        var _a;
        this.schema = Bookmark.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Bookmark.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Bookmark.schema.contents);
    }
    /** Gets @type {BookmarkAttributes['id']}. */
    Bookmark.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {BookmarkAttributes['id']}. */
    Bookmark.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {BookmarkAttributes['element']}. */
    Bookmark.prototype.getElement = function () {
        return this.attributes['element'];
    };
    /** Sets @type {BookmarkAttributes['element']}. */
    Bookmark.prototype.setElement = function (element) {
        this.attributes['element'] = element;
        return this;
    };
    /** Gets @type {BookmarkAttributes['name']}. */
    Bookmark.prototype.getName = function () {
        return this.attributes['name'];
    };
    /** Sets @type {BookmarkAttributes['name']}. */
    Bookmark.prototype.setName = function (name) {
        this.attributes['name'] = name;
        return this;
    };
    /** Gets @type {BookmarkAttributes['position']}. */
    Bookmark.prototype.getPosition = function () {
        return this.attributes['position'];
    };
    /** Sets @type {BookmarkAttributes['position']}. */
    Bookmark.prototype.setPosition = function (position) {
        this.attributes['position'] = position;
        return this;
    };
    Bookmark.schema = {
        name: 'bookmark',
        attributes: {
            id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            element: { type: 'optional', value: { type: 'string' } },
            name: { type: 'optional', value: { type: 'string' } },
            position: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
        },
        contents: [],
    };
    return Bookmark;
}());
exports.Bookmark = Bookmark;
/**
 * The `<credit-image>` element
 *
 * Parent element: `<credit>`
 *
 * The `<credit-image>` element is similar to the `<image>` element for a `<direction>`. However, since the `<credit>`
 * is not part of a measure, the default-x and default-y attributes adjust the origin relative to the bottom left-hand
 * corner of the page.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/credit-image/}
 */
var CreditImage = /** @class */ (function () {
    function CreditImage(opts) {
        var _a;
        this.schema = CreditImage.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, CreditImage.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(CreditImage.schema.contents);
    }
    /** Gets @type {CreditImageAttributes['default-x']}. */
    CreditImage.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {CreditImageAttributes['default-x']}. */
    CreditImage.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {CreditImageAttributes['default-y']}. */
    CreditImage.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {CreditImageAttributes['default-y']}. */
    CreditImage.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {CreditImageAttributes['halign']}. */
    CreditImage.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {CreditImageAttributes['halign']}. */
    CreditImage.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {CreditImageAttributes['height']}. */
    CreditImage.prototype.getHeight = function () {
        return this.attributes['height'];
    };
    /** Sets @type {CreditImageAttributes['height']}. */
    CreditImage.prototype.setHeight = function (height) {
        this.attributes['height'] = height;
        return this;
    };
    /** Gets @type {CreditImageAttributes['id']}. */
    CreditImage.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {CreditImageAttributes['id']}. */
    CreditImage.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {CreditImageAttributes['relative-x']}. */
    CreditImage.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {CreditImageAttributes['relative-x']}. */
    CreditImage.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {CreditImageAttributes['relative-y']}. */
    CreditImage.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {CreditImageAttributes['relative-y']}. */
    CreditImage.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {CreditImageAttributes['source']}. */
    CreditImage.prototype.getSource = function () {
        return this.attributes['source'];
    };
    /** Sets @type {CreditImageAttributes['source']}. */
    CreditImage.prototype.setSource = function (source) {
        this.attributes['source'] = source;
        return this;
    };
    /** Gets @type {CreditImageAttributes['type']}. */
    CreditImage.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {CreditImageAttributes['type']}. */
    CreditImage.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {CreditImageAttributes['valign']}. */
    CreditImage.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {CreditImageAttributes['valign']}. */
    CreditImage.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {CreditImageAttributes['width']}. */
    CreditImage.prototype.getWidth = function () {
        return this.attributes['width'];
    };
    /** Sets @type {CreditImageAttributes['width']}. */
    CreditImage.prototype.setWidth = function (width) {
        this.attributes['width'] = width;
        return this;
    };
    CreditImage.schema = {
        name: 'credit-image',
        attributes: {
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            height: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            source: { type: 'optional', value: { type: 'string' } },
            type: { type: 'optional', value: { type: 'string' } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom'] } },
            width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return CreditImage;
}());
exports.CreditImage = CreditImage;
/**
 * The `<credit-words>` element
 *
 * Parent element: `<credit>`
 *
 * The `<credit-words>` element is similar to the `<words>` element for a `<direction>`. However, since the `<credit>`
 * is not part of a measure, the default-x and default-y attributes adjust the origin relative to the bottom left-hand
 * corner of the page. The enclosure is none if not specified.
 *
 * By default, a series of `<credit-words>` and `<credit-symbol>` elements within a single `<credit>` element follow one
 * another in sequence visually. Non-positional formatting attributes are carried over from the previous element by
 * default.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/credit-words/}
 */
var CreditWords = /** @class */ (function () {
    function CreditWords(opts) {
        var _a;
        this.schema = CreditWords.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, CreditWords.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(CreditWords.schema.contents);
    }
    /** Gets @type {CreditWordsAttributes['color']}. */
    CreditWords.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {CreditWordsAttributes['color']}. */
    CreditWords.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['default-x']}. */
    CreditWords.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {CreditWordsAttributes['default-x']}. */
    CreditWords.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['default-y']}. */
    CreditWords.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {CreditWordsAttributes['default-y']}. */
    CreditWords.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['dir']}. */
    CreditWords.prototype.getDir = function () {
        return this.attributes['dir'];
    };
    /** Sets @type {CreditWordsAttributes['dir']}. */
    CreditWords.prototype.setDir = function (dir) {
        this.attributes['dir'] = dir;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['enclosure']}. */
    CreditWords.prototype.getEnclosure = function () {
        return this.attributes['enclosure'];
    };
    /** Sets @type {CreditWordsAttributes['enclosure']}. */
    CreditWords.prototype.setEnclosure = function (enclosure) {
        this.attributes['enclosure'] = enclosure;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['font-family']}. */
    CreditWords.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {CreditWordsAttributes['font-family']}. */
    CreditWords.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['font-size']}. */
    CreditWords.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {CreditWordsAttributes['font-size']}. */
    CreditWords.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['font-style']}. */
    CreditWords.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {CreditWordsAttributes['font-style']}. */
    CreditWords.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['font-weight']}. */
    CreditWords.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {CreditWordsAttributes['font-weight']}. */
    CreditWords.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['halign']}. */
    CreditWords.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {CreditWordsAttributes['halign']}. */
    CreditWords.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['id']}. */
    CreditWords.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {CreditWordsAttributes['id']}. */
    CreditWords.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['justify']}. */
    CreditWords.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {CreditWordsAttributes['justify']}. */
    CreditWords.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['letter-spacing']}. */
    CreditWords.prototype.getLetterSpacing = function () {
        return this.attributes['letter-spacing'];
    };
    /** Sets @type {CreditWordsAttributes['letter-spacing']}. */
    CreditWords.prototype.setLetterSpacing = function (letterSpacing) {
        this.attributes['letter-spacing'] = letterSpacing;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['line-height']}. */
    CreditWords.prototype.getLineHeight = function () {
        return this.attributes['line-height'];
    };
    /** Sets @type {CreditWordsAttributes['line-height']}. */
    CreditWords.prototype.setLineHeight = function (lineHeight) {
        this.attributes['line-height'] = lineHeight;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['line-through']}. */
    CreditWords.prototype.getLineThrough = function () {
        return this.attributes['line-through'];
    };
    /** Sets @type {CreditWordsAttributes['line-through']}. */
    CreditWords.prototype.setLineThrough = function (lineThrough) {
        this.attributes['line-through'] = lineThrough;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['overline']}. */
    CreditWords.prototype.getOverline = function () {
        return this.attributes['overline'];
    };
    /** Sets @type {CreditWordsAttributes['overline']}. */
    CreditWords.prototype.setOverline = function (overline) {
        this.attributes['overline'] = overline;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['relative-x']}. */
    CreditWords.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {CreditWordsAttributes['relative-x']}. */
    CreditWords.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['relative-y']}. */
    CreditWords.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {CreditWordsAttributes['relative-y']}. */
    CreditWords.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['rotation']}. */
    CreditWords.prototype.getRotation = function () {
        return this.attributes['rotation'];
    };
    /** Sets @type {CreditWordsAttributes['rotation']}. */
    CreditWords.prototype.setRotation = function (rotation) {
        this.attributes['rotation'] = rotation;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['underline']}. */
    CreditWords.prototype.getUnderline = function () {
        return this.attributes['underline'];
    };
    /** Sets @type {CreditWordsAttributes['underline']}. */
    CreditWords.prototype.setUnderline = function (underline) {
        this.attributes['underline'] = underline;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['valign']}. */
    CreditWords.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {CreditWordsAttributes['valign']}. */
    CreditWords.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['xml:lang']}. */
    CreditWords.prototype.getXmlLang = function () {
        return this.attributes['xml:lang'];
    };
    /** Sets @type {CreditWordsAttributes['xml:lang']}. */
    CreditWords.prototype.setXmlLang = function (xmlLang) {
        this.attributes['xml:lang'] = xmlLang;
        return this;
    };
    /** Gets @type {CreditWordsAttributes['xml:space']}. */
    CreditWords.prototype.getXmlSpace = function () {
        return this.attributes['xml:space'];
    };
    /** Sets @type {CreditWordsAttributes['xml:space']}. */
    CreditWords.prototype.setXmlSpace = function (xmlSpace) {
        this.attributes['xml:space'] = xmlSpace;
        return this;
    };
    /** Gets @type {string}. */
    CreditWords.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    CreditWords.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    CreditWords.schema = {
        name: 'credit-words',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
            enclosure: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        'none',
                        'rectangle',
                        'square',
                        'oval',
                        'circle',
                        'bracket',
                        'inverted-bracket',
                        'triangle',
                        'diamond',
                        'pentagon',
                        'hexagon',
                        'heptagon',
                        'octagon',
                        'nonagon',
                        'decagon',
                    ],
                },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'letter-spacing': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-height': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
            'xml:lang': { type: 'optional', value: { type: 'string' } },
            'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
        },
        contents: [{ type: 'string' }],
    };
    return CreditWords;
}());
exports.CreditWords = CreditWords;
/**
 * The `<credit-symbol>` element
 *
 * Parent element: `<credit>`
 *
 * The `<credit-symbol>` element is similar to the `<symbol>` element for a `<direction>`. However, since the `<credit>`
 * is not part of a measure, the default-x and default-y attributes adjust the origin relative to the bottom left-hand
 * corner of the page. The enclosure is none if not specified.
 *
 * By default, a series of `<credit-words>` and `<credit-symbol>` elements within a single `<credit>` element follow one
 * another in sequence visually. Non-positional formatting attributes are carried over from the previous element by
 * default.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/credit-symbol/}
 */
var CreditSymbol = /** @class */ (function () {
    function CreditSymbol(opts) {
        var _a;
        this.schema = CreditSymbol.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, CreditSymbol.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(CreditSymbol.schema.contents);
    }
    /** Gets @type {CreditSymbolAttributes['color']}. */
    CreditSymbol.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {CreditSymbolAttributes['color']}. */
    CreditSymbol.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['default-x']}. */
    CreditSymbol.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {CreditSymbolAttributes['default-x']}. */
    CreditSymbol.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['default-y']}. */
    CreditSymbol.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {CreditSymbolAttributes['default-y']}. */
    CreditSymbol.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['dir']}. */
    CreditSymbol.prototype.getDir = function () {
        return this.attributes['dir'];
    };
    /** Sets @type {CreditSymbolAttributes['dir']}. */
    CreditSymbol.prototype.setDir = function (dir) {
        this.attributes['dir'] = dir;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['enclosure']}. */
    CreditSymbol.prototype.getEnclosure = function () {
        return this.attributes['enclosure'];
    };
    /** Sets @type {CreditSymbolAttributes['enclosure']}. */
    CreditSymbol.prototype.setEnclosure = function (enclosure) {
        this.attributes['enclosure'] = enclosure;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['font-family']}. */
    CreditSymbol.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {CreditSymbolAttributes['font-family']}. */
    CreditSymbol.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['font-size']}. */
    CreditSymbol.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {CreditSymbolAttributes['font-size']}. */
    CreditSymbol.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['font-style']}. */
    CreditSymbol.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {CreditSymbolAttributes['font-style']}. */
    CreditSymbol.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['font-weight']}. */
    CreditSymbol.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {CreditSymbolAttributes['font-weight']}. */
    CreditSymbol.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['halign']}. */
    CreditSymbol.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {CreditSymbolAttributes['halign']}. */
    CreditSymbol.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['id']}. */
    CreditSymbol.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {CreditSymbolAttributes['id']}. */
    CreditSymbol.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['justify']}. */
    CreditSymbol.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {CreditSymbolAttributes['justify']}. */
    CreditSymbol.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['letter-spacing']}. */
    CreditSymbol.prototype.getLetterSpacing = function () {
        return this.attributes['letter-spacing'];
    };
    /** Sets @type {CreditSymbolAttributes['letter-spacing']}. */
    CreditSymbol.prototype.setLetterSpacing = function (letterSpacing) {
        this.attributes['letter-spacing'] = letterSpacing;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['line-height']}. */
    CreditSymbol.prototype.getLineHeight = function () {
        return this.attributes['line-height'];
    };
    /** Sets @type {CreditSymbolAttributes['line-height']}. */
    CreditSymbol.prototype.setLineHeight = function (lineHeight) {
        this.attributes['line-height'] = lineHeight;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['line-through']}. */
    CreditSymbol.prototype.getLineThrough = function () {
        return this.attributes['line-through'];
    };
    /** Sets @type {CreditSymbolAttributes['line-through']}. */
    CreditSymbol.prototype.setLineThrough = function (lineThrough) {
        this.attributes['line-through'] = lineThrough;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['overline']}. */
    CreditSymbol.prototype.getOverline = function () {
        return this.attributes['overline'];
    };
    /** Sets @type {CreditSymbolAttributes['overline']}. */
    CreditSymbol.prototype.setOverline = function (overline) {
        this.attributes['overline'] = overline;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['relative-x']}. */
    CreditSymbol.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {CreditSymbolAttributes['relative-x']}. */
    CreditSymbol.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['relative-y']}. */
    CreditSymbol.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {CreditSymbolAttributes['relative-y']}. */
    CreditSymbol.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['rotation']}. */
    CreditSymbol.prototype.getRotation = function () {
        return this.attributes['rotation'];
    };
    /** Sets @type {CreditSymbolAttributes['rotation']}. */
    CreditSymbol.prototype.setRotation = function (rotation) {
        this.attributes['rotation'] = rotation;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['underline']}. */
    CreditSymbol.prototype.getUnderline = function () {
        return this.attributes['underline'];
    };
    /** Sets @type {CreditSymbolAttributes['underline']}. */
    CreditSymbol.prototype.setUnderline = function (underline) {
        this.attributes['underline'] = underline;
        return this;
    };
    /** Gets @type {CreditSymbolAttributes['valign']}. */
    CreditSymbol.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {CreditSymbolAttributes['valign']}. */
    CreditSymbol.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {string}. */
    CreditSymbol.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    CreditSymbol.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    CreditSymbol.schema = {
        name: 'credit-symbol',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
            enclosure: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        'none',
                        'rectangle',
                        'square',
                        'oval',
                        'circle',
                        'bracket',
                        'inverted-bracket',
                        'triangle',
                        'diamond',
                        'pentagon',
                        'hexagon',
                        'heptagon',
                        'octagon',
                        'nonagon',
                        'decagon',
                    ],
                },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'letter-spacing': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-height': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return CreditSymbol;
}());
exports.CreditSymbol = CreditSymbol;
/**
 * The `<credit>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<credit>` element represents the appearance of the title, composer, arranger, lyricist, copyright, dedication,
 * and other text, symbols, and graphics that commonly appear on the first page of a score. The `<credit-words>`,
 * `<credit-symbol>`, and `<credit-image>` elements are similar to the `<words>`, `<symbol>`, and `<image>` elements for
 * directions. However, since the credit is not part of a measure, the default-x and default-y attributes adjust the
 * origin relative to the bottom left-hand corner of the page. The enclosure for `<credit-words>` and `<credit-symbol>`
 * is none if not specified.
 *
 * By default, a series of `<credit-words>` and `<credit-symbol>` elements within a single `<credit>` element follow one
 * another in sequence visually. Non-positional formatting attributes are carried over from the previous element by
 * default.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/credit/}
 */
var Credit = /** @class */ (function () {
    function Credit(opts) {
        var _a;
        this.schema = Credit.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Credit.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Credit.schema.contents);
    }
    /** Gets @type {CreditAttributes['id']}. */
    Credit.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {CreditAttributes['id']}. */
    Credit.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {CreditAttributes['page']}. */
    Credit.prototype.getPage = function () {
        return this.attributes['page'];
    };
    /** Sets @type {CreditAttributes['page']}. */
    Credit.prototype.setPage = function (page) {
        this.attributes['page'] = page;
        return this;
    };
    /** Gets @type {Array<CreditType>}. */
    Credit.prototype.getCreditTypes = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<CreditType>}. */
    Credit.prototype.setCreditTypes = function (creditTypes) {
        this.contents[0] = creditTypes;
        return this;
    };
    /** Gets @type {Array<Link>}. */
    Credit.prototype.getLinks = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<Link>}. */
    Credit.prototype.setLinks = function (links) {
        this.contents[1] = links;
        return this;
    };
    /** Gets @type {Array<Bookmark>}. */
    Credit.prototype.getBookmarks = function () {
        return this.contents[2];
    };
    /** Sets @type {Array<Bookmark>}. */
    Credit.prototype.setBookmarks = function (bookmarks) {
        this.contents[2] = bookmarks;
        return this;
    };
    /** Gets @type {CreditImage | CreditToken}. */
    Credit.prototype.getValue = function () {
        return this.contents[3];
    };
    /** Sets @type {CreditImage | CreditToken}. */
    Credit.prototype.setValue = function (value) {
        this.contents[3] = value;
        return this;
    };
    Credit.schema = {
        name: 'credit',
        attributes: {
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            page: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
        },
        contents: [
            { type: 'label', label: 'credit-types', value: { type: 'zeroOrMore', value: CreditType } },
            { type: 'label', label: 'links', value: { type: 'zeroOrMore', value: Link } },
            { type: 'label', label: 'bookmarks', value: { type: 'zeroOrMore', value: Bookmark } },
            {
                type: 'label',
                label: 'value',
                value: {
                    type: 'choices',
                    choices: [
                        CreditImage,
                        {
                            type: 'label',
                            label: 'credit-token',
                            value: [
                                { type: 'choices', choices: [CreditWords, CreditSymbol] },
                                {
                                    type: 'zeroOrMore',
                                    value: [
                                        { type: 'zeroOrMore', value: Link },
                                        { type: 'zeroOrMore', value: Bookmark },
                                        { type: 'choices', choices: [CreditWords, CreditSymbol] },
                                    ],
                                },
                            ],
                        },
                    ],
                },
            },
        ],
    };
    return Credit;
}());
exports.Credit = Credit;
/**
 * The `<group-name>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-name>` element describes the name of a <part-group> element. The formatting attributes are deprecated as
 * of Version 2.0 in favor of the new `<group-name-display>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-name/}
 */
var GroupName = /** @class */ (function () {
    function GroupName(opts) {
        var _a;
        this.schema = GroupName.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, GroupName.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(GroupName.schema.contents);
    }
    /** Gets @type {GroupNameAttributes['color']}. */
    GroupName.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {GroupNameAttributes['color']}. */
    GroupName.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {GroupNameAttributes['default-x']}. */
    GroupName.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {GroupNameAttributes['default-x']}. */
    GroupName.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {GroupNameAttributes['default-y']}. */
    GroupName.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {GroupNameAttributes['default-y']}. */
    GroupName.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {GroupNameAttributes['font-family']}. */
    GroupName.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {GroupNameAttributes['font-family']}. */
    GroupName.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {GroupNameAttributes['font-size']}. */
    GroupName.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {GroupNameAttributes['font-size']}. */
    GroupName.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {GroupNameAttributes['font-style']}. */
    GroupName.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {GroupNameAttributes['font-style']}. */
    GroupName.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {GroupNameAttributes['font-weight']}. */
    GroupName.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {GroupNameAttributes['font-weight']}. */
    GroupName.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {GroupNameAttributes['justify']}. */
    GroupName.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {GroupNameAttributes['justify']}. */
    GroupName.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {GroupNameAttributes['relative-x']}. */
    GroupName.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {GroupNameAttributes['relative-x']}. */
    GroupName.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {GroupNameAttributes['relative-y']}. */
    GroupName.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {GroupNameAttributes['relative-y']}. */
    GroupName.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    GroupName.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    GroupName.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    GroupName.schema = {
        name: 'group-name',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return GroupName;
}());
exports.GroupName = GroupName;
/**
 * The `<display-text>` element
 *
 * Parent elements: `<group-abbreviation-display>`, `<group-name-display>`, `<notehead-text>`,
 * `<part-abbreviation-display>`, `<part-name-display>`
 *
 * The `<display-text>` element is used for exact formatting of multi-font text in element in display elements such as
 * `<part-name-display>`. The enclosure attribute is none if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/display-text/}
 */
var DisplayText = /** @class */ (function () {
    function DisplayText(opts) {
        var _a;
        this.schema = DisplayText.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DisplayText.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DisplayText.schema.contents);
    }
    /** Gets @type {DisplayTextAttributes['color']}. */
    DisplayText.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DisplayTextAttributes['color']}. */
    DisplayText.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['default-x']}. */
    DisplayText.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DisplayTextAttributes['default-x']}. */
    DisplayText.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['default-y']}. */
    DisplayText.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DisplayTextAttributes['default-y']}. */
    DisplayText.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['dir']}. */
    DisplayText.prototype.getDir = function () {
        return this.attributes['dir'];
    };
    /** Sets @type {DisplayTextAttributes['dir']}. */
    DisplayText.prototype.setDir = function (dir) {
        this.attributes['dir'] = dir;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['enclosure']}. */
    DisplayText.prototype.getEnclosure = function () {
        return this.attributes['enclosure'];
    };
    /** Sets @type {DisplayTextAttributes['enclosure']}. */
    DisplayText.prototype.setEnclosure = function (enclosure) {
        this.attributes['enclosure'] = enclosure;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['font-family']}. */
    DisplayText.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DisplayTextAttributes['font-family']}. */
    DisplayText.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['font-size']}. */
    DisplayText.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DisplayTextAttributes['font-size']}. */
    DisplayText.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['font-style']}. */
    DisplayText.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DisplayTextAttributes['font-style']}. */
    DisplayText.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['font-weight']}. */
    DisplayText.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DisplayTextAttributes['font-weight']}. */
    DisplayText.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['halign']}. */
    DisplayText.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {DisplayTextAttributes['halign']}. */
    DisplayText.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['justify']}. */
    DisplayText.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {DisplayTextAttributes['justify']}. */
    DisplayText.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['letter-spacing']}. */
    DisplayText.prototype.getLetterSpacing = function () {
        return this.attributes['letter-spacing'];
    };
    /** Sets @type {DisplayTextAttributes['letter-spacing']}. */
    DisplayText.prototype.setLetterSpacing = function (letterSpacing) {
        this.attributes['letter-spacing'] = letterSpacing;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['line-height']}. */
    DisplayText.prototype.getLineHeight = function () {
        return this.attributes['line-height'];
    };
    /** Sets @type {DisplayTextAttributes['line-height']}. */
    DisplayText.prototype.setLineHeight = function (lineHeight) {
        this.attributes['line-height'] = lineHeight;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['line-through']}. */
    DisplayText.prototype.getLineThrough = function () {
        return this.attributes['line-through'];
    };
    /** Sets @type {DisplayTextAttributes['line-through']}. */
    DisplayText.prototype.setLineThrough = function (lineThrough) {
        this.attributes['line-through'] = lineThrough;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['overline']}. */
    DisplayText.prototype.getOverline = function () {
        return this.attributes['overline'];
    };
    /** Sets @type {DisplayTextAttributes['overline']}. */
    DisplayText.prototype.setOverline = function (overline) {
        this.attributes['overline'] = overline;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['relative-x']}. */
    DisplayText.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DisplayTextAttributes['relative-x']}. */
    DisplayText.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['relative-y']}. */
    DisplayText.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DisplayTextAttributes['relative-y']}. */
    DisplayText.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['rotation']}. */
    DisplayText.prototype.getRotation = function () {
        return this.attributes['rotation'];
    };
    /** Sets @type {DisplayTextAttributes['rotation']}. */
    DisplayText.prototype.setRotation = function (rotation) {
        this.attributes['rotation'] = rotation;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['underline']}. */
    DisplayText.prototype.getUnderline = function () {
        return this.attributes['underline'];
    };
    /** Sets @type {DisplayTextAttributes['underline']}. */
    DisplayText.prototype.setUnderline = function (underline) {
        this.attributes['underline'] = underline;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['valign']}. */
    DisplayText.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {DisplayTextAttributes['valign']}. */
    DisplayText.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['xml:lang']}. */
    DisplayText.prototype.getXmlLang = function () {
        return this.attributes['xml:lang'];
    };
    /** Sets @type {DisplayTextAttributes['xml:lang']}. */
    DisplayText.prototype.setXmlLang = function (xmlLang) {
        this.attributes['xml:lang'] = xmlLang;
        return this;
    };
    /** Gets @type {DisplayTextAttributes['xml:space']}. */
    DisplayText.prototype.getXmlSpace = function () {
        return this.attributes['xml:space'];
    };
    /** Sets @type {DisplayTextAttributes['xml:space']}. */
    DisplayText.prototype.setXmlSpace = function (xmlSpace) {
        this.attributes['xml:space'] = xmlSpace;
        return this;
    };
    /** Gets @type {string | null}. */
    DisplayText.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string | null}. */
    DisplayText.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    DisplayText.schema = {
        name: 'display-text',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
            enclosure: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        'none',
                        'rectangle',
                        'square',
                        'oval',
                        'circle',
                        'bracket',
                        'inverted-bracket',
                        'triangle',
                        'diamond',
                        'pentagon',
                        'hexagon',
                        'heptagon',
                        'octagon',
                        'nonagon',
                        'decagon',
                    ],
                },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'letter-spacing': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-height': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
            'xml:lang': { type: 'optional', value: { type: 'string' } },
            'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
        },
        contents: [{ type: 'optional', value: { type: 'string' } }],
    };
    return DisplayText;
}());
exports.DisplayText = DisplayText;
/**
 * The `<accidental-text>` element
 *
 * Parent elements: `<group-abbreviation-display>`, `<group-name-display>`, `<notehead-text>`,
 * `<part-abbreviation-display>`, `<part-name-display>`
 *
 * The `<accidental-text>` element is used for exact formatting of accidentals in display elements such as
 * `<part-name-display>`. The enclosure attribute is none if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-name-display/}
 */
var AccidentalText = /** @class */ (function () {
    function AccidentalText(opts) {
        var _a;
        this.schema = AccidentalText.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, AccidentalText.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(AccidentalText.schema.contents);
    }
    /** Gets @type {AccidentalTextAttributes['color']}. */
    AccidentalText.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {AccidentalTextAttributes['color']}. */
    AccidentalText.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['default-x']}. */
    AccidentalText.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {AccidentalTextAttributes['default-x']}. */
    AccidentalText.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['default-y']}. */
    AccidentalText.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {AccidentalTextAttributes['default-y']}. */
    AccidentalText.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['dir']}. */
    AccidentalText.prototype.getDir = function () {
        return this.attributes['dir'];
    };
    /** Sets @type {AccidentalTextAttributes['dir']}. */
    AccidentalText.prototype.setDir = function (dir) {
        this.attributes['dir'] = dir;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['enclosure']}. */
    AccidentalText.prototype.getEnclosure = function () {
        return this.attributes['enclosure'];
    };
    /** Sets @type {AccidentalTextAttributes['enclosure']}. */
    AccidentalText.prototype.setEnclosure = function (enclosure) {
        this.attributes['enclosure'] = enclosure;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['font-family']}. */
    AccidentalText.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {AccidentalTextAttributes['font-family']}. */
    AccidentalText.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['font-size']}. */
    AccidentalText.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {AccidentalTextAttributes['font-size']}. */
    AccidentalText.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['font-style']}. */
    AccidentalText.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {AccidentalTextAttributes['font-style']}. */
    AccidentalText.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['font-weight']}. */
    AccidentalText.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {AccidentalTextAttributes['font-weight']}. */
    AccidentalText.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['halign']}. */
    AccidentalText.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {AccidentalTextAttributes['halign']}. */
    AccidentalText.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['justify']}. */
    AccidentalText.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {AccidentalTextAttributes['justify']}. */
    AccidentalText.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['letter-spacing']}. */
    AccidentalText.prototype.getLetterSpacing = function () {
        return this.attributes['letter-spacing'];
    };
    /** Sets @type {AccidentalTextAttributes['letter-spacing']}. */
    AccidentalText.prototype.setLetterSpacing = function (letterSpacing) {
        this.attributes['letter-spacing'] = letterSpacing;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['line-height']}. */
    AccidentalText.prototype.getLineHeight = function () {
        return this.attributes['line-height'];
    };
    /** Sets @type {AccidentalTextAttributes['line-height']}. */
    AccidentalText.prototype.setLineHeight = function (lineHeight) {
        this.attributes['line-height'] = lineHeight;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['line-through']}. */
    AccidentalText.prototype.getLineThrough = function () {
        return this.attributes['line-through'];
    };
    /** Sets @type {AccidentalTextAttributes['line-through']}. */
    AccidentalText.prototype.setLineThrough = function (lineThrough) {
        this.attributes['line-through'] = lineThrough;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['overline']}. */
    AccidentalText.prototype.getOverline = function () {
        return this.attributes['overline'];
    };
    /** Sets @type {AccidentalTextAttributes['overline']}. */
    AccidentalText.prototype.setOverline = function (overline) {
        this.attributes['overline'] = overline;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['relative-x']}. */
    AccidentalText.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {AccidentalTextAttributes['relative-x']}. */
    AccidentalText.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['relative-y']}. */
    AccidentalText.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {AccidentalTextAttributes['relative-y']}. */
    AccidentalText.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['rotation']}. */
    AccidentalText.prototype.getRotation = function () {
        return this.attributes['rotation'];
    };
    /** Sets @type {AccidentalTextAttributes['rotation']}. */
    AccidentalText.prototype.setRotation = function (rotation) {
        this.attributes['rotation'] = rotation;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['smufl']}. */
    AccidentalText.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {AccidentalTextAttributes['smufl']}. */
    AccidentalText.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['underline']}. */
    AccidentalText.prototype.getUnderline = function () {
        return this.attributes['underline'];
    };
    /** Sets @type {AccidentalTextAttributes['underline']}. */
    AccidentalText.prototype.setUnderline = function (underline) {
        this.attributes['underline'] = underline;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['valign']}. */
    AccidentalText.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {AccidentalTextAttributes['valign']}. */
    AccidentalText.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['xml:lang']}. */
    AccidentalText.prototype.getXmlLang = function () {
        return this.attributes['xml:lang'];
    };
    /** Sets @type {AccidentalTextAttributes['xml:lang']}. */
    AccidentalText.prototype.setXmlLang = function (xmlLang) {
        this.attributes['xml:lang'] = xmlLang;
        return this;
    };
    /** Gets @type {AccidentalTextAttributes['xml:space']}. */
    AccidentalText.prototype.getXmlSpace = function () {
        return this.attributes['xml:space'];
    };
    /** Sets @type {AccidentalTextAttributes['xml:space']}. */
    AccidentalText.prototype.setXmlSpace = function (xmlSpace) {
        this.attributes['xml:space'] = xmlSpace;
        return this;
    };
    /** Gets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
    AccidentalText.prototype.getAccidentalValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
    AccidentalText.prototype.setAccidentalValue = function (accidentalValue) {
        this.contents[0] = accidentalValue;
        return this;
    };
    AccidentalText.schema = {
        name: 'accidental-text',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
            enclosure: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        'none',
                        'rectangle',
                        'square',
                        'oval',
                        'circle',
                        'bracket',
                        'inverted-bracket',
                        'triangle',
                        'diamond',
                        'pentagon',
                        'hexagon',
                        'heptagon',
                        'octagon',
                        'nonagon',
                        'decagon',
                    ],
                },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'letter-spacing': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-height': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            smufl: {
                type: 'optional',
                value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
            },
            underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
            'xml:lang': { type: 'optional', value: { type: 'string' } },
            'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
        },
        contents: [
            {
                type: 'label',
                label: 'accidental-value',
                value: {
                    type: 'choices',
                    choices: [
                        'other',
                        'sharp',
                        'natural',
                        'flat',
                        'double-sharp',
                        'sharp-sharp',
                        'flat-flat',
                        'natural-sharp',
                        'natural-flat',
                        'quarter-flat',
                        'quarter-sharp',
                        'three-quarters-flat',
                        'three-quarters-sharp',
                        'sharp-down',
                        'sharp-up',
                        'natural-down',
                        'natural-up',
                        'flat-down',
                        'flat-up',
                        'double-sharp-down',
                        'double-sharp-up',
                        'flat-flat-down',
                        'flat-flat-up',
                        'arrow-down',
                        'arrow-up',
                        'triple-sharp',
                        'triple-flat',
                        'slash-quarter-sharp',
                        'slash-sharp',
                        'slash-flat',
                        'double-slash-flat',
                        'sharp-1',
                        'sharp-2',
                        'sharp-3',
                        'sharp-5',
                        'flat-1',
                        'flat-2',
                        'flat-3',
                        'flat-4',
                        'sori',
                        'koron',
                    ],
                },
            },
        ],
    };
    return AccidentalText;
}());
exports.AccidentalText = AccidentalText;
/**
 * The `<group-name-display>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-name-display>` element is used for exact formatting of multi-font text in group names to the left of the
 * system. The print-object attribute can be used to determine what, if anything, is printed at the start of each
 * system.
 *
 * Formatting specified in the `<group-name-display>` element overrides formatting specified in the `<group-name>`
 * element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-name-display/}
 */
var GroupNameDisplay = /** @class */ (function () {
    function GroupNameDisplay(opts) {
        var _a;
        this.schema = GroupNameDisplay.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, GroupNameDisplay.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(GroupNameDisplay.schema.contents);
    }
    /** Gets @type {GroupNameDisplayAttributes['print-object']}. */
    GroupNameDisplay.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {GroupNameDisplayAttributes['print-object']}. */
    GroupNameDisplay.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {Array<DisplayText | AccidentalText>}. */
    GroupNameDisplay.prototype.getTexts = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<DisplayText | AccidentalText>}. */
    GroupNameDisplay.prototype.setTexts = function (texts) {
        this.contents[0] = texts;
        return this;
    };
    GroupNameDisplay.schema = {
        name: 'group-name-display',
        attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
        contents: [
            {
                type: 'label',
                label: 'texts',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
            },
        ],
    };
    return GroupNameDisplay;
}());
exports.GroupNameDisplay = GroupNameDisplay;
/**
 * The `<group-abbreviation>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-abbreviation>` element describes the abbreviation of a `<part-group>` element. The formatting attributes
 * are deprecated as of Version 2.0 in favor of the new `<group-abbreviation-display>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-abbreviation/}
 */
var GroupAbbreviation = /** @class */ (function () {
    function GroupAbbreviation(opts) {
        var _a;
        this.schema = GroupAbbreviation.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, GroupAbbreviation.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(GroupAbbreviation.schema.contents);
    }
    /** Gets @type {GroupAbbreviationAttributes['color']}. */
    GroupAbbreviation.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {GroupAbbreviationAttributes['color']}. */
    GroupAbbreviation.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {GroupAbbreviationAttributes['default-x']}. */
    GroupAbbreviation.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {GroupAbbreviationAttributes['default-x']}. */
    GroupAbbreviation.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {GroupAbbreviationAttributes['default-y']}. */
    GroupAbbreviation.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {GroupAbbreviationAttributes['default-y']}. */
    GroupAbbreviation.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {GroupAbbreviationAttributes['font-family']}. */
    GroupAbbreviation.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {GroupAbbreviationAttributes['font-family']}. */
    GroupAbbreviation.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {GroupAbbreviationAttributes['font-size']}. */
    GroupAbbreviation.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {GroupAbbreviationAttributes['font-size']}. */
    GroupAbbreviation.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {GroupAbbreviationAttributes['font-style']}. */
    GroupAbbreviation.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {GroupAbbreviationAttributes['font-style']}. */
    GroupAbbreviation.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {GroupAbbreviationAttributes['font-weight']}. */
    GroupAbbreviation.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {GroupAbbreviationAttributes['font-weight']}. */
    GroupAbbreviation.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {GroupAbbreviationAttributes['justify']}. */
    GroupAbbreviation.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {GroupAbbreviationAttributes['justify']}. */
    GroupAbbreviation.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {GroupAbbreviationAttributes['relative-x']}. */
    GroupAbbreviation.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {GroupAbbreviationAttributes['relative-x']}. */
    GroupAbbreviation.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {GroupAbbreviationAttributes['relative-y']}. */
    GroupAbbreviation.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {GroupAbbreviationAttributes['relative-y']}. */
    GroupAbbreviation.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    GroupAbbreviation.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    GroupAbbreviation.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    GroupAbbreviation.schema = {
        name: 'group-abbreviation',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'string' }],
    };
    return GroupAbbreviation;
}());
exports.GroupAbbreviation = GroupAbbreviation;
/**
 * The `<group-abbreviation-display> element`
 *
 * Parent element: `<part-group>`
 *
 * The `<group-abbreviation-display> element is used for exact formatting of multi-font text in group abbreviations to
 * the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the
 * start of each system.`
 *
 * Formatting specified in the `<group-abbreviation-display> element overrides formatting specified in the
 * `<group-abbreviation> element.`
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-abbreviation-display/}
 */
var GroupAbbreviationDisplay = /** @class */ (function () {
    function GroupAbbreviationDisplay(opts) {
        var _a;
        this.schema = GroupAbbreviationDisplay.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, GroupAbbreviationDisplay.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(GroupAbbreviationDisplay.schema.contents);
    }
    /** Gets @type {GroupAbbreviationDisplayAttributes['print-object']}. */
    GroupAbbreviationDisplay.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {GroupAbbreviationDisplayAttributes['print-object']}. */
    GroupAbbreviationDisplay.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {Array<DisplayText | AccidentalText>}. */
    GroupAbbreviationDisplay.prototype.getTexts = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<DisplayText | AccidentalText>}. */
    GroupAbbreviationDisplay.prototype.setTexts = function (texts) {
        this.contents[0] = texts;
        return this;
    };
    GroupAbbreviationDisplay.schema = {
        name: 'group-abbreviation-display',
        attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
        contents: [
            {
                type: 'label',
                label: 'texts',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
            },
        ],
    };
    return GroupAbbreviationDisplay;
}());
exports.GroupAbbreviationDisplay = GroupAbbreviationDisplay;
/**
 * The `<group-symbol>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-symbol>` element indicates how the symbol for a group is indicated in the score. It is none if not
 * specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-symbol/}
 */
var GroupSymbol = /** @class */ (function () {
    function GroupSymbol(opts) {
        var _a;
        this.schema = GroupSymbol.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, GroupSymbol.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(GroupSymbol.schema.contents);
    }
    /** Gets @type {GroupSymbolAttributes['color']}. */
    GroupSymbol.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {GroupSymbolAttributes['color']}. */
    GroupSymbol.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {GroupSymbolAttributes['default-x']}. */
    GroupSymbol.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {GroupSymbolAttributes['default-x']}. */
    GroupSymbol.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {GroupSymbolAttributes['default-y']}. */
    GroupSymbol.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {GroupSymbolAttributes['default-y']}. */
    GroupSymbol.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {GroupSymbolAttributes['relative-x']}. */
    GroupSymbol.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {GroupSymbolAttributes['relative-x']}. */
    GroupSymbol.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {GroupSymbolAttributes['relative-y']}. */
    GroupSymbol.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {GroupSymbolAttributes['relative-y']}. */
    GroupSymbol.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {'none' | 'brace' | 'bracket' | 'line' | 'square'}. */
    GroupSymbol.prototype.getGroupSymbolValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'none' | 'brace' | 'bracket' | 'line' | 'square'}. */
    GroupSymbol.prototype.setGroupSymbolValue = function (groupSymbolValue) {
        this.contents[0] = groupSymbolValue;
        return this;
    };
    GroupSymbol.schema = {
        name: 'group-symbol',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'group-symbol-value',
                    value: { type: 'choices', choices: ['none', 'brace', 'bracket', 'line', 'square'] },
                },
            },
        ],
    };
    return GroupSymbol;
}());
exports.GroupSymbol = GroupSymbol;
/**
 * The `<group-barline>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-barline>` element indicates if the group should have common barlines.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-barline/}
 */
var GroupBarline = /** @class */ (function () {
    function GroupBarline(opts) {
        var _a;
        this.schema = GroupBarline.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, GroupBarline.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(GroupBarline.schema.contents);
    }
    /** Gets @type {GroupBarlineAttributes['color']}. */
    GroupBarline.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {GroupBarlineAttributes['color']}. */
    GroupBarline.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {'yes' | 'no' | 'Mensurstrich'}. */
    GroupBarline.prototype.getGroupBarlineValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'yes' | 'no' | 'Mensurstrich'}. */
    GroupBarline.prototype.setGroupBarlineValue = function (groupBarlineValue) {
        this.contents[0] = groupBarlineValue;
        return this;
    };
    GroupBarline.schema = {
        name: 'group-barline',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'group-barline-value',
                    value: { type: 'choices', choices: ['yes', 'no', 'Mensurstrich'] },
                },
            },
        ],
    };
    return GroupBarline;
}());
exports.GroupBarline = GroupBarline;
/**
 * The `<group-time>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-time>` element indicates that the displayed time signatures should stretch across all parts and staves in
 * the group.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-time/}
 */
var GroupTime = /** @class */ (function () {
    function GroupTime(opts) {
        var _a;
        this.schema = GroupTime.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, GroupTime.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(GroupTime.schema.contents);
    }
    GroupTime.schema = { name: 'group-time', attributes: {}, contents: [] };
    return GroupTime;
}());
exports.GroupTime = GroupTime;
/**
 * The `<footnote>` element
 *
 * Parent elements: `<attributes>`, `<backup>`, `<barline>`, `<direction>`, `<figure>`, `<figured-bass>`, `<forward>`,
 * `<harmony>`, `<lyric>`, `<notations>`, `<note>`, `<part-group>`
 *
 * The `<footnote>` element specifies editorial information that appears in footnotes in the printed score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/footnote/}
 */
var Footnote = /** @class */ (function () {
    function Footnote(opts) {
        var _a;
        this.schema = Footnote.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Footnote.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Footnote.schema.contents);
    }
    /** Gets @type {FootnoteAttributes['color']}. */
    Footnote.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FootnoteAttributes['color']}. */
    Footnote.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FootnoteAttributes['default-x']}. */
    Footnote.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {FootnoteAttributes['default-x']}. */
    Footnote.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {FootnoteAttributes['default-y']}. */
    Footnote.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {FootnoteAttributes['default-y']}. */
    Footnote.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {FootnoteAttributes['dir']}. */
    Footnote.prototype.getDir = function () {
        return this.attributes['dir'];
    };
    /** Sets @type {FootnoteAttributes['dir']}. */
    Footnote.prototype.setDir = function (dir) {
        this.attributes['dir'] = dir;
        return this;
    };
    /** Gets @type {FootnoteAttributes['enclosure']}. */
    Footnote.prototype.getEnclosure = function () {
        return this.attributes['enclosure'];
    };
    /** Sets @type {FootnoteAttributes['enclosure']}. */
    Footnote.prototype.setEnclosure = function (enclosure) {
        this.attributes['enclosure'] = enclosure;
        return this;
    };
    /** Gets @type {FootnoteAttributes['font-family']}. */
    Footnote.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FootnoteAttributes['font-family']}. */
    Footnote.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FootnoteAttributes['font-size']}. */
    Footnote.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FootnoteAttributes['font-size']}. */
    Footnote.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FootnoteAttributes['font-style']}. */
    Footnote.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FootnoteAttributes['font-style']}. */
    Footnote.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FootnoteAttributes['font-weight']}. */
    Footnote.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FootnoteAttributes['font-weight']}. */
    Footnote.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {FootnoteAttributes['halign']}. */
    Footnote.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {FootnoteAttributes['halign']}. */
    Footnote.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {FootnoteAttributes['justify']}. */
    Footnote.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {FootnoteAttributes['justify']}. */
    Footnote.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {FootnoteAttributes['letter-spacing']}. */
    Footnote.prototype.getLetterSpacing = function () {
        return this.attributes['letter-spacing'];
    };
    /** Sets @type {FootnoteAttributes['letter-spacing']}. */
    Footnote.prototype.setLetterSpacing = function (letterSpacing) {
        this.attributes['letter-spacing'] = letterSpacing;
        return this;
    };
    /** Gets @type {FootnoteAttributes['line-height']}. */
    Footnote.prototype.getLineHeight = function () {
        return this.attributes['line-height'];
    };
    /** Sets @type {FootnoteAttributes['line-height']}. */
    Footnote.prototype.setLineHeight = function (lineHeight) {
        this.attributes['line-height'] = lineHeight;
        return this;
    };
    /** Gets @type {FootnoteAttributes['line-through']}. */
    Footnote.prototype.getLineThrough = function () {
        return this.attributes['line-through'];
    };
    /** Sets @type {FootnoteAttributes['line-through']}. */
    Footnote.prototype.setLineThrough = function (lineThrough) {
        this.attributes['line-through'] = lineThrough;
        return this;
    };
    /** Gets @type {FootnoteAttributes['overline']}. */
    Footnote.prototype.getOverline = function () {
        return this.attributes['overline'];
    };
    /** Sets @type {FootnoteAttributes['overline']}. */
    Footnote.prototype.setOverline = function (overline) {
        this.attributes['overline'] = overline;
        return this;
    };
    /** Gets @type {FootnoteAttributes['relative-x']}. */
    Footnote.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {FootnoteAttributes['relative-x']}. */
    Footnote.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {FootnoteAttributes['relative-y']}. */
    Footnote.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {FootnoteAttributes['relative-y']}. */
    Footnote.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {FootnoteAttributes['rotation']}. */
    Footnote.prototype.getRotation = function () {
        return this.attributes['rotation'];
    };
    /** Sets @type {FootnoteAttributes['rotation']}. */
    Footnote.prototype.setRotation = function (rotation) {
        this.attributes['rotation'] = rotation;
        return this;
    };
    /** Gets @type {FootnoteAttributes['underline']}. */
    Footnote.prototype.getUnderline = function () {
        return this.attributes['underline'];
    };
    /** Sets @type {FootnoteAttributes['underline']}. */
    Footnote.prototype.setUnderline = function (underline) {
        this.attributes['underline'] = underline;
        return this;
    };
    /** Gets @type {FootnoteAttributes['valign']}. */
    Footnote.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {FootnoteAttributes['valign']}. */
    Footnote.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {FootnoteAttributes['xml:lang']}. */
    Footnote.prototype.getXmlLang = function () {
        return this.attributes['xml:lang'];
    };
    /** Sets @type {FootnoteAttributes['xml:lang']}. */
    Footnote.prototype.setXmlLang = function (xmlLang) {
        this.attributes['xml:lang'] = xmlLang;
        return this;
    };
    /** Gets @type {FootnoteAttributes['xml:space']}. */
    Footnote.prototype.getXmlSpace = function () {
        return this.attributes['xml:space'];
    };
    /** Sets @type {FootnoteAttributes['xml:space']}. */
    Footnote.prototype.setXmlSpace = function (xmlSpace) {
        this.attributes['xml:space'] = xmlSpace;
        return this;
    };
    /** Gets @type {string}. */
    Footnote.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Footnote.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Footnote.schema = {
        name: 'footnote',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
            enclosure: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        'none',
                        'rectangle',
                        'square',
                        'oval',
                        'circle',
                        'bracket',
                        'inverted-bracket',
                        'triangle',
                        'diamond',
                        'pentagon',
                        'hexagon',
                        'heptagon',
                        'octagon',
                        'nonagon',
                        'decagon',
                    ],
                },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'letter-spacing': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-height': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
            'xml:lang': { type: 'optional', value: { type: 'string' } },
            'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Footnote;
}());
exports.Footnote = Footnote;
/**
 * The `<level>` element
 *
 * Parent elements: `<attributes>`, `<backup>`, `<barline>`, `<direction>`, `<figure>`, `<figured-bass>`, `<forward>`,
 * `<harmony>`, `<lyric>`, `<notations>`, `<note>`, `<part-group>`
 *
 * The `<level>` element is used to specify editorial information for different MusicXML elements. The content contains
 * identifying and/or descriptive text about the editorial status of the parent element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/level/}
 */
var Level = /** @class */ (function () {
    function Level(opts) {
        var _a;
        this.schema = Level.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Level.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Level.schema.contents);
    }
    /** Gets @type {LevelAttributes['bracket']}. */
    Level.prototype.getBracket = function () {
        return this.attributes['bracket'];
    };
    /** Sets @type {LevelAttributes['bracket']}. */
    Level.prototype.setBracket = function (bracket) {
        this.attributes['bracket'] = bracket;
        return this;
    };
    /** Gets @type {LevelAttributes['parentheses']}. */
    Level.prototype.getParentheses = function () {
        return this.attributes['parentheses'];
    };
    /** Sets @type {LevelAttributes['parentheses']}. */
    Level.prototype.setParentheses = function (parentheses) {
        this.attributes['parentheses'] = parentheses;
        return this;
    };
    /** Gets @type {LevelAttributes['reference']}. */
    Level.prototype.getReference = function () {
        return this.attributes['reference'];
    };
    /** Sets @type {LevelAttributes['reference']}. */
    Level.prototype.setReference = function (reference) {
        this.attributes['reference'] = reference;
        return this;
    };
    /** Gets @type {LevelAttributes['size']}. */
    Level.prototype.getSize = function () {
        return this.attributes['size'];
    };
    /** Sets @type {LevelAttributes['size']}. */
    Level.prototype.setSize = function (size) {
        this.attributes['size'] = size;
        return this;
    };
    /** Gets @type {LevelAttributes['type']}. */
    Level.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {LevelAttributes['type']}. */
    Level.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {string}. */
    Level.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Level.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Level.schema = {
        name: 'level',
        attributes: {
            bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            reference: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
            type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop', 'single'] } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Level;
}());
exports.Level = Level;
/**
 * The `<part-list>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<part-list>` element identifies the different musical parts in this document. Each part has an ID that is used
 * later within the musical data. Since parts may be encoded separately and combined later, identification elements are
 * present at both the score and `<score-part>` levels.
 *
 * There must be at least one `<score-part>`, combined as desired with `<part-group>` elements that indicate braces and
 * brackets. Parts are ordered from top to bottom in a score based on the order in which they appear in the
 * `<part-list>`.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-list/}
 */
var PartGroup = /** @class */ (function () {
    function PartGroup(opts) {
        var _a;
        this.schema = PartGroup.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartGroup.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartGroup.schema.contents);
    }
    /** Gets @type {PartGroupAttributes['type']}. */
    PartGroup.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {PartGroupAttributes['type']}. */
    PartGroup.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {PartGroupAttributes['number']}. */
    PartGroup.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {PartGroupAttributes['number']}. */
    PartGroup.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {GroupName | null}. */
    PartGroup.prototype.getGroupName = function () {
        return this.contents[0];
    };
    /** Sets @type {GroupName | null}. */
    PartGroup.prototype.setGroupName = function (groupName) {
        this.contents[0] = groupName;
        return this;
    };
    /** Gets @type {GroupNameDisplay | null}. */
    PartGroup.prototype.getGroupNameDisplay = function () {
        return this.contents[1];
    };
    /** Sets @type {GroupNameDisplay | null}. */
    PartGroup.prototype.setGroupNameDisplay = function (groupNameDisplay) {
        this.contents[1] = groupNameDisplay;
        return this;
    };
    /** Gets @type {GroupAbbreviation | null}. */
    PartGroup.prototype.getGroupAbbreviation = function () {
        return this.contents[2];
    };
    /** Sets @type {GroupAbbreviation | null}. */
    PartGroup.prototype.setGroupAbbreviation = function (groupAbbreviation) {
        this.contents[2] = groupAbbreviation;
        return this;
    };
    /** Gets @type {GroupAbbreviationDisplay | null}. */
    PartGroup.prototype.getGroupAbbreviationDisplay = function () {
        return this.contents[3];
    };
    /** Sets @type {GroupAbbreviationDisplay | null}. */
    PartGroup.prototype.setGroupAbbreviationDisplay = function (groupAbbreviationDisplay) {
        this.contents[3] = groupAbbreviationDisplay;
        return this;
    };
    /** Gets @type {GroupSymbol | null}. */
    PartGroup.prototype.getGroupSymbol = function () {
        return this.contents[4];
    };
    /** Sets @type {GroupSymbol | null}. */
    PartGroup.prototype.setGroupSymbol = function (groupSymbol) {
        this.contents[4] = groupSymbol;
        return this;
    };
    /** Gets @type {GroupBarline | null}. */
    PartGroup.prototype.getGroupBarline = function () {
        return this.contents[5];
    };
    /** Sets @type {GroupBarline | null}. */
    PartGroup.prototype.setGroupBarline = function (groupBarline) {
        this.contents[5] = groupBarline;
        return this;
    };
    /** Gets @type {GroupTime | null}. */
    PartGroup.prototype.getGroupTime = function () {
        return this.contents[6];
    };
    /** Sets @type {GroupTime | null}. */
    PartGroup.prototype.setGroupTime = function (groupTime) {
        this.contents[6] = groupTime;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    PartGroup.prototype.getFootnote = function () {
        return this.contents[7];
    };
    /** Sets @type {Footnote | null}. */
    PartGroup.prototype.setFootnote = function (footnote) {
        this.contents[7] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    PartGroup.prototype.getLevel = function () {
        return this.contents[8];
    };
    /** Sets @type {Level | null}. */
    PartGroup.prototype.setLevel = function (level) {
        this.contents[8] = level;
        return this;
    };
    PartGroup.schema = {
        name: 'part-group',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            number: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            { type: 'optional', value: GroupName },
            { type: 'optional', value: GroupNameDisplay },
            { type: 'optional', value: GroupAbbreviation },
            { type: 'optional', value: GroupAbbreviationDisplay },
            { type: 'optional', value: GroupSymbol },
            { type: 'optional', value: GroupBarline },
            { type: 'optional', value: GroupTime },
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
        ],
    };
    return PartGroup;
}());
exports.PartGroup = PartGroup;
/**
 * The `<instrument-link>` element
 *
 * Parent element: `<part-link>`
 *
 * Multiple `<part-link>` elements can link a condensed part within a score file to multiple MusicXML parts files. For
 * example, a "Clarinet 1 and 2" part in a score file could link to separate "Clarinet 1" and "Clarinet 2" part files.
 * The `<instrument-link>` element distinguishes which of the `<score-instrument>`s within a `<score-part>` are in which part file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument-link/}
 */
var InstrumentLink = /** @class */ (function () {
    function InstrumentLink(opts) {
        var _a;
        this.schema = InstrumentLink.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, InstrumentLink.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(InstrumentLink.schema.contents);
    }
    /** Gets @type {InstrumentLinkAttributes['id']}. */
    InstrumentLink.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {InstrumentLinkAttributes['id']}. */
    InstrumentLink.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    InstrumentLink.schema = {
        name: 'instrument-link',
        attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [],
    };
    return InstrumentLink;
}());
exports.InstrumentLink = InstrumentLink;
/**
 * The `<group-link>` element
 *
 * Parent element: `<part-link>`
 *
 * Multiple `<part-link>` elements can reference different types of linked documents, such as parts and condensed score.
 * The optional `<group-link>` elements identify the groups used in the linked document. The content of a `<group-link>`
 * element should match the content of a `<group>` element in the linked document.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-link/}
 */
var GroupLink = /** @class */ (function () {
    function GroupLink(opts) {
        var _a;
        this.schema = GroupLink.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, GroupLink.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(GroupLink.schema.contents);
    }
    /** Gets @type {string}. */
    GroupLink.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    GroupLink.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    GroupLink.schema = {
        name: 'group-link',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return GroupLink;
}());
exports.GroupLink = GroupLink;
/**
 * The `<part-link>` element
 *
 * Parent element: `<score-part>`
 *
 * The `<part-link>` element allows MusicXML data for both score and parts to be contained within a single compressed
 * MusicXML file. It links a `<score-part>` from a score document to MusicXML documents that contain parts data. In the
 * case of a single compressed MusicXML file, the link href values are paths that are relative to the root folder of the
 * zip file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-link/}
 */
var PartLink = /** @class */ (function () {
    function PartLink(opts) {
        var _a;
        this.schema = PartLink.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartLink.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartLink.schema.contents);
    }
    /** Gets @type {PartLinkAttributes['xlink:href']}. */
    PartLink.prototype.getXlinkHref = function () {
        return this.attributes['xlink:href'];
    };
    /** Sets @type {PartLinkAttributes['xlink:href']}. */
    PartLink.prototype.setXlinkHref = function (xlinkHref) {
        this.attributes['xlink:href'] = xlinkHref;
        return this;
    };
    /** Gets @type {PartLinkAttributes['xlink:actuate']}. */
    PartLink.prototype.getXlinkActuate = function () {
        return this.attributes['xlink:actuate'];
    };
    /** Sets @type {PartLinkAttributes['xlink:actuate']}. */
    PartLink.prototype.setXlinkActuate = function (xlinkActuate) {
        this.attributes['xlink:actuate'] = xlinkActuate;
        return this;
    };
    /** Gets @type {PartLinkAttributes['xlink:role']}. */
    PartLink.prototype.getXlinkRole = function () {
        return this.attributes['xlink:role'];
    };
    /** Sets @type {PartLinkAttributes['xlink:role']}. */
    PartLink.prototype.setXlinkRole = function (xlinkRole) {
        this.attributes['xlink:role'] = xlinkRole;
        return this;
    };
    /** Gets @type {PartLinkAttributes['xlink:show']}. */
    PartLink.prototype.getXlinkShow = function () {
        return this.attributes['xlink:show'];
    };
    /** Sets @type {PartLinkAttributes['xlink:show']}. */
    PartLink.prototype.setXlinkShow = function (xlinkShow) {
        this.attributes['xlink:show'] = xlinkShow;
        return this;
    };
    /** Gets @type {PartLinkAttributes['xlink:title']}. */
    PartLink.prototype.getXlinkTitle = function () {
        return this.attributes['xlink:title'];
    };
    /** Sets @type {PartLinkAttributes['xlink:title']}. */
    PartLink.prototype.setXlinkTitle = function (xlinkTitle) {
        this.attributes['xlink:title'] = xlinkTitle;
        return this;
    };
    /** Gets @type {PartLinkAttributes['xlink:type']}. */
    PartLink.prototype.getXlinkType = function () {
        return this.attributes['xlink:type'];
    };
    /** Sets @type {PartLinkAttributes['xlink:type']}. */
    PartLink.prototype.setXlinkType = function (xlinkType) {
        this.attributes['xlink:type'] = xlinkType;
        return this;
    };
    /** Gets @type {Array<InstrumentLink>}. */
    PartLink.prototype.getInstrumentLinks = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<InstrumentLink>}. */
    PartLink.prototype.setInstrumentLinks = function (instrumentLinks) {
        this.contents[0] = instrumentLinks;
        return this;
    };
    /** Gets @type {Array<GroupLink>}. */
    PartLink.prototype.getGroupLinks = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<GroupLink>}. */
    PartLink.prototype.setGroupLinks = function (groupLinks) {
        this.contents[1] = groupLinks;
        return this;
    };
    PartLink.schema = {
        name: 'part-link',
        attributes: {
            'xlink:href': { type: 'required', value: { type: 'string' } },
            'xlink:actuate': {
                type: 'optional',
                value: { type: 'choices', choices: ['none', 'onRequest', 'onLoad', 'other'] },
            },
            'xlink:role': { type: 'optional', value: { type: 'string' } },
            'xlink:show': {
                type: 'optional',
                value: { type: 'choices', choices: ['none', 'new', 'replace', 'embed', 'other'] },
            },
            'xlink:title': { type: 'optional', value: { type: 'string' } },
            'xlink:type': { type: 'optional', value: { type: 'choices', choices: ['simple'] } },
        },
        contents: [
            { type: 'label', label: 'instrument-links', value: { type: 'zeroOrMore', value: InstrumentLink } },
            { type: 'label', label: 'group-links', value: { type: 'zeroOrMore', value: GroupLink } },
        ],
    };
    return PartLink;
}());
exports.PartLink = PartLink;
/**
 * The `<part-name>` element
 *
 * Parent element: `<score-part>`
 *
 * The `<part-name>` and `<part-abbreviation>` elements describe the name and abbreviation of a `<score-part>` element,
 * respectively. Formatting attributes for these elements were deprecated in Version 2.0 in favor of the
 * `<part-name-display>` and `<part-abbreviation-display>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-name/}
 */
var PartName = /** @class */ (function () {
    function PartName(opts) {
        var _a;
        this.schema = PartName.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartName.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartName.schema.contents);
    }
    /** Gets @type {PartNameAttributes['color']}. */
    PartName.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {PartNameAttributes['color']}. */
    PartName.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {PartNameAttributes['default-x']}. */
    PartName.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {PartNameAttributes['default-x']}. */
    PartName.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {PartNameAttributes['default-y']}. */
    PartName.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {PartNameAttributes['default-y']}. */
    PartName.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {PartNameAttributes['font-family']}. */
    PartName.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PartNameAttributes['font-family']}. */
    PartName.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PartNameAttributes['font-size']}. */
    PartName.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PartNameAttributes['font-size']}. */
    PartName.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PartNameAttributes['font-style']}. */
    PartName.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PartNameAttributes['font-style']}. */
    PartName.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PartNameAttributes['font-weight']}. */
    PartName.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PartNameAttributes['font-weight']}. */
    PartName.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {PartNameAttributes['justify']}. */
    PartName.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {PartNameAttributes['justify']}. */
    PartName.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {PartNameAttributes['print-object']}. */
    PartName.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {PartNameAttributes['print-object']}. */
    PartName.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {PartNameAttributes['relative-x']}. */
    PartName.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {PartNameAttributes['relative-x']}. */
    PartName.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {PartNameAttributes['relative-y']}. */
    PartName.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {PartNameAttributes['relative-y']}. */
    PartName.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    PartName.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    PartName.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    PartName.schema = {
        name: 'part-name',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return PartName;
}());
exports.PartName = PartName;
/**
 * The `<part-name-display>` element
 *
 * Parent elements: `<print>`, `<score-part>`
 *
 * The `<part-name-display>` element is used for exact formatting of multi-font text in part names to the left of the
 * system. The print-object attribute can be used to determine what, if anything, is printed at the start of each system.
 *
 * Formatting specified in the `<part-name-display>` element overrides formatting specified in the <part-name> element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-name-display/}
 */
var PartNameDisplay = /** @class */ (function () {
    function PartNameDisplay(opts) {
        var _a;
        this.schema = PartNameDisplay.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartNameDisplay.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartNameDisplay.schema.contents);
    }
    /** Gets @type {PartNameDisplayAttributes['print-object']}. */
    PartNameDisplay.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {PartNameDisplayAttributes['print-object']}. */
    PartNameDisplay.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {Array<DisplayText | AccidentalText>}. */
    PartNameDisplay.prototype.getTexts = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<DisplayText | AccidentalText>}. */
    PartNameDisplay.prototype.setTexts = function (texts) {
        this.contents[0] = texts;
        return this;
    };
    PartNameDisplay.schema = {
        name: 'part-name-display',
        attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
        contents: [
            {
                type: 'label',
                label: 'texts',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
            },
        ],
    };
    return PartNameDisplay;
}());
exports.PartNameDisplay = PartNameDisplay;
/**
 * The `<part-abbreviation>` element
 *
 * Parent element: `<score-part>`
 *
 * The `<part-name>` and `<part-abbreviation>` elements describe the name and abbreviation of a `<score-part>` element,
 * respectively. Formatting attributes for these elements were deprecated in Version 2.0 in favor of the
 * `<part-name-display>` and `<part-abbreviation-display>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-abbreviation/}
 */
var PartAbbreviation = /** @class */ (function () {
    function PartAbbreviation(opts) {
        var _a;
        this.schema = PartAbbreviation.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartAbbreviation.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartAbbreviation.schema.contents);
    }
    /** Gets @type {PartAbbreviationAttributes['color']}. */
    PartAbbreviation.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {PartAbbreviationAttributes['color']}. */
    PartAbbreviation.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {PartAbbreviationAttributes['default-x']}. */
    PartAbbreviation.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {PartAbbreviationAttributes['default-x']}. */
    PartAbbreviation.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {PartAbbreviationAttributes['default-y']}. */
    PartAbbreviation.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {PartAbbreviationAttributes['default-y']}. */
    PartAbbreviation.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {PartAbbreviationAttributes['font-family']}. */
    PartAbbreviation.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PartAbbreviationAttributes['font-family']}. */
    PartAbbreviation.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PartAbbreviationAttributes['font-size']}. */
    PartAbbreviation.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PartAbbreviationAttributes['font-size']}. */
    PartAbbreviation.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PartAbbreviationAttributes['font-style']}. */
    PartAbbreviation.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PartAbbreviationAttributes['font-style']}. */
    PartAbbreviation.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PartAbbreviationAttributes['font-weight']}. */
    PartAbbreviation.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PartAbbreviationAttributes['font-weight']}. */
    PartAbbreviation.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {PartAbbreviationAttributes['justify']}. */
    PartAbbreviation.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {PartAbbreviationAttributes['justify']}. */
    PartAbbreviation.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {PartAbbreviationAttributes['print-object']}. */
    PartAbbreviation.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {PartAbbreviationAttributes['print-object']}. */
    PartAbbreviation.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {PartAbbreviationAttributes['relative-x']}. */
    PartAbbreviation.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {PartAbbreviationAttributes['relative-x']}. */
    PartAbbreviation.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {PartAbbreviationAttributes['relative-y']}. */
    PartAbbreviation.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {PartAbbreviationAttributes['relative-y']}. */
    PartAbbreviation.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    PartAbbreviation.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    PartAbbreviation.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    PartAbbreviation.schema = {
        name: 'part-abbreviation',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return PartAbbreviation;
}());
exports.PartAbbreviation = PartAbbreviation;
/**
 * The `<part-abbreviation-display>` element
 *
 * Parent elements: `<print>`, `<score-part>`
 *
 * The `<part-abbreviation-display>` element is used for exact formatting of multi-font text in part abbreviations to
 * the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the
 * start of each system.
 *
 * Formatting specified in the `<part-abbreviation-display>` element overrides formatting specified in the
 * `<part-abbreviation>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-abbreviation-display/}
 */
var PartAbbreviationDisplay = /** @class */ (function () {
    function PartAbbreviationDisplay(opts) {
        var _a;
        this.schema = PartAbbreviationDisplay.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartAbbreviationDisplay.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartAbbreviationDisplay.schema.contents);
    }
    /** Gets @type {PartAbbreviationDisplayAttributes['print-object']}. */
    PartAbbreviationDisplay.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {PartAbbreviationDisplayAttributes['print-object']}. */
    PartAbbreviationDisplay.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {Array<DisplayText | AccidentalText>}. */
    PartAbbreviationDisplay.prototype.getTexts = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<DisplayText | AccidentalText>}. */
    PartAbbreviationDisplay.prototype.setTexts = function (texts) {
        this.contents[0] = texts;
        return this;
    };
    PartAbbreviationDisplay.schema = {
        name: 'part-abbreviation-display',
        attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
        contents: [
            {
                type: 'label',
                label: 'texts',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
            },
        ],
    };
    return PartAbbreviationDisplay;
}());
exports.PartAbbreviationDisplay = PartAbbreviationDisplay;
/**
 * The `<group>` element
 *
 * Parent element: `<score-part>`
 *
 * The `<group>` element allows the use of different versions of the part for different purposes. Typical values include
 * score, parts, sound, and data. Ordering information can be derived from the ordering within a MusicXML score or opus.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group/}
 */
var Group = /** @class */ (function () {
    function Group(opts) {
        var _a;
        this.schema = Group.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Group.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Group.schema.contents);
    }
    /** Gets @type {string}. */
    Group.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Group.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Group.schema = {
        name: 'group',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Group;
}());
exports.Group = Group;
/**
 * The `<instrument-name>` element
 *
 * Parent element: `<score-instrument>`
 *
 * The `<instrument-name>` element is typically used within a software application, rather than appearing on the printed
 * page of a score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument-name/}
 */
var InstrumentName = /** @class */ (function () {
    function InstrumentName(opts) {
        var _a;
        this.schema = InstrumentName.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, InstrumentName.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(InstrumentName.schema.contents);
    }
    /** Gets @type {string}. */
    InstrumentName.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    InstrumentName.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    InstrumentName.schema = {
        name: 'instrument-name',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return InstrumentName;
}());
exports.InstrumentName = InstrumentName;
/**
 * The `<instrument-abbreviation>` element
 *
 * Parent element: `<score-instrument>`
 *
 * The `<instrument-abbreviation>` element is typically used within a software application, rather than appearing on the
 * printed page of a score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument-abbreviation/}
 */
var InstrumentAbbreviation = /** @class */ (function () {
    function InstrumentAbbreviation(opts) {
        var _a;
        this.schema = InstrumentAbbreviation.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, InstrumentAbbreviation.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(InstrumentAbbreviation.schema.contents);
    }
    /** Gets @type {string}. */
    InstrumentAbbreviation.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    InstrumentAbbreviation.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    InstrumentAbbreviation.schema = {
        name: 'instrument-abbreviation',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return InstrumentAbbreviation;
}());
exports.InstrumentAbbreviation = InstrumentAbbreviation;
/**
 * The `<instrument-sound>` element
 *
 * Parent elements: `<instrument-change>`, `<score-instrument>`
 *
 * The `<instrument-sound>` element describes the default timbre of the `<score-instrument>`. This description is
 * independent of a particular virtual or MIDI instrument specification and allows playback to be shared more easily
 * between applications and libraries.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument-sound/}
 */
var InstrumentSound = /** @class */ (function () {
    function InstrumentSound(opts) {
        var _a;
        this.schema = InstrumentSound.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, InstrumentSound.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(InstrumentSound.schema.contents);
    }
    /** Gets @type {string}. */
    InstrumentSound.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    InstrumentSound.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    InstrumentSound.schema = {
        name: 'instrument-sound',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return InstrumentSound;
}());
exports.InstrumentSound = InstrumentSound;
/**
 * The `<solo>` element
 *
 * Parent elements: `<instrument-change>`, `<score-instrument>`
 *
 * The `<solo>` element is present if performance is intended by a solo instrument.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/solo/}
 */
var Solo = /** @class */ (function () {
    function Solo(opts) {
        var _a;
        this.schema = Solo.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Solo.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Solo.schema.contents);
    }
    Solo.schema = { name: 'solo', attributes: {}, contents: [] };
    return Solo;
}());
exports.Solo = Solo;
/**
 * The `<ensemble>` element
 *
 * Parent elements: `<instrument-change>`, `<score-instrument>`
 *
 * The `<ensemble>` element is present if performance is intended by an ensemble such as an orchestral section. The text
 * of the `<ensemble>` element contains the size of the section, or is empty if the ensemble size is not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ensemble/}
 */
var Ensemble = /** @class */ (function () {
    function Ensemble(opts) {
        var _a;
        this.schema = Ensemble.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Ensemble.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Ensemble.schema.contents);
    }
    /** Gets @type {'' | number}. */
    Ensemble.prototype.getSize = function () {
        return this.contents[0];
    };
    /** Sets @type {'' | number}. */
    Ensemble.prototype.setSize = function (size) {
        this.contents[0] = size;
        return this;
    };
    Ensemble.schema = {
        name: 'ensemble',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'size',
                value: { type: 'required', value: { type: 'choices', choices: ['', { type: 'int', min: 1, max: Infinity }] } },
            },
        ],
    };
    return Ensemble;
}());
exports.Ensemble = Ensemble;
/**
 * The `<virtual-library>` element
 *
 * Parent element: `<virtual-instrument>`
 *
 * The `<virtual-library>` element indicates the virtual instrument library name.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/virtual-library/}
 */
var VirtualLibrary = /** @class */ (function () {
    function VirtualLibrary(opts) {
        var _a;
        this.schema = VirtualLibrary.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, VirtualLibrary.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(VirtualLibrary.schema.contents);
    }
    /** Gets @type {string}. */
    VirtualLibrary.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    VirtualLibrary.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    VirtualLibrary.schema = {
        name: 'virtual-library',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return VirtualLibrary;
}());
exports.VirtualLibrary = VirtualLibrary;
/**
 * The `<virtual-name>` element
 *
 * Parent element: `<virtual-instrument>`
 *
 * The `<virtual-name>` element indicates the library-specific name for the virtual instrument.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/virtual-name/}
 */
var VirtualName = /** @class */ (function () {
    function VirtualName(opts) {
        var _a;
        this.schema = VirtualName.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, VirtualName.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(VirtualName.schema.contents);
    }
    /** Gets @type {string}. */
    VirtualName.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    VirtualName.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    VirtualName.schema = {
        name: 'virtual-name',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return VirtualName;
}());
exports.VirtualName = VirtualName;
/**
 * The `<virtual-instrument>` element
 *
 * Parent elements: `<instrument-change>`, `<score-instrument>`
 *
 * The `<virtual-instrument>` element defines a specific virtual instrument used for an `<instrument sound>`.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/virtual-instrument/}
 */
var VirtualInstrument = /** @class */ (function () {
    function VirtualInstrument(opts) {
        var _a;
        this.schema = VirtualInstrument.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, VirtualInstrument.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(VirtualInstrument.schema.contents);
    }
    /** Gets @type {VirtualLibrary | null}. */
    VirtualInstrument.prototype.getVirtualLibrary = function () {
        return this.contents[0];
    };
    /** Sets @type {VirtualLibrary | null}. */
    VirtualInstrument.prototype.setVirtualLibrary = function (virtualLibrary) {
        this.contents[0] = virtualLibrary;
        return this;
    };
    /** Gets @type {VirtualName | null}. */
    VirtualInstrument.prototype.getVirtualName = function () {
        return this.contents[1];
    };
    /** Sets @type {VirtualName | null}. */
    VirtualInstrument.prototype.setVirtualName = function (virtualName) {
        this.contents[1] = virtualName;
        return this;
    };
    VirtualInstrument.schema = {
        name: 'virtual-instrument',
        attributes: {},
        contents: [
            { type: 'optional', value: VirtualLibrary },
            { type: 'optional', value: VirtualName },
        ],
    };
    return VirtualInstrument;
}());
exports.VirtualInstrument = VirtualInstrument;
/**
 * Parent element: `<score-part>`
 *
 * The `<score-instrument>` element represents a single instrument within a `<score-part>`. As with the `<score-part>`
 * element, each `<score-instrument>` has a required ID attribute, a name, and an optional abbreviation.
 *
 * A `<score-instrument>` element is also required if the score specifies MIDI 1.0 channels, banks, or programs. An
 * initial `<midi-instrument>` assignment can also be made here. MusicXML software should be able to automatically
 * assign reasonable channels and instruments without these elements in simple cases, such as where part names match
 * General MIDI instrument names.
 *
 * The `<score-instrument>` element can also distinguish multiple instruments of the same type that are on the same
 * part, such as Clarinet 1 and Clarinet 2 instruments within a Clarinets 1 and 2 part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/score-instrument/}
 */
var ScoreInstrument = /** @class */ (function () {
    function ScoreInstrument(opts) {
        var _a;
        this.schema = ScoreInstrument.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ScoreInstrument.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ScoreInstrument.schema.contents);
    }
    /** Gets @type {ScoreInstrumentAttributes['id']}. */
    ScoreInstrument.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {ScoreInstrumentAttributes['id']}. */
    ScoreInstrument.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {InstrumentName}. */
    ScoreInstrument.prototype.getInstrumentName = function () {
        return this.contents[0];
    };
    /** Sets @type {InstrumentName}. */
    ScoreInstrument.prototype.setInstrumentName = function (instrumentName) {
        this.contents[0] = instrumentName;
        return this;
    };
    /** Gets @type {InstrumentAbbreviation | null}. */
    ScoreInstrument.prototype.getInstrumentAbbreviation = function () {
        return this.contents[1];
    };
    /** Sets @type {InstrumentAbbreviation | null}. */
    ScoreInstrument.prototype.setInstrumentAbbreviation = function (instrumentAbbreviation) {
        this.contents[1] = instrumentAbbreviation;
        return this;
    };
    /** Gets @type {InstrumentSound | null}. */
    ScoreInstrument.prototype.getInstrumentSound = function () {
        return this.contents[2];
    };
    /** Sets @type {InstrumentSound | null}. */
    ScoreInstrument.prototype.setInstrumentSound = function (instrumentSound) {
        this.contents[2] = instrumentSound;
        return this;
    };
    /** Gets @type {Array<Solo | Ensemble>}. */
    ScoreInstrument.prototype.getInstrumentTypes = function () {
        return this.contents[3];
    };
    /** Sets @type {Array<Solo | Ensemble>}. */
    ScoreInstrument.prototype.setInstrumentTypes = function (instrumentTypes) {
        this.contents[3] = instrumentTypes;
        return this;
    };
    /** Gets @type {VirtualInstrument | null}. */
    ScoreInstrument.prototype.getVirtualInstrument = function () {
        return this.contents[4];
    };
    /** Sets @type {VirtualInstrument | null}. */
    ScoreInstrument.prototype.setVirtualInstrument = function (virtualInstrument) {
        this.contents[4] = virtualInstrument;
        return this;
    };
    ScoreInstrument.schema = {
        name: 'score-instrument',
        attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [
            { type: 'required', value: InstrumentName },
            { type: 'optional', value: InstrumentAbbreviation },
            { type: 'optional', value: InstrumentSound },
            {
                type: 'label',
                label: 'instrument-types',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Solo, Ensemble] } },
            },
            { type: 'optional', value: VirtualInstrument },
        ],
    };
    return ScoreInstrument;
}());
exports.ScoreInstrument = ScoreInstrument;
/**
 * The `<player>` element
 *
 * Parent element: `<score-part>`
 *
 * The `<player>` element allows for multiple players per `<score-part>` for use in listening applications. One player
 * may play multiple instruments, while a single instrument may include multiple players in divisi sections.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/player/}
 */
var Player = /** @class */ (function () {
    function Player(opts) {
        var _a;
        this.schema = Player.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Player.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Player.schema.contents);
    }
    /** Gets @type {PlayerAttributes['id']}. */
    Player.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {PlayerAttributes['id']}. */
    Player.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    Player.schema = {
        name: 'player',
        attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [],
    };
    return Player;
}());
exports.Player = Player;
/**
 * The `<midi-device>` element
 *
 * Parent elements: `<score-part>`, `<sound>`
 *
 * The `<midi-device>` element corresponds to the DeviceName meta event in Standard MIDI Files. Unlike the DeviceName
 * meta event, there can be multiple `<midi-device>` elements per MusicXML part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-device/}
 */
var MidiDevice = /** @class */ (function () {
    function MidiDevice(opts) {
        var _a;
        this.schema = MidiDevice.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MidiDevice.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MidiDevice.schema.contents);
    }
    /** Gets @type {MidiDeviceAttributes['id']}. */
    MidiDevice.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {MidiDeviceAttributes['id']}. */
    MidiDevice.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {MidiDeviceAttributes['midi16']}. */
    MidiDevice.prototype.getMidi16 = function () {
        return this.attributes['port'];
    };
    /** Sets @type {MidiDeviceAttributes['midi16']}. */
    MidiDevice.prototype.setMidi16 = function (midi16) {
        this.attributes['port'] = midi16;
        return this;
    };
    /** Gets @type {string}. */
    MidiDevice.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    MidiDevice.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    MidiDevice.schema = {
        name: 'midi-device',
        attributes: {
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            port: { type: 'optional', value: { type: 'label', label: 'midi16', value: { type: 'int', min: 1, max: 16 } } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return MidiDevice;
}());
exports.MidiDevice = MidiDevice;
/**
 * The `<midi-channel>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<midi-channel>` element specifies a MIDI 1.0 channel numbers ranging from 1 to 16.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-channel/}
 */
var MidiChannel = /** @class */ (function () {
    function MidiChannel(opts) {
        var _a;
        this.schema = MidiChannel.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MidiChannel.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MidiChannel.schema.contents);
    }
    /** Gets @type {number}. */
    MidiChannel.prototype.getMidi16 = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    MidiChannel.prototype.setMidi16 = function (midi16) {
        this.contents[0] = midi16;
        return this;
    };
    MidiChannel.schema = {
        name: 'midi-channel',
        attributes: {},
        contents: [
            { type: 'required', value: { type: 'label', label: 'midi16', value: { type: 'int', min: 1, max: 16 } } },
        ],
    };
    return MidiChannel;
}());
exports.MidiChannel = MidiChannel;
/**
 * The `<midi-name>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<midi-name>` element corresponds to a ProgramName meta-event within a Standard MIDI File.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-name/}
 */
var MidiName = /** @class */ (function () {
    function MidiName(opts) {
        var _a;
        this.schema = MidiName.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MidiName.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MidiName.schema.contents);
    }
    /** Gets @type {string}. */
    MidiName.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    MidiName.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    MidiName.schema = {
        name: 'midi-name',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return MidiName;
}());
exports.MidiName = MidiName;
/**
 * The `<midi-bank>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<midi-bank>` element specifies a MIDI 1.0 bank number ranging from 1 to 16,384.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-bank/}
 */
var MidiBank = /** @class */ (function () {
    function MidiBank(opts) {
        var _a;
        this.schema = MidiBank.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MidiBank.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MidiBank.schema.contents);
    }
    /** Gets @type {number}. */
    MidiBank.prototype.getMidi16384 = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    MidiBank.prototype.setMidi16384 = function (midi16384) {
        this.contents[0] = midi16384;
        return this;
    };
    MidiBank.schema = {
        name: 'midi-bank',
        attributes: {},
        contents: [
            { type: 'required', value: { type: 'label', label: 'midi16384', value: { type: 'int', min: 1, max: 16384 } } },
        ],
    };
    return MidiBank;
}());
exports.MidiBank = MidiBank;
/**
 * The `<midi-program>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<midi-program>` element specifies a MIDI 1.0 program number ranging from 1 to 128.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-program/}
 */
var MidiProgram = /** @class */ (function () {
    function MidiProgram(opts) {
        var _a;
        this.schema = MidiProgram.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MidiProgram.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MidiProgram.schema.contents);
    }
    /** Gets @type {number}. */
    MidiProgram.prototype.getMidi128 = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    MidiProgram.prototype.setMidi128 = function (midi128) {
        this.contents[0] = midi128;
        return this;
    };
    MidiProgram.schema = {
        name: 'midi-program',
        attributes: {},
        contents: [
            { type: 'required', value: { type: 'label', label: 'midi128', value: { type: 'int', min: 1, max: 128 } } },
        ],
    };
    return MidiProgram;
}());
exports.MidiProgram = MidiProgram;
/**
 * The `<midi-unpitched>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * For unpitched instruments, the `<midi-unpitched>` element specifies a MIDI 1.0 note number ranging from 1 to 128. It
 * is usually used with MIDI banks for percussion. Note that MIDI 1.0 note numbers are generally specified from 0 to 127
 * rather than the 1 to 128 numbering used in this element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-unpitched/}
 */
var MidiUnpitched = /** @class */ (function () {
    function MidiUnpitched(opts) {
        var _a;
        this.schema = MidiUnpitched.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MidiUnpitched.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MidiUnpitched.schema.contents);
    }
    /** Gets @type {number}. */
    MidiUnpitched.prototype.getMidi128 = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    MidiUnpitched.prototype.setMidi128 = function (midi128) {
        this.contents[0] = midi128;
        return this;
    };
    MidiUnpitched.schema = {
        name: 'midi-unpitched',
        attributes: {},
        contents: [
            { type: 'required', value: { type: 'label', label: 'midi128', value: { type: 'int', min: 1, max: 128 } } },
        ],
    };
    return MidiUnpitched;
}());
exports.MidiUnpitched = MidiUnpitched;
/**
 * The `<volume>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<volume>` element value is a percentage of the maximum ranging from 0 to 100, with decimal values allowed. This
 * corresponds to a scaling value for the MIDI 1.0 channel volume controller.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/volume/}
 */
var Volume = /** @class */ (function () {
    function Volume(opts) {
        var _a;
        this.schema = Volume.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Volume.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Volume.schema.contents);
    }
    /** Gets @type {number}. */
    Volume.prototype.getVolume = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Volume.prototype.setVolume = function (volume) {
        this.contents[0] = volume;
        return this;
    };
    Volume.schema = {
        name: 'volume',
        attributes: {},
        contents: [
            { type: 'label', label: 'volume', value: { type: 'required', value: { type: 'float', min: 0, max: 100 } } },
        ],
    };
    return Volume;
}());
exports.Volume = Volume;
/**
 * The `<pan>` element
 *
 * Parent element: `<midi-instrument>`\
 *
 * The `<pan>` and `<elevation>` elements allow placing of sound in a 3-D space relative to the listener. Both are
 * expressed in degrees ranging from -180 to 180. For pan, 0 is straight ahead, -90 is hard left, 90 is hard right, and
 * -180 and 180 are directly behind the listener.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pan/}
 */
var Pan = /** @class */ (function () {
    function Pan(opts) {
        var _a;
        this.schema = Pan.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Pan.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Pan.schema.contents);
    }
    /** Gets @type {number}. */
    Pan.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Pan.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Pan.schema = {
        name: 'pan',
        attributes: {},
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'float', min: -180, max: 180 } } },
        ],
    };
    return Pan;
}());
exports.Pan = Pan;
/**
 * The `<elevation>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<elevation>` and `<pan>` elements allow placing of sound in a 3-D space relative to the listener. Both are
 * expressed in degrees ranging from -180 to 180. For `<elevation>`, 0 is level with the listener, 90 is directly above,
 * and -90 is directly below.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/elevation/}
 */
var Elevation = /** @class */ (function () {
    function Elevation(opts) {
        var _a;
        this.schema = Elevation.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Elevation.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Elevation.schema.contents);
    }
    /** Gets @type {number}. */
    Elevation.prototype.getElevation = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Elevation.prototype.setElevation = function (elevation) {
        this.contents[0] = elevation;
        return this;
    };
    Elevation.schema = {
        name: 'elevation',
        attributes: {},
        contents: [
            { type: 'label', label: 'elevation', value: { type: 'required', value: { type: 'float', min: -180, max: 180 } } },
        ],
    };
    return Elevation;
}());
exports.Elevation = Elevation;
/**
 * The `<midi-instrument>` element
 *
 * Parent elements: `<score-part>`, `<sound>`
 *
 * The `<midi-instrument>` element defines MIDI 1.0 instrument playback. The `<midi-instrument>` element can be a part
 * of either the `<score-instrument>` element at the start of a part, or the <sound>` element within a part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-instrument/}
 */
var MidiInstrument = /** @class */ (function () {
    function MidiInstrument(opts) {
        var _a;
        this.schema = MidiInstrument.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MidiInstrument.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MidiInstrument.schema.contents);
    }
    /** Gets @type {MidiInstrumentAttributes['id']}. */
    MidiInstrument.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {MidiInstrumentAttributes['id']}. */
    MidiInstrument.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {MidiChannel | null}. */
    MidiInstrument.prototype.getMidiChannel = function () {
        return this.contents[0];
    };
    /** Sets @type {MidiChannel | null}. */
    MidiInstrument.prototype.setMidiChannel = function (midiChannel) {
        this.contents[0] = midiChannel;
        return this;
    };
    /** Gets @type {MidiName | null}. */
    MidiInstrument.prototype.getMidiName = function () {
        return this.contents[1];
    };
    /** Sets @type {MidiName | null}. */
    MidiInstrument.prototype.setMidiName = function (midiName) {
        this.contents[1] = midiName;
        return this;
    };
    /** Gets @type {MidiBank | null}. */
    MidiInstrument.prototype.getMidiBank = function () {
        return this.contents[2];
    };
    /** Sets @type {MidiBank | null}. */
    MidiInstrument.prototype.setMidiBank = function (midiBank) {
        this.contents[2] = midiBank;
        return this;
    };
    /** Gets @type {MidiProgram | null}. */
    MidiInstrument.prototype.getMidiProgram = function () {
        return this.contents[3];
    };
    /** Sets @type {MidiProgram | null}. */
    MidiInstrument.prototype.setMidiProgram = function (midiProgram) {
        this.contents[3] = midiProgram;
        return this;
    };
    /** Gets @type {MidiUnpitched | null}. */
    MidiInstrument.prototype.getMidiUnpitched = function () {
        return this.contents[4];
    };
    /** Sets @type {MidiUnpitched | null}. */
    MidiInstrument.prototype.setMidiUnpitched = function (midiUnpitched) {
        this.contents[4] = midiUnpitched;
        return this;
    };
    /** Gets @type {Volume | null}. */
    MidiInstrument.prototype.getVolume = function () {
        return this.contents[5];
    };
    /** Sets @type {Volume | null}. */
    MidiInstrument.prototype.setVolume = function (volume) {
        this.contents[5] = volume;
        return this;
    };
    /** Gets @type {Pan | null}. */
    MidiInstrument.prototype.getPan = function () {
        return this.contents[6];
    };
    /** Sets @type {Pan | null}. */
    MidiInstrument.prototype.setPan = function (pan) {
        this.contents[6] = pan;
        return this;
    };
    /** Gets @type {Elevation | null}. */
    MidiInstrument.prototype.getElevation = function () {
        return this.contents[7];
    };
    /** Sets @type {Elevation | null}. */
    MidiInstrument.prototype.setElevation = function (elevation) {
        this.contents[7] = elevation;
        return this;
    };
    MidiInstrument.schema = {
        name: 'midi-instrument',
        attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [
            { type: 'optional', value: MidiChannel },
            { type: 'optional', value: MidiName },
            { type: 'optional', value: MidiBank },
            { type: 'optional', value: MidiProgram },
            { type: 'optional', value: MidiUnpitched },
            { type: 'optional', value: Volume },
            { type: 'optional', value: Pan },
            { type: 'optional', value: Elevation },
        ],
    };
    return MidiInstrument;
}());
exports.MidiInstrument = MidiInstrument;
/**
 * The `<score-part>` element
 *
 * Parent element: `<part-list>`
 *
 * The `<score-part>` element collects part-wide information for each part in a score. Often each MusicXML part
 * corresponds to a track in a Standard MIDI Format 1 file. In this case, the `<midi-device>` element is used to make a
 * MIDI device or port assignment for the given track or specific MIDI instruments. Initial `<midi-instrument>`
 * assignments may be made here as well.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/score-part/}
 */
var ScorePart = /** @class */ (function () {
    function ScorePart(opts) {
        var _a;
        this.schema = ScorePart.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ScorePart.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ScorePart.schema.contents);
    }
    /** Gets @type {ScorePartAttributes['id']}. */
    ScorePart.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {ScorePartAttributes['id']}. */
    ScorePart.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {Identification | null}. */
    ScorePart.prototype.getIdentification = function () {
        return this.contents[0];
    };
    /** Sets @type {Identification | null}. */
    ScorePart.prototype.setIdentification = function (identification) {
        this.contents[0] = identification;
        return this;
    };
    /** Gets @type {Array<PartLink>}. */
    ScorePart.prototype.getPartLinks = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<PartLink>}. */
    ScorePart.prototype.setPartLinks = function (partLinks) {
        this.contents[1] = partLinks;
        return this;
    };
    /** Gets @type {PartName}. */
    ScorePart.prototype.getPartName = function () {
        return this.contents[2];
    };
    /** Sets @type {PartName}. */
    ScorePart.prototype.setPartName = function (partName) {
        this.contents[2] = partName;
        return this;
    };
    /** Gets @type {PartNameDisplay | null}. */
    ScorePart.prototype.getPartNameDisplay = function () {
        return this.contents[3];
    };
    /** Sets @type {PartNameDisplay | null}. */
    ScorePart.prototype.setPartNameDisplay = function (partNameDisplay) {
        this.contents[3] = partNameDisplay;
        return this;
    };
    /** Gets @type {PartAbbreviation | null}. */
    ScorePart.prototype.getPartAbbreviation = function () {
        return this.contents[4];
    };
    /** Sets @type {PartAbbreviation | null}. */
    ScorePart.prototype.setPartAbbreviation = function (partAbbreviation) {
        this.contents[4] = partAbbreviation;
        return this;
    };
    /** Gets @type {PartAbbreviationDisplay | null}. */
    ScorePart.prototype.getPartAbbreviationDisplay = function () {
        return this.contents[5];
    };
    /** Sets @type {PartAbbreviationDisplay | null}. */
    ScorePart.prototype.setPartAbbreviationDisplay = function (partAbbreviationDisplay) {
        this.contents[5] = partAbbreviationDisplay;
        return this;
    };
    /** Gets @type {Array<Group>}. */
    ScorePart.prototype.getGroups = function () {
        return this.contents[6];
    };
    /** Sets @type {Array<Group>}. */
    ScorePart.prototype.setGroups = function (groups) {
        this.contents[6] = groups;
        return this;
    };
    /** Gets @type {Array<ScoreInstrument>}. */
    ScorePart.prototype.getScoreInstruments = function () {
        return this.contents[7];
    };
    /** Sets @type {Array<ScoreInstrument>}. */
    ScorePart.prototype.setScoreInstruments = function (scoreInstruments) {
        this.contents[7] = scoreInstruments;
        return this;
    };
    /** Gets @type {Array<Player>}. */
    ScorePart.prototype.getPlayers = function () {
        return this.contents[8];
    };
    /** Sets @type {Array<Player>}. */
    ScorePart.prototype.setPlayers = function (players) {
        this.contents[8] = players;
        return this;
    };
    /** Gets @type {Array<MidiDevice | MidiInstrument>}. */
    ScorePart.prototype.getMidis = function () {
        return this.contents[9];
    };
    /** Sets @type {Array<MidiDevice | MidiInstrument>}. */
    ScorePart.prototype.setMidis = function (midis) {
        this.contents[9] = midis;
        return this;
    };
    ScorePart.schema = {
        name: 'score-part',
        attributes: { id: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
        contents: [
            { type: 'optional', value: Identification },
            { type: 'label', label: 'part-links', value: { type: 'zeroOrMore', value: PartLink } },
            { type: 'required', value: PartName },
            { type: 'optional', value: PartNameDisplay },
            { type: 'optional', value: PartAbbreviation },
            { type: 'optional', value: PartAbbreviationDisplay },
            { type: 'label', label: 'groups', value: { type: 'zeroOrMore', value: Group } },
            { type: 'label', label: 'score-instruments', value: { type: 'zeroOrMore', value: ScoreInstrument } },
            { type: 'label', label: 'players', value: { type: 'zeroOrMore', value: Player } },
            {
                type: 'label',
                label: 'midis',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [MidiDevice, MidiInstrument] } },
            },
        ],
    };
    return ScorePart;
}());
exports.ScorePart = ScorePart;
/**
 * The `<part-list>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<part-list>` element identifies the different musical parts in this document. Each part has an ID that is used
 * later within the musical data. Since parts may be encoded separately and combined later, identification elements are
 * present at both the score and <score-part> levels.
 *
 * There must be at least one `<score-part>`, combined as desired with `<part-group>` elements that indicate braces and
 * brackets. Parts are ordered from top to bottom in a score based on the order in which they appear in the
 * `<part-list>`.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-list/}
 */
var PartList = /** @class */ (function () {
    function PartList(opts) {
        var _a;
        this.schema = PartList.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartList.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartList.schema.contents);
    }
    /** Gets @type {Array<PartGroup>}. */
    PartList.prototype.getPartGroups = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<PartGroup>}. */
    PartList.prototype.setPartGroups = function (partGroups) {
        this.contents[0] = partGroups;
        return this;
    };
    /** Gets @type {ScorePart}. */
    PartList.prototype.getScorePart = function () {
        return this.contents[1];
    };
    /** Sets @type {ScorePart}. */
    PartList.prototype.setScorePart = function (scorePart) {
        this.contents[1] = scorePart;
        return this;
    };
    /** Gets @type {Array<PartGroup | ScorePart>}. */
    PartList.prototype.getParts = function () {
        return this.contents[2];
    };
    /** Sets @type {Array<PartGroup | ScorePart>}. */
    PartList.prototype.setParts = function (parts) {
        this.contents[2] = parts;
        return this;
    };
    PartList.schema = {
        name: 'part-list',
        attributes: {},
        contents: [
            { type: 'label', label: 'part-groups', value: { type: 'zeroOrMore', value: PartGroup } },
            { type: 'required', value: ScorePart },
            {
                type: 'label',
                label: 'parts',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [PartGroup, ScorePart] } },
            },
        ],
    };
    return PartList;
}());
exports.PartList = PartList;
/**
 * The `<chord>` element
 *
 * Parent element: `<note>`
 *
 * The `<chord>` element indicates that this note is an additional chord tone with the preceding note.
 *
 * The `<duration>` of a `<chord>` note does not move the musical position within a `<measure>`. That is done by the
 * `<duration>` of the first preceding note without a `<chord>` element. Thus the `<duration>` of a `<chord>` note
 * cannot be longer than the preceding note.
 *
 * In most cases the `<duration>` will be the same as the preceding note. However it can be shorter in situations such
 * as multiple stops for string instruments. Here is an example from Mozart's Concerto No. 3 for Violin, K. 216:
 *
 * If these first three notes are represented as a chord, the quarter notes must be the ones with the `<chord>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/chord/}
 */
var Chord = /** @class */ (function () {
    function Chord(opts) {
        var _a;
        this.schema = Chord.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Chord.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Chord.schema.contents);
    }
    Chord.schema = { name: 'chord', attributes: {}, contents: [] };
    return Chord;
}());
exports.Chord = Chord;
/**
 * The `<step>` element
 *
 * Parent element: `<pitch>`
 *
 * The `<step>` element represents a step of the diatonic scale, represented using the English letters A through G.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/step/}
 */
var Step = /** @class */ (function () {
    function Step(opts) {
        var _a;
        this.schema = Step.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Step.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Step.schema.contents);
    }
    /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    Step.prototype.getStep = function () {
        return this.contents[0];
    };
    /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    Step.prototype.setStep = function (step) {
        this.contents[0] = step;
        return this;
    };
    Step.schema = {
        name: 'step',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'step',
                    value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
                },
            },
        ],
    };
    return Step;
}());
exports.Step = Step;
/**
 * The `<alter>` element
 *
 * Parent element: `<pitch>`
 *
 * The `<alter> element represents chromatic alteration in number of semitones (e.g., -1 for flat, 1 for sharp). Decimal
 * values like 0.5 (quarter tone sharp) are used for microtones.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/alter/}
 */
var Alter = /** @class */ (function () {
    function Alter(opts) {
        var _a;
        this.schema = Alter.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Alter.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Alter.schema.contents);
    }
    /** Gets @type {number}. */
    Alter.prototype.getSemitones = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Alter.prototype.setSemitones = function (semitones) {
        this.contents[0] = semitones;
        return this;
    };
    Alter.schema = {
        name: 'alter',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return Alter;
}());
exports.Alter = Alter;
/**
 * The `<octave>` element
 *
 * Parent element: `<pitch>`
 *
 * Octaves are represented by the numbers 0 to 9, where 4 indicates the octave started by middle C.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/octave/}
 */
var Octave = /** @class */ (function () {
    function Octave(opts) {
        var _a;
        this.schema = Octave.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Octave.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Octave.schema.contents);
    }
    /** Gets @type {number}. */
    Octave.prototype.getOctave = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Octave.prototype.setOctave = function (octave) {
        this.contents[0] = octave;
        return this;
    };
    Octave.schema = {
        name: 'octave',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
    };
    return Octave;
}());
exports.Octave = Octave;
/**
 * The `<pitch>` element
 *
 * Parent element: `<note>`
 *
 * Pitch is represented as a combination of the step of the diatonic scale, the chromatic alteration, and the octave.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pitch/}
 */
var Pitch = /** @class */ (function () {
    function Pitch(opts) {
        var _a;
        this.schema = Pitch.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Pitch.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Pitch.schema.contents);
    }
    /** Gets @type {Step}. */
    Pitch.prototype.getStep = function () {
        return this.contents[0];
    };
    /** Sets @type {Step}. */
    Pitch.prototype.setStep = function (step) {
        this.contents[0] = step;
        return this;
    };
    /** Gets @type {Alter | null}. */
    Pitch.prototype.getAlter = function () {
        return this.contents[1];
    };
    /** Sets @type {Alter | null}. */
    Pitch.prototype.setAlter = function (alter) {
        this.contents[1] = alter;
        return this;
    };
    /** Gets @type {Octave}. */
    Pitch.prototype.getOctave = function () {
        return this.contents[2];
    };
    /** Sets @type {Octave}. */
    Pitch.prototype.setOctave = function (octave) {
        this.contents[2] = octave;
        return this;
    };
    Pitch.schema = {
        name: 'pitch',
        attributes: {},
        contents: [
            { type: 'required', value: Step },
            { type: 'optional', value: Alter },
            { type: 'required', value: Octave },
        ],
    };
    return Pitch;
}());
exports.Pitch = Pitch;
/**
 * The `<display-step>` element
 *
 * Parent elements: `<rest>`, `<unpitched>`
 *
 * The `<display-step>` and `<display-octave>` elements are used to place `<rest>` and `<unpitched>` elements on the
 * staff without implying that these elements have pitch. Positioning follows the current clef. If percussion clef is
 * used, the `<display-step>` and `<display-octave>` elements are interpreted as if in treble clef, with a G in octave
 * 4 on line 2.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/display-step/}
 */
var DisplayStep = /** @class */ (function () {
    function DisplayStep(opts) {
        var _a;
        this.schema = DisplayStep.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DisplayStep.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DisplayStep.schema.contents);
    }
    /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    DisplayStep.prototype.getStep = function () {
        return this.contents[0];
    };
    /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    DisplayStep.prototype.setStep = function (step) {
        this.contents[0] = step;
        return this;
    };
    DisplayStep.schema = {
        name: 'display-step',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'step',
                    value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
                },
            },
        ],
    };
    return DisplayStep;
}());
exports.DisplayStep = DisplayStep;
/**
 * The `<display-octave>` element
 *
 * Parent elements: `<rest>`, `<unpitched>`
 *
 * The `<display-step>` and `<display-octave>` elements are used to place `<rest>` and `<unpitched>` elements on the
 * staff without implying that these elements have pitch. Positioning follows the current clef. If percussion clef is
 * used, the `<display-step>` and `<display-octave>` elements are interpreted as if in treble clef, with a G in octave
 * 4 on line 2.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/display-octave/}
 */
var DisplayOctave = /** @class */ (function () {
    function DisplayOctave(opts) {
        var _a;
        this.schema = DisplayOctave.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DisplayOctave.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DisplayOctave.schema.contents);
    }
    /** Gets @type {number}. */
    DisplayOctave.prototype.getOctave = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    DisplayOctave.prototype.setOctave = function (octave) {
        this.contents[0] = octave;
        return this;
    };
    DisplayOctave.schema = {
        name: 'display-octave',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
    };
    return DisplayOctave;
}());
exports.DisplayOctave = DisplayOctave;
/**
 * The `<unpitched>` element
 *
 * Parent element: `<note>`
 *
 * The `<unpitched>` element represents notes that are notated on the staff but lack definite pitch, such as unpitched
 * percussion and speaking voice. If the child elements are not present, the note is placed on the middle line of the
 * staff. This is generally used with a one-line staff. Notes in percussion clef should always use an `<unpitched>`
 * element rather than a `<pitch>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/unpitched/}
 */
var Unpitched = /** @class */ (function () {
    function Unpitched(opts) {
        var _a;
        this.schema = Unpitched.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Unpitched.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Unpitched.schema.contents);
    }
    /** Gets @type {DisplayStep}. */
    Unpitched.prototype.getDisplayStep = function () {
        return this.contents[0];
    };
    /** Sets @type {DisplayStep}. */
    Unpitched.prototype.setDisplayStep = function (displayStep) {
        this.contents[0] = displayStep;
        return this;
    };
    /** Gets @type {DisplayOctave}. */
    Unpitched.prototype.getDisplayOctave = function () {
        return this.contents[1];
    };
    /** Sets @type {DisplayOctave}. */
    Unpitched.prototype.setDisplayOctave = function (displayOctave) {
        this.contents[1] = displayOctave;
        return this;
    };
    Unpitched.schema = {
        name: 'unpitched',
        attributes: {},
        contents: [
            { type: 'required', value: DisplayStep },
            { type: 'required', value: DisplayOctave },
        ],
    };
    return Unpitched;
}());
exports.Unpitched = Unpitched;
/**
 * The `<rest>` element
 *
 * Parent element: `<note>
 *
 * The `<rest> element indicates notated rests or silences. A `<rest> element is usually empty, but placement on the
 * staff can be specified using `<display-step>` and `<display-octave>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/rest/}
 */
var Rest = /** @class */ (function () {
    function Rest(opts) {
        var _a;
        this.schema = Rest.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Rest.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Rest.schema.contents);
    }
    /** Gets @type {RestAttributes['measure']}. */
    Rest.prototype.getMeasure = function () {
        return this.attributes['measure'];
    };
    /** Sets @type {RestAttributes['measure']}. */
    Rest.prototype.setMeasure = function (measure) {
        this.attributes['measure'] = measure;
        return this;
    };
    /** Gets @type {[DisplayStep, DisplayOctave] | null}. */
    Rest.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {[DisplayStep, DisplayOctave] | null}. */
    Rest.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Rest.schema = {
        name: 'rest',
        attributes: { measure: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
        contents: [
            {
                type: 'optional',
                value: {
                    type: 'label',
                    label: 'value',
                    value: [
                        { type: 'required', value: DisplayStep },
                        { type: 'required', value: DisplayOctave },
                    ],
                },
            },
        ],
    };
    return Rest;
}());
exports.Rest = Rest;
/**
 * The `<duration>` element
 *
 * Parent elements: `<backup>`, `<figured-bass>`, `<forward>`, `<note>`
 *
 * Duration is a positive number specified in division units. The `<duration>` element represents the intended duration
 * vs. the notated duration (for instance, differences in dotted notes in Baroque-era music). Differences in duration
 * specific to an interpretation or performance should be represented using the `<note>` element's attack and release
 * attributes.
 *
 * The `<duration>` element moves the musical position when used in `<backup>` elements, `<forward>` elements, and
 * `<note>` elements that do not contain a `<chord>` child element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/duration/}
 */
var Duration = /** @class */ (function () {
    function Duration(opts) {
        var _a;
        this.schema = Duration.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Duration.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Duration.schema.contents);
    }
    /** Gets @type {number}. */
    Duration.prototype.getPositiveDivisions = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Duration.prototype.setPositiveDivisions = function (positiveDivisions) {
        this.contents[0] = positiveDivisions;
        return this;
    };
    Duration.schema = {
        name: 'duration',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'positive-divisions', value: { type: 'float', min: 1, max: Infinity } },
            },
        ],
    };
    return Duration;
}());
exports.Duration = Duration;
/**
 * The `<tie>` element
 *
 * Parent element: `<note>`
 *
 * The `<tie>` element indicates that a tie begins or ends with this note. The `<tie>` element indicates sound; the
 * `<tied>` element indicates notation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tie/}
 */
var Tie = /** @class */ (function () {
    function Tie(opts) {
        var _a;
        this.schema = Tie.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Tie.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Tie.schema.contents);
    }
    /** Gets @type {TieAttributes['type']}. */
    Tie.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {TieAttributes['type']}. */
    Tie.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {TieAttributes['time-only']}. */
    Tie.prototype.getTimeOnly = function () {
        return this.attributes['time-only'];
    };
    /** Sets @type {TieAttributes['time-only']}. */
    Tie.prototype.setTimeOnly = function (timeOnly) {
        this.attributes['time-only'] = timeOnly;
        return this;
    };
    Tie.schema = {
        name: 'tie',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
        },
        contents: [],
    };
    return Tie;
}());
exports.Tie = Tie;
/**
 * The `<cue>` element
 *
 * Parent element: `<note>`
 *
 * The `<cue>` element indicates the presence of a cue note. In MusicXML, a cue note is a silent note with no playback.
 * Normal notes that play can be specified as cue size using the `<type>` element. A cue note that is specified as full
 * size using the `<type>` element will still remain silent.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/cue/}
 */
var Cue = /** @class */ (function () {
    function Cue(opts) {
        var _a;
        this.schema = Cue.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Cue.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Cue.schema.contents);
    }
    Cue.schema = { name: 'cue', attributes: {}, contents: [] };
    return Cue;
}());
exports.Cue = Cue;
/**
 * The `<grace>` element
 *
 * Parent element: `<note>`
 *
 * The `<grace>` element indicates the presence of a grace note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/grace/}
 */
var Grace = /** @class */ (function () {
    function Grace(opts) {
        var _a;
        this.schema = Grace.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Grace.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Grace.schema.contents);
    }
    /** Gets @type {GraceAttributes['make-time']}. */
    Grace.prototype.getMakeTime = function () {
        return this.attributes['make-time'];
    };
    /** Sets @type {GraceAttributes['make-time']}. */
    Grace.prototype.setMakeTime = function (makeTime) {
        this.attributes['make-time'] = makeTime;
        return this;
    };
    /** Gets @type {GraceAttributes['slash']}. */
    Grace.prototype.getSlash = function () {
        return this.attributes['slash'];
    };
    /** Sets @type {GraceAttributes['slash']}. */
    Grace.prototype.setSlash = function (slash) {
        this.attributes['slash'] = slash;
        return this;
    };
    /** Gets @type {GraceAttributes['steal-time-following']}. */
    Grace.prototype.getStealTimeFollowing = function () {
        return this.attributes['steal-time-following'];
    };
    /** Sets @type {GraceAttributes['steal-time-following']}. */
    Grace.prototype.setStealTimeFollowing = function (stealTimeFollowing) {
        this.attributes['steal-time-following'] = stealTimeFollowing;
        return this;
    };
    /** Gets @type {GraceAttributes['steal-time-previous']}. */
    Grace.prototype.getStealTimePrevious = function () {
        return this.attributes['steal-time-previous'];
    };
    /** Sets @type {GraceAttributes['steal-time-previous']}. */
    Grace.prototype.setStealTimePrevious = function (stealTimePrevious) {
        this.attributes['steal-time-previous'] = stealTimePrevious;
        return this;
    };
    Grace.schema = {
        name: 'grace',
        attributes: {
            'make-time': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'steal-time-following': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'steal-time-previous': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
        },
        contents: [],
    };
    return Grace;
}());
exports.Grace = Grace;
/**
 * The `<instrument>` element
 *
 * Parent element: `<note>`
 *
 * The `<instrument>` element distinguishes between `<score-instrument>` elements in a `<score-part>`. If multiple
 * `<score-instrument>` elements are specified in a `<score-part>`, there should be an `<instrument>` element for each
 * note in the `<part>`. Notes that are shared between multiple `<score-instrument>`s can have more than one
 * `<instrument>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument/}
 */
var Instrument = /** @class */ (function () {
    function Instrument(opts) {
        var _a;
        this.schema = Instrument.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Instrument.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Instrument.schema.contents);
    }
    /** Gets @type {InstrumentAttributes['id']}. */
    Instrument.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {InstrumentAttributes['id']}. */
    Instrument.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    Instrument.schema = {
        name: 'instrument',
        attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [],
    };
    return Instrument;
}());
exports.Instrument = Instrument;
/**
 * The `<voice>` element
 *
 * Parent elements: `<direction>`, `<forward>`, `<note>`
 *
 * A voice is a sequence of musical events (e.g. notes, chords, rests) that proceeds linearly in time. The `<voice>`
 * element is used to distinguish between multiple voices in individual parts.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/voice/}
 */
var Voice = /** @class */ (function () {
    function Voice(opts) {
        var _a;
        this.schema = Voice.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Voice.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Voice.schema.contents);
    }
    /** Gets @type {string}. */
    Voice.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Voice.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Voice.schema = {
        name: 'voice',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Voice;
}());
exports.Voice = Voice;
/**
 * The `<type>` element
 *
 * Parent element: `<note>`
 *
 * The `<type>` element indicates the graphic note type. Values range from 1024th to maxima.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/type/}
 */
var Type = /** @class */ (function () {
    function Type(opts) {
        var _a;
        this.schema = Type.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Type.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Type.schema.contents);
    }
    /** Gets @type {TypeAttributes['size']}. */
    Type.prototype.getSize = function () {
        return this.attributes['size'];
    };
    /** Sets @type {TypeAttributes['size']}. */
    Type.prototype.setSize = function (size) {
        this.attributes['size'] = size;
        return this;
    };
    /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    Type.prototype.getNoteTypeValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    Type.prototype.setNoteTypeValue = function (noteTypeValue) {
        this.contents[0] = noteTypeValue;
        return this;
    };
    Type.schema = {
        name: 'type',
        attributes: {
            size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'note-type-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'whole',
                            '1024th',
                            '512th',
                            '256th',
                            '128th',
                            '64th',
                            '32nd',
                            '16th',
                            'eighth',
                            'half',
                            'quarter',
                            'whole',
                            'breve',
                            'long',
                            'maxima',
                        ],
                    },
                },
            },
        ],
    };
    return Type;
}());
exports.Type = Type;
/**
 * The `<dot>` element
 *
 * Parent element: `<note>`
 *
 * One `<dot>` element is used for each dot of prolongation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/dot/}
 */
var Dot = /** @class */ (function () {
    function Dot(opts) {
        var _a;
        this.schema = Dot.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Dot.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Dot.schema.contents);
    }
    /** Gets @type {DotAttributes['color']}. */
    Dot.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DotAttributes['color']}. */
    Dot.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DotAttributes['default-x']}. */
    Dot.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DotAttributes['default-x']}. */
    Dot.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DotAttributes['default-y']}. */
    Dot.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DotAttributes['default-y']}. */
    Dot.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DotAttributes['font-family']}. */
    Dot.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DotAttributes['font-family']}. */
    Dot.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DotAttributes['font-size']}. */
    Dot.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DotAttributes['font-size']}. */
    Dot.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DotAttributes['font-style']}. */
    Dot.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DotAttributes['font-style']}. */
    Dot.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DotAttributes['font-weight']}. */
    Dot.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DotAttributes['font-weight']}. */
    Dot.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DotAttributes['placement']}. */
    Dot.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {DotAttributes['placement']}. */
    Dot.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {DotAttributes['relative-x']}. */
    Dot.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DotAttributes['relative-x']}. */
    Dot.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DotAttributes['relative-y']}. */
    Dot.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DotAttributes['relative-y']}. */
    Dot.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Dot.schema = {
        name: 'dot',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Dot;
}());
exports.Dot = Dot;
/**
 * The `<accidental>` element
 *
 * Parent element: `<note>`
 *
 * The `<accidental>` element represents actual notated accidentals.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accidental/}
 */
var Accidental = /** @class */ (function () {
    function Accidental(opts) {
        var _a;
        this.schema = Accidental.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Accidental.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Accidental.schema.contents);
    }
    /** Gets @type {AccidentalAttributes['bracket']}. */
    Accidental.prototype.getBracket = function () {
        return this.attributes['bracket'];
    };
    /** Sets @type {AccidentalAttributes['bracket']}. */
    Accidental.prototype.setBracket = function (bracket) {
        this.attributes['bracket'] = bracket;
        return this;
    };
    /** Gets @type {AccidentalAttributes['cautionary']}. */
    Accidental.prototype.getCautionary = function () {
        return this.attributes['cautionary'];
    };
    /** Sets @type {AccidentalAttributes['cautionary']}. */
    Accidental.prototype.setCautionary = function (cautionary) {
        this.attributes['cautionary'] = cautionary;
        return this;
    };
    /** Gets @type {AccidentalAttributes['color']}. */
    Accidental.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {AccidentalAttributes['color']}. */
    Accidental.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {AccidentalAttributes['default-x']}. */
    Accidental.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {AccidentalAttributes['default-x']}. */
    Accidental.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {AccidentalAttributes['default-y']}. */
    Accidental.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {AccidentalAttributes['default-y']}. */
    Accidental.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {AccidentalAttributes['editorial']}. */
    Accidental.prototype.getEditorial = function () {
        return this.attributes['editorial'];
    };
    /** Sets @type {AccidentalAttributes['editorial']}. */
    Accidental.prototype.setEditorial = function (editorial) {
        this.attributes['editorial'] = editorial;
        return this;
    };
    /** Gets @type {AccidentalAttributes['font-family']}. */
    Accidental.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {AccidentalAttributes['font-family']}. */
    Accidental.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {AccidentalAttributes['font-size']}. */
    Accidental.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {AccidentalAttributes['font-size']}. */
    Accidental.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {AccidentalAttributes['font-style']}. */
    Accidental.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {AccidentalAttributes['font-style']}. */
    Accidental.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {AccidentalAttributes['font-weight']}. */
    Accidental.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {AccidentalAttributes['font-weight']}. */
    Accidental.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {AccidentalAttributes['parentheses']}. */
    Accidental.prototype.getParentheses = function () {
        return this.attributes['parentheses'];
    };
    /** Sets @type {AccidentalAttributes['parentheses']}. */
    Accidental.prototype.setParentheses = function (parentheses) {
        this.attributes['parentheses'] = parentheses;
        return this;
    };
    /** Gets @type {AccidentalAttributes['relative-x']}. */
    Accidental.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {AccidentalAttributes['relative-x']}. */
    Accidental.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {AccidentalAttributes['relative-y']}. */
    Accidental.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {AccidentalAttributes['relative-y']}. */
    Accidental.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {AccidentalAttributes['size']}. */
    Accidental.prototype.getSize = function () {
        return this.attributes['size'];
    };
    /** Sets @type {AccidentalAttributes['size']}. */
    Accidental.prototype.setSize = function (size) {
        this.attributes['size'] = size;
        return this;
    };
    /** Gets @type {AccidentalAttributes['smufl']}. */
    Accidental.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {AccidentalAttributes['smufl']}. */
    Accidental.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
    Accidental.prototype.getAccidentalValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
    Accidental.prototype.setAccidentalValue = function (accidentalValue) {
        this.contents[0] = accidentalValue;
        return this;
    };
    Accidental.schema = {
        name: 'accidental',
        attributes: {
            bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            cautionary: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            editorial: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
            smufl: {
                type: 'optional',
                value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
            },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'accidental-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'other',
                            'sharp',
                            'natural',
                            'flat',
                            'double-sharp',
                            'sharp-sharp',
                            'flat-flat',
                            'natural-sharp',
                            'natural-flat',
                            'quarter-flat',
                            'quarter-sharp',
                            'three-quarters-flat',
                            'three-quarters-sharp',
                            'sharp-down',
                            'sharp-up',
                            'natural-down',
                            'natural-up',
                            'flat-down',
                            'flat-up',
                            'double-sharp-down',
                            'double-sharp-up',
                            'flat-flat-down',
                            'flat-flat-up',
                            'arrow-down',
                            'arrow-up',
                            'triple-sharp',
                            'triple-flat',
                            'slash-quarter-sharp',
                            'slash-sharp',
                            'slash-flat',
                            'double-slash-flat',
                            'sharp-1',
                            'sharp-2',
                            'sharp-3',
                            'sharp-5',
                            'flat-1',
                            'flat-2',
                            'flat-3',
                            'flat-4',
                            'sori',
                            'koron',
                        ],
                    },
                },
            },
        ],
    };
    return Accidental;
}());
exports.Accidental = Accidental;
/**
 * The `<actual-notes>` element
 *
 * Parent element: `<time-modification>`
 *
 * The `<actual-notes>` element describes how many notes are played in the time usually occupied by the number in the
 * `<normal-notes>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/actual-notes/}
 */
var ActualNotes = /** @class */ (function () {
    function ActualNotes(opts) {
        var _a;
        this.schema = ActualNotes.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ActualNotes.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ActualNotes.schema.contents);
    }
    /** Gets @type {number}. */
    ActualNotes.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    ActualNotes.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    ActualNotes.schema = {
        name: 'actual-notes',
        attributes: {},
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
        ],
    };
    return ActualNotes;
}());
exports.ActualNotes = ActualNotes;
/**
 * The `<normal-notes>` element
 *
 * Parent element: `<time-modification>`
 *
 * The `<normal-notes>` element describes how many notes are usually played in the time occupied by the number in the
 * `<actual-notes>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/normal-notes/}
 */
var NormalNotes = /** @class */ (function () {
    function NormalNotes(opts) {
        var _a;
        this.schema = NormalNotes.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NormalNotes.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NormalNotes.schema.contents);
    }
    /** Gets @type {number}. */
    NormalNotes.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    NormalNotes.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    NormalNotes.schema = {
        name: 'normal-notes',
        attributes: {},
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
        ],
    };
    return NormalNotes;
}());
exports.NormalNotes = NormalNotes;
/**
 * The `<normal-type>` element
 *
 * Parent element: `<time-modification>`
 *
 * If the type associated with the number in the `<normal-notes>` element is different than the current note type
 * (e.g., a quarter note within an eighth note triplet), then the `<normal-notes>` type (e.g. eighth) is specified in
 * the `<normal-type>` and `<normal-dot>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/normal-type/}
 */
var NormalType = /** @class */ (function () {
    function NormalType(opts) {
        var _a;
        this.schema = NormalType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NormalType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NormalType.schema.contents);
    }
    /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    NormalType.prototype.getNoteTypeValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    NormalType.prototype.setNoteTypeValue = function (noteTypeValue) {
        this.contents[0] = noteTypeValue;
        return this;
    };
    NormalType.schema = {
        name: 'normal-type',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'note-type-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'whole',
                            '1024th',
                            '512th',
                            '256th',
                            '128th',
                            '64th',
                            '32nd',
                            '16th',
                            'eighth',
                            'half',
                            'quarter',
                            'whole',
                            'breve',
                            'long',
                            'maxima',
                        ],
                    },
                },
            },
        ],
    };
    return NormalType;
}());
exports.NormalType = NormalType;
/**
 * The `<normal-dot>` element
 *
 * Parent element: `<time-modification>`
 *
 * The `<normal-dot>` element is used to specify dotted normal tuplet types.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/normal-dot/}
 */
var NormalDot = /** @class */ (function () {
    function NormalDot(opts) {
        var _a;
        this.schema = NormalDot.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NormalDot.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NormalDot.schema.contents);
    }
    NormalDot.schema = { name: 'normal-dot', attributes: {}, contents: [] };
    return NormalDot;
}());
exports.NormalDot = NormalDot;
/**
 * The `<time-modification>` element
 *
 * Parent element: `<note>`
 *
 * Time modification indicates tuplets, double-note tremolos, and other durational changes. A `<time-modification>`
 * element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note
 * type represented by the `<type>` and `<dot>` elements. Nested tuplets and other notations that use more detailed
 * information need both the `<time-modification>` and `<tuplet>` elements to be represented accurately.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/time-modification/}
 */
var TimeModification = /** @class */ (function () {
    function TimeModification(opts) {
        var _a;
        this.schema = TimeModification.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TimeModification.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TimeModification.schema.contents);
    }
    /** Gets @type {ActualNotes}. */
    TimeModification.prototype.getActualNotes = function () {
        return this.contents[0];
    };
    /** Sets @type {ActualNotes}. */
    TimeModification.prototype.setActualNotes = function (actualNotes) {
        this.contents[0] = actualNotes;
        return this;
    };
    /** Gets @type {NormalNotes}. */
    TimeModification.prototype.getNormalNotes = function () {
        return this.contents[1];
    };
    /** Sets @type {NormalNotes}. */
    TimeModification.prototype.setNormalNotes = function (normalNotes) {
        this.contents[1] = normalNotes;
        return this;
    };
    /** Gets @type {[NormalType, Array<NormalDot>] | null}. */
    TimeModification.prototype.getNormal = function () {
        return this.contents[2];
    };
    /** Sets @type {[NormalType, Array<NormalDot>] | null}. */
    TimeModification.prototype.setNormal = function (normal) {
        this.contents[2] = normal;
        return this;
    };
    TimeModification.schema = {
        name: 'time-modification',
        attributes: {},
        contents: [
            { type: 'required', value: ActualNotes },
            { type: 'required', value: NormalNotes },
            {
                type: 'label',
                label: 'normal',
                value: {
                    type: 'optional',
                    value: [
                        { type: 'required', value: NormalType },
                        { type: 'zeroOrMore', value: NormalDot },
                    ],
                },
            },
        ],
    };
    return TimeModification;
}());
exports.TimeModification = TimeModification;
/**
 * The `<stem>` element
 *
 * Parent element: `<note>`
 *
 * Values for the `<stem>` element can be down, up, none, or double. A `<stem>` element associated with a `<rest>`
 * refers to a stemlet.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stem/}
 */
var Stem = /** @class */ (function () {
    function Stem(opts) {
        var _a;
        this.schema = Stem.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Stem.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Stem.schema.contents);
    }
    /** Gets @type {StemAttributes['color']}. */
    Stem.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {StemAttributes['color']}. */
    Stem.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {StemAttributes['default-x']}. */
    Stem.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {StemAttributes['default-x']}. */
    Stem.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {StemAttributes['default-y']}. */
    Stem.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {StemAttributes['default-y']}. */
    Stem.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {StemAttributes['relative-x']}. */
    Stem.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {StemAttributes['relative-x']}. */
    Stem.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {StemAttributes['relative-y']}. */
    Stem.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {StemAttributes['relative-y']}. */
    Stem.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {'none' | 'down' | 'up' | 'double'}. */
    Stem.prototype.getStemValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'none' | 'down' | 'up' | 'double'}. */
    Stem.prototype.setStemValue = function (stemValue) {
        this.contents[0] = stemValue;
        return this;
    };
    Stem.schema = {
        name: 'stem',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [
            { type: 'label', label: 'stem-value', value: { type: 'choices', choices: ['none', 'down', 'up', 'double'] } },
        ],
    };
    return Stem;
}());
exports.Stem = Stem;
/**
 * The `<notehead>` element
 *
 * Parent element: `<note>`
 *
 * The `<notehead>` element indicates shapes other than the open and closed ovals associated with note durations.
 *
 * The smufl attribute can be used to specify a particular notehead, allowing application interoperability without
 * requiring every Standard Music Font Layout (SMuFL) glyph to have a MusicXML element equivalent. This attribute can be
 * used either with the other value, or to refine a specific notehead value such as cluster.
 *
 * Noteheads in the SMuFL Note name noteheads and Note name noteheads supplement ranges
 * (U+E150–U+E1AF and U+EEE0–U+EEFF) should not use the smufl attribute or the other value, but instead use the
 * `<notehead-text>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/notehead/}
 */
var Notehead = /** @class */ (function () {
    function Notehead(opts) {
        var _a;
        this.schema = Notehead.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Notehead.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Notehead.schema.contents);
    }
    /** Gets @type {NoteheadAttributes['color']}. */
    Notehead.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {NoteheadAttributes['color']}. */
    Notehead.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {NoteheadAttributes['filled']}. */
    Notehead.prototype.getFilled = function () {
        return this.attributes['filled'];
    };
    /** Sets @type {NoteheadAttributes['filled']}. */
    Notehead.prototype.setFilled = function (filled) {
        this.attributes['filled'] = filled;
        return this;
    };
    /** Gets @type {NoteheadAttributes['font-family']}. */
    Notehead.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {NoteheadAttributes['font-family']}. */
    Notehead.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {NoteheadAttributes['font-size']}. */
    Notehead.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {NoteheadAttributes['font-size']}. */
    Notehead.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {NoteheadAttributes['font-style']}. */
    Notehead.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {NoteheadAttributes['font-style']}. */
    Notehead.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {NoteheadAttributes['font-weight']}. */
    Notehead.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {NoteheadAttributes['font-weight']}. */
    Notehead.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {NoteheadAttributes['parentheses']}. */
    Notehead.prototype.getParentheses = function () {
        return this.attributes['parentheses'];
    };
    /** Sets @type {NoteheadAttributes['parentheses']}. */
    Notehead.prototype.setParentheses = function (parentheses) {
        this.attributes['parentheses'] = parentheses;
        return this;
    };
    /** Gets @type {NoteheadAttributes['smufl']}. */
    Notehead.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {NoteheadAttributes['smufl']}. */
    Notehead.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {'other' | 'arrow down' | 'arrow up' | 'back slashed' | 'circle dot' | 'circle-x' | 'circled' | 'cluster' | 'cross' | 'diamond' | 'do' | 'fa' | 'fa up' | 'inverted triangle' | 'la' | 'left triangle' | 'mi' | 'none' | 'normal' | 're' | 'rectangle' | 'slash' | 'slashed' | 'so' | 'square' | 'ti' | 'triangle' | 'x'}. */
    Notehead.prototype.getNoteheadValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'other' | 'arrow down' | 'arrow up' | 'back slashed' | 'circle dot' | 'circle-x' | 'circled' | 'cluster' | 'cross' | 'diamond' | 'do' | 'fa' | 'fa up' | 'inverted triangle' | 'la' | 'left triangle' | 'mi' | 'none' | 'normal' | 're' | 'rectangle' | 'slash' | 'slashed' | 'so' | 'square' | 'ti' | 'triangle' | 'x'}. */
    Notehead.prototype.setNoteheadValue = function (noteheadValue) {
        this.contents[0] = noteheadValue;
        return this;
    };
    Notehead.schema = {
        name: 'notehead',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            filled: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            smufl: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'notehead-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'other',
                            'arrow down',
                            'arrow up',
                            'back slashed',
                            'circle dot',
                            'circle-x',
                            'circled',
                            'cluster',
                            'cross',
                            'diamond',
                            'do',
                            'fa',
                            'fa up',
                            'inverted triangle',
                            'la',
                            'left triangle',
                            'mi',
                            'none',
                            'normal',
                            're',
                            'rectangle',
                            'slash',
                            'slashed',
                            'so',
                            'square',
                            'ti',
                            'triangle',
                            'x',
                        ],
                    },
                },
            },
        ],
    };
    return Notehead;
}());
exports.Notehead = Notehead;
/**
 * The `<notehead-text>` element
 *
 * Parent element: `<note>`
 *
 * The `<notehead-text>` element represents text that is displayed inside a notehead, as is done in some educational
 * music. It is not needed for the numbers used in tablature or jianpu notation. The presence of a TAB or jianpu clefs\
 * is sufficient to indicate that numbers are used. The `<display-text>` and `<accidental-text>` elements allow display
 * of fully formatted text and accidentals.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/notehead-text/}
 */
var NoteheadText = /** @class */ (function () {
    function NoteheadText(opts) {
        var _a;
        this.schema = NoteheadText.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NoteheadText.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NoteheadText.schema.contents);
    }
    /** Gets @type {Array<[DisplayText, AccidentalText]>}. */
    NoteheadText.prototype.getTexts = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<[DisplayText, AccidentalText]>}. */
    NoteheadText.prototype.setTexts = function (texts) {
        this.contents[0] = texts;
        return this;
    };
    NoteheadText.schema = {
        name: 'notehead-text',
        attributes: {},
        contents: [{ type: 'label', label: 'texts', value: { type: 'oneOrMore', value: [DisplayText, AccidentalText] } }],
    };
    return NoteheadText;
}());
exports.NoteheadText = NoteheadText;
/**
 * The `<staff>` element
 *
 * Parent elements: `<direction>`, `<forward>`, `<harmony>`, `<note>`
 *
 * Staff assignment is only needed for music notated on multiple staves. Staff values are numbers, with 1 referring to
 * the top-most staff in a part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff/}
 */
var Staff = /** @class */ (function () {
    function Staff(opts) {
        var _a;
        this.schema = Staff.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Staff.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Staff.schema.contents);
    }
    /** Gets @type {number}. */
    Staff.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Staff.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Staff.schema = {
        name: 'staff',
        attributes: {},
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
        ],
    };
    return Staff;
}());
exports.Staff = Staff;
/**
 * The `<beam>` element
 *
 * Parent element: `<note>`
 *
 * Beam values include begin, continue, end, forward hook, and backward hook. Each beam in a note is represented with a
 * separate `<beam>` element with a different number attribute, starting with the eighth note beam using a value of 1.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beam/}
 */
var Beam = /** @class */ (function () {
    function Beam(opts) {
        var _a;
        this.schema = Beam.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Beam.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Beam.schema.contents);
    }
    /** Gets @type {BeamAttributes['color']}. */
    Beam.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {BeamAttributes['color']}. */
    Beam.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {BeamAttributes['fan']}. */
    Beam.prototype.getFan = function () {
        return this.attributes['fan'];
    };
    /** Sets @type {BeamAttributes['fan']}. */
    Beam.prototype.setFan = function (fan) {
        this.attributes['fan'] = fan;
        return this;
    };
    /** Gets @type {BeamAttributes['id']}. */
    Beam.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {BeamAttributes['id']}. */
    Beam.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {BeamAttributes['number']}. */
    Beam.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {BeamAttributes['number']}. */
    Beam.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {BeamAttributes['repeater']}. */
    Beam.prototype.getRepeater = function () {
        return this.attributes['repeater'];
    };
    /** Sets @type {BeamAttributes['repeater']}. */
    Beam.prototype.setRepeater = function (repeater) {
        this.attributes['repeater'] = repeater;
        return this;
    };
    /** Gets @type {'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'}. */
    Beam.prototype.getBeamValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'}. */
    Beam.prototype.setBeamValue = function (beamValue) {
        this.contents[0] = beamValue;
        return this;
    };
    Beam.schema = {
        name: 'beam',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            fan: { type: 'optional', value: { type: 'choices', choices: ['accel', 'none', 'rit'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 8 } },
            repeater: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'beam-value',
                    value: { type: 'choices', choices: ['backward hook', 'begin', 'continue', 'end', 'forward hook'] },
                },
            },
        ],
    };
    return Beam;
}());
exports.Beam = Beam;
/**
 * The `<tied>` element
 *
 * Parent element: `<notations>`
 *
 * The `<tied>` element represents the notated tie. The `<tie>` element represents the tie sound.
 *
 * Ties that join two notes of the same pitch together should be represented with a `<tied>` element on the first note
 * with type="start" and a `<tied>` element on the second note with type="stop". This can also be done if the two notes
 * being tied are enharmonically equivalent, but have different step values. It is not recommended to use `<tied>`
 * elements to join two notes with enharmonically inequivalent pitches.
 *
 * Ties that indicate that an instrument should be undamped are specified with a single `<tied>`
 * element with type="let-ring".
 *
 * Ties that are visually attached to only one note, other than undamped ties, should be specified with two `<tied>`
 * elements on the same note, first type="start" then type="stop". This can be used to represent ties into or out of
 * repeated sections or codas.
 *
 * When multiple `<tied>` elements with the same tag are used within the same note, their order within the MusicXML
 * document should match the musical score order. For example, a note with a tie at the end of a first ending should
 * have the `<tied>` element with a type of start precede the `<tied>` element with a type of stop.
 *
 * Normal ties need only two bezier points: one associated with the start of the tie, the other with the stop. Ties
 * divided over system breaks can specify additional bezier data at `<tied>` elements with a continue type.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tied/}
 */
var Tied = /** @class */ (function () {
    function Tied(opts) {
        var _a;
        this.schema = Tied.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Tied.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Tied.schema.contents);
    }
    /** Gets @type {TiedAttributes['type']}. */
    Tied.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {TiedAttributes['type']}. */
    Tied.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {TiedAttributes['bezier-x']}. */
    Tied.prototype.getBezierX = function () {
        return this.attributes['bezier-x'];
    };
    /** Sets @type {TiedAttributes['bezier-x']}. */
    Tied.prototype.setBezierX = function (bezierX) {
        this.attributes['bezier-x'] = bezierX;
        return this;
    };
    /** Gets @type {TiedAttributes['bezier-x2']}. */
    Tied.prototype.getBezierX2 = function () {
        return this.attributes['bezier-x2'];
    };
    /** Sets @type {TiedAttributes['bezier-x2']}. */
    Tied.prototype.setBezierX2 = function (bezierX2) {
        this.attributes['bezier-x2'] = bezierX2;
        return this;
    };
    /** Gets @type {TiedAttributes['bezier-y']}. */
    Tied.prototype.getBezierY = function () {
        return this.attributes['bezier-y'];
    };
    /** Sets @type {TiedAttributes['bezier-y']}. */
    Tied.prototype.setBezierY = function (bezierY) {
        this.attributes['bezier-y'] = bezierY;
        return this;
    };
    /** Gets @type {TiedAttributes['bezier-y2']}. */
    Tied.prototype.getBezierY2 = function () {
        return this.attributes['bezier-y2'];
    };
    /** Sets @type {TiedAttributes['bezier-y2']}. */
    Tied.prototype.setBezierY2 = function (bezierY2) {
        this.attributes['bezier-y2'] = bezierY2;
        return this;
    };
    /** Gets @type {TiedAttributes['color']}. */
    Tied.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TiedAttributes['color']}. */
    Tied.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TiedAttributes['dash-length']}. */
    Tied.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {TiedAttributes['dash-length']}. */
    Tied.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {TiedAttributes['default-x']}. */
    Tied.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {TiedAttributes['default-x']}. */
    Tied.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {TiedAttributes['default-y']}. */
    Tied.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {TiedAttributes['default-y']}. */
    Tied.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {TiedAttributes['id']}. */
    Tied.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {TiedAttributes['id']}. */
    Tied.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {TiedAttributes['line-type']}. */
    Tied.prototype.getLineType = function () {
        return this.attributes['line-type'];
    };
    /** Sets @type {TiedAttributes['line-type']}. */
    Tied.prototype.setLineType = function (lineType) {
        this.attributes['line-type'] = lineType;
        return this;
    };
    /** Gets @type {TiedAttributes['number']}. */
    Tied.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {TiedAttributes['number']}. */
    Tied.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {TiedAttributes['orientation']}. */
    Tied.prototype.getOrientation = function () {
        return this.attributes['orientation'];
    };
    /** Sets @type {TiedAttributes['orientation']}. */
    Tied.prototype.setOrientation = function (orientation) {
        this.attributes['orientation'] = orientation;
        return this;
    };
    /** Gets @type {TiedAttributes['placement']}. */
    Tied.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {TiedAttributes['placement']}. */
    Tied.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {TiedAttributes['relative-x']}. */
    Tied.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {TiedAttributes['relative-x']}. */
    Tied.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {TiedAttributes['relative-y']}. */
    Tied.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {TiedAttributes['relative-y']}. */
    Tied.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {TiedAttributes['space-length']}. */
    Tied.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {TiedAttributes['space-length']}. */
    Tied.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    Tied.schema = {
        name: 'tied',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue', 'let-ring'] } },
            'bezier-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'bezier-x2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'bezier-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'bezier-y2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            orientation: { type: 'optional', value: { type: 'choices', choices: ['over', 'under'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return Tied;
}());
exports.Tied = Tied;
/**
 * The `<slur>` element
 *
 * Parent element: `<notations>`
 *
 * Most slurs are represented with two `<slur>` elements: one with a start type, and one with a stop type. Slurs can add
 * more elements using a continue type. This is typically used to specify the formatting of cross-system slurs, or to
 * specify the shape of very complex slurs.
 *
 * Normal slurs and S-shaped slurs need only two bezier points: one associated with the start of the slur, the other
 * with the stop. Complex slurs and slurs divided over system breaks can specify additional bezier data at `<slur>`
 * elements with a continue type.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/slur/}
 */
var Slur = /** @class */ (function () {
    function Slur(opts) {
        var _a;
        this.schema = Slur.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Slur.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Slur.schema.contents);
    }
    /** Gets @type {SlurAttributes['type']}. */
    Slur.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {SlurAttributes['type']}. */
    Slur.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {SlurAttributes['bezier-x']}. */
    Slur.prototype.getBezierX = function () {
        return this.attributes['bezier-x'];
    };
    /** Sets @type {SlurAttributes['bezier-x']}. */
    Slur.prototype.setBezierX = function (bezierX) {
        this.attributes['bezier-x'] = bezierX;
        return this;
    };
    /** Gets @type {SlurAttributes['bezier-x2']}. */
    Slur.prototype.getBezierX2 = function () {
        return this.attributes['bezier-x2'];
    };
    /** Sets @type {SlurAttributes['bezier-x2']}. */
    Slur.prototype.setBezierX2 = function (bezierX2) {
        this.attributes['bezier-x2'] = bezierX2;
        return this;
    };
    /** Gets @type {SlurAttributes['bezier-y']}. */
    Slur.prototype.getBezierY = function () {
        return this.attributes['bezier-y'];
    };
    /** Sets @type {SlurAttributes['bezier-y']}. */
    Slur.prototype.setBezierY = function (bezierY) {
        this.attributes['bezier-y'] = bezierY;
        return this;
    };
    /** Gets @type {SlurAttributes['bezier-y2']}. */
    Slur.prototype.getBezierY2 = function () {
        return this.attributes['bezier-y2'];
    };
    /** Sets @type {SlurAttributes['bezier-y2']}. */
    Slur.prototype.setBezierY2 = function (bezierY2) {
        this.attributes['bezier-y2'] = bezierY2;
        return this;
    };
    /** Gets @type {SlurAttributes['color']}. */
    Slur.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {SlurAttributes['color']}. */
    Slur.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {SlurAttributes['dash-length']}. */
    Slur.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {SlurAttributes['dash-length']}. */
    Slur.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {SlurAttributes['default-x']}. */
    Slur.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {SlurAttributes['default-x']}. */
    Slur.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {SlurAttributes['default-y']}. */
    Slur.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {SlurAttributes['default-y']}. */
    Slur.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {SlurAttributes['id']}. */
    Slur.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {SlurAttributes['id']}. */
    Slur.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {SlurAttributes['line-type']}. */
    Slur.prototype.getLineType = function () {
        return this.attributes['line-type'];
    };
    /** Sets @type {SlurAttributes['line-type']}. */
    Slur.prototype.setLineType = function (lineType) {
        this.attributes['line-type'] = lineType;
        return this;
    };
    /** Gets @type {SlurAttributes['number']}. */
    Slur.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {SlurAttributes['number']}. */
    Slur.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {SlurAttributes['orientation']}. */
    Slur.prototype.getOrientation = function () {
        return this.attributes['orientation'];
    };
    /** Sets @type {SlurAttributes['orientation']}. */
    Slur.prototype.setOrientation = function (orientation) {
        this.attributes['orientation'] = orientation;
        return this;
    };
    /** Gets @type {SlurAttributes['placement']}. */
    Slur.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {SlurAttributes['placement']}. */
    Slur.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {SlurAttributes['relative-x']}. */
    Slur.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {SlurAttributes['relative-x']}. */
    Slur.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {SlurAttributes['relative-y']}. */
    Slur.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {SlurAttributes['relative-y']}. */
    Slur.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {SlurAttributes['space-length']}. */
    Slur.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {SlurAttributes['space-length']}. */
    Slur.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    Slur.schema = {
        name: 'slur',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
            'bezier-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'bezier-x2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'bezier-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'bezier-y2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            orientation: { type: 'optional', value: { type: 'choices', choices: ['over', 'under'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return Slur;
}());
exports.Slur = Slur;
/**
 * The `<tuplet-number>` element
 *
 * Parent elements: `<tuplet-actual>`, `<tuplet-normal>`
 *
 * The `<tuplet-number>` element indicates the number of notes for this portion of the tuplet.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet-number/}
 */
var TupletNumber = /** @class */ (function () {
    function TupletNumber(opts) {
        var _a;
        this.schema = TupletNumber.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TupletNumber.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TupletNumber.schema.contents);
    }
    /** Gets @type {TupletNumberAttributes['color']}. */
    TupletNumber.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TupletNumberAttributes['color']}. */
    TupletNumber.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TupletNumberAttributes['font-family']}. */
    TupletNumber.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TupletNumberAttributes['font-family']}. */
    TupletNumber.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TupletNumberAttributes['font-size']}. */
    TupletNumber.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TupletNumberAttributes['font-size']}. */
    TupletNumber.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TupletNumberAttributes['font-style']}. */
    TupletNumber.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TupletNumberAttributes['font-style']}. */
    TupletNumber.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TupletNumberAttributes['font-weight']}. */
    TupletNumber.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TupletNumberAttributes['font-weight']}. */
    TupletNumber.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {number}. */
    TupletNumber.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    TupletNumber.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    TupletNumber.schema = {
        name: 'tuplet-number',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
        },
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
        ],
    };
    return TupletNumber;
}());
exports.TupletNumber = TupletNumber;
/**
 * The `<tuplet-type>` element
 *
 * Parent elements: `<tuplet-actual>`, `<tuplet-normal>`
 *
 * The `<tuplet-type>` element indicates the graphical note type of the notes for this portion of the tuplet.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet-type/}
 */
var TupletType = /** @class */ (function () {
    function TupletType(opts) {
        var _a;
        this.schema = TupletType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TupletType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TupletType.schema.contents);
    }
    /** Gets @type {TupletTypeAttributes['color']}. */
    TupletType.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TupletTypeAttributes['color']}. */
    TupletType.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TupletTypeAttributes['font-family']}. */
    TupletType.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TupletTypeAttributes['font-family']}. */
    TupletType.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TupletTypeAttributes['font-size']}. */
    TupletType.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TupletTypeAttributes['font-size']}. */
    TupletType.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TupletTypeAttributes['font-style']}. */
    TupletType.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TupletTypeAttributes['font-style']}. */
    TupletType.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TupletTypeAttributes['font-weight']}. */
    TupletType.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TupletTypeAttributes['font-weight']}. */
    TupletType.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    TupletType.prototype.getNoteTypeValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    TupletType.prototype.setNoteTypeValue = function (noteTypeValue) {
        this.contents[0] = noteTypeValue;
        return this;
    };
    TupletType.schema = {
        name: 'tuplet-type',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
        },
        contents: [
            {
                type: 'label',
                label: 'note-type-value',
                value: {
                    type: 'choices',
                    choices: [
                        'whole',
                        '1024th',
                        '512th',
                        '256th',
                        '128th',
                        '64th',
                        '32nd',
                        '16th',
                        'eighth',
                        'half',
                        'quarter',
                        'whole',
                        'breve',
                        'long',
                        'maxima',
                    ],
                },
            },
        ],
    };
    return TupletType;
}());
exports.TupletType = TupletType;
/**
 * The `<tuplet-dot>` element
 *
 * Parent elements: `<tuplet-actual>`, `<tuplet-normal>`
 *
 * The `<tuplet-dot>` element is used to specify dotted tuplet types.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet-dot/}
 */
var TupletDot = /** @class */ (function () {
    function TupletDot(opts) {
        var _a;
        this.schema = TupletDot.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TupletDot.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TupletDot.schema.contents);
    }
    /** Gets @type {TupletDotAttributes['color']}. */
    TupletDot.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TupletDotAttributes['color']}. */
    TupletDot.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TupletDotAttributes['font-family']}. */
    TupletDot.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TupletDotAttributes['font-family']}. */
    TupletDot.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TupletDotAttributes['font-size']}. */
    TupletDot.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TupletDotAttributes['font-size']}. */
    TupletDot.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TupletDotAttributes['font-style']}. */
    TupletDot.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TupletDotAttributes['font-style']}. */
    TupletDot.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TupletDotAttributes['font-weight']}. */
    TupletDot.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TupletDotAttributes['font-weight']}. */
    TupletDot.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    TupletDot.schema = {
        name: 'tuplet-dot',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
        },
        contents: [],
    };
    return TupletDot;
}());
exports.TupletDot = TupletDot;
/**
 * The `<tuplet-actual>` element
 *
 * Parent element: `<tuplet>`
 *
 * The `<tuplet-actual>` element provide optional full control over how the actual part of the `<tuplet>` is displayed,
 * including number and note type (with dots). If any of these elements are absent, their values are based on the
 * `<time-modification>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet-actual/}
 */
var TupletActual = /** @class */ (function () {
    function TupletActual(opts) {
        var _a;
        this.schema = TupletActual.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TupletActual.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TupletActual.schema.contents);
    }
    /** Gets @type {TupletNumber | null}. */
    TupletActual.prototype.getTupletNumber = function () {
        return this.contents[0];
    };
    /** Sets @type {TupletNumber | null}. */
    TupletActual.prototype.setTupletNumber = function (tupletNumber) {
        this.contents[0] = tupletNumber;
        return this;
    };
    /** Gets @type {TupletType | null}. */
    TupletActual.prototype.getTupletType = function () {
        return this.contents[1];
    };
    /** Sets @type {TupletType | null}. */
    TupletActual.prototype.setTupletType = function (tupletType) {
        this.contents[1] = tupletType;
        return this;
    };
    /** Gets @type {Array<TupletDot>}. */
    TupletActual.prototype.getTupletDots = function () {
        return this.contents[2];
    };
    /** Sets @type {Array<TupletDot>}. */
    TupletActual.prototype.setTupletDots = function (tupletDots) {
        this.contents[2] = tupletDots;
        return this;
    };
    TupletActual.schema = {
        name: 'tuplet-actual',
        attributes: {},
        contents: [
            { type: 'optional', value: TupletNumber },
            { type: 'optional', value: TupletType },
            { type: 'label', label: 'tuplet-dots', value: { type: 'zeroOrMore', value: TupletDot } },
        ],
    };
    return TupletActual;
}());
exports.TupletActual = TupletActual;
/**
 * The `<tuplet-normal>` element
 *
 * Parent element: `<tuplet>`
 *
 * The `<tuplet-normal>` element provide optional full control over how the normal part of the `<tuplet>` is displayed,
 * including number and note type (with dots). If any of these elements are absent, their values are based on the
 * `<time-modification>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet-normal/}
 */
var TupletNormal = /** @class */ (function () {
    function TupletNormal(opts) {
        var _a;
        this.schema = TupletNormal.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TupletNormal.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TupletNormal.schema.contents);
    }
    /** Gets @type {TupletNumber | null}. */
    TupletNormal.prototype.getTupletNumber = function () {
        return this.contents[0];
    };
    /** Sets @type {TupletNumber | null}. */
    TupletNormal.prototype.setTupletNumber = function (tupletNumber) {
        this.contents[0] = tupletNumber;
        return this;
    };
    /** Gets @type {TupletType | null}. */
    TupletNormal.prototype.getTupletType = function () {
        return this.contents[1];
    };
    /** Sets @type {TupletType | null}. */
    TupletNormal.prototype.setTupletType = function (tupletType) {
        this.contents[1] = tupletType;
        return this;
    };
    /** Gets @type {Array<TupletDot>}. */
    TupletNormal.prototype.getTupletDots = function () {
        return this.contents[2];
    };
    /** Sets @type {Array<TupletDot>}. */
    TupletNormal.prototype.setTupletDots = function (tupletDots) {
        this.contents[2] = tupletDots;
        return this;
    };
    TupletNormal.schema = {
        name: 'tuplet-normal',
        attributes: {},
        contents: [
            { type: 'optional', value: TupletNumber },
            { type: 'optional', value: TupletType },
            { type: 'label', label: 'tuplet-dots', value: { type: 'zeroOrMore', value: TupletDot } },
        ],
    };
    return TupletNormal;
}());
exports.TupletNormal = TupletNormal;
/**
 * The `<tuplet>` element
 *
 * Parent element: `<notations>`
 *
 * A `<tuplet>` element is present when a tuplet is to be displayed graphically, in addition to the sound data provided
 * by the `<time-modification>` elements.
 *
 * Whereas a `<time-modification>` element shows how the cumulative, sounding effect of tuplets and double-note tremolos
 * compare to the written note type, the `<tuplet>` element describes how this is displayed. The `<tuplet>` element also
 * provides more detailed representation information than the `<time-modification>` element, and is needed to represent
 * nested tuplets and other complex tuplets accurately.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet/}
 */
var Tuplet = /** @class */ (function () {
    function Tuplet(opts) {
        var _a;
        this.schema = Tuplet.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Tuplet.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Tuplet.schema.contents);
    }
    /** Gets @type {TupletAttributes['type']}. */
    Tuplet.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {TupletAttributes['type']}. */
    Tuplet.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {TupletAttributes['bracket']}. */
    Tuplet.prototype.getBracket = function () {
        return this.attributes['bracket'];
    };
    /** Sets @type {TupletAttributes['bracket']}. */
    Tuplet.prototype.setBracket = function (bracket) {
        this.attributes['bracket'] = bracket;
        return this;
    };
    /** Gets @type {TupletAttributes['default-x']}. */
    Tuplet.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {TupletAttributes['default-x']}. */
    Tuplet.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {TupletAttributes['default-y']}. */
    Tuplet.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {TupletAttributes['default-y']}. */
    Tuplet.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {TupletAttributes['id']}. */
    Tuplet.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {TupletAttributes['id']}. */
    Tuplet.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {TupletAttributes['line-shape']}. */
    Tuplet.prototype.getLineShape = function () {
        return this.attributes['line-shape'];
    };
    /** Sets @type {TupletAttributes['line-shape']}. */
    Tuplet.prototype.setLineShape = function (lineShape) {
        this.attributes['line-shape'] = lineShape;
        return this;
    };
    /** Gets @type {TupletAttributes['number']}. */
    Tuplet.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {TupletAttributes['number']}. */
    Tuplet.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {TupletAttributes['placement']}. */
    Tuplet.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {TupletAttributes['placement']}. */
    Tuplet.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {TupletAttributes['relative-x']}. */
    Tuplet.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {TupletAttributes['relative-x']}. */
    Tuplet.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {TupletAttributes['relative-y']}. */
    Tuplet.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {TupletAttributes['relative-y']}. */
    Tuplet.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {TupletAttributes['show-number']}. */
    Tuplet.prototype.getShowNumber = function () {
        return this.attributes['show-number'];
    };
    /** Sets @type {TupletAttributes['show-number']}. */
    Tuplet.prototype.setShowNumber = function (showNumber) {
        this.attributes['show-number'] = showNumber;
        return this;
    };
    /** Gets @type {TupletAttributes['show-type']}. */
    Tuplet.prototype.getShowType = function () {
        return this.attributes['show-type'];
    };
    /** Sets @type {TupletAttributes['show-type']}. */
    Tuplet.prototype.setShowType = function (showType) {
        this.attributes['show-type'] = showType;
        return this;
    };
    /** Gets @type {TupletActual | null}. */
    Tuplet.prototype.getTupletActual = function () {
        return this.contents[0];
    };
    /** Sets @type {TupletActual | null}. */
    Tuplet.prototype.setTupletActual = function (tupletActual) {
        this.contents[0] = tupletActual;
        return this;
    };
    /** Gets @type {TupletNormal | null}. */
    Tuplet.prototype.getTupletNormal = function () {
        return this.contents[1];
    };
    /** Sets @type {TupletNormal | null}. */
    Tuplet.prototype.setTupletNormal = function (tupletNormal) {
        this.contents[1] = tupletNormal;
        return this;
    };
    Tuplet.schema = {
        name: 'tuplet',
        attributes: {
            type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop'] } },
            bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'show-number': { type: 'optional', value: { type: 'choices', choices: ['none', 'actual', 'both'] } },
            'show-type': { type: 'optional', value: { type: 'choices', choices: ['none', 'actual', 'both'] } },
        },
        contents: [
            { type: 'optional', value: TupletActual },
            { type: 'optional', value: TupletNormal },
        ],
    };
    return Tuplet;
}());
exports.Tuplet = Tuplet;
/**
 * The `<glissando>` element
 *
 * Parent element: `<notations>`
 *
 * The `<glissando>` and `<slide>` elements both indicate rapidly moving from one pitch to the other so that individual
 * notes are not discerned. A `<glissando>` sounds the distinct notes in between the two pitches and defaults to a wavy
 * line. The optional text is printed alongside the line.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/glissando/}
 */
var Glissando = /** @class */ (function () {
    function Glissando(opts) {
        var _a;
        this.schema = Glissando.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Glissando.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Glissando.schema.contents);
    }
    /** Gets @type {GlissandoAttributes['type']}. */
    Glissando.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {GlissandoAttributes['type']}. */
    Glissando.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {GlissandoAttributes['color']}. */
    Glissando.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {GlissandoAttributes['color']}. */
    Glissando.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {GlissandoAttributes['dash-length']}. */
    Glissando.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {GlissandoAttributes['dash-length']}. */
    Glissando.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {GlissandoAttributes['default-x']}. */
    Glissando.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {GlissandoAttributes['default-x']}. */
    Glissando.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {GlissandoAttributes['default-y']}. */
    Glissando.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {GlissandoAttributes['default-y']}. */
    Glissando.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {GlissandoAttributes['font-family']}. */
    Glissando.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {GlissandoAttributes['font-family']}. */
    Glissando.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {GlissandoAttributes['font-size']}. */
    Glissando.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {GlissandoAttributes['font-size']}. */
    Glissando.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {GlissandoAttributes['font-style']}. */
    Glissando.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {GlissandoAttributes['font-style']}. */
    Glissando.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {GlissandoAttributes['font-weight']}. */
    Glissando.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {GlissandoAttributes['font-weight']}. */
    Glissando.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {GlissandoAttributes['id']}. */
    Glissando.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {GlissandoAttributes['id']}. */
    Glissando.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {GlissandoAttributes['line-type']}. */
    Glissando.prototype.getLineType = function () {
        return this.attributes['line-type'];
    };
    /** Sets @type {GlissandoAttributes['line-type']}. */
    Glissando.prototype.setLineType = function (lineType) {
        this.attributes['line-type'] = lineType;
        return this;
    };
    /** Gets @type {GlissandoAttributes['number']}. */
    Glissando.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {GlissandoAttributes['number']}. */
    Glissando.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {GlissandoAttributes['relative-x']}. */
    Glissando.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {GlissandoAttributes['relative-x']}. */
    Glissando.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {GlissandoAttributes['relative-y']}. */
    Glissando.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {GlissandoAttributes['relative-y']}. */
    Glissando.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {GlissandoAttributes['space-length']}. */
    Glissando.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {GlissandoAttributes['space-length']}. */
    Glissando.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    /** Gets @type {string}. */
    Glissando.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Glissando.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Glissando.schema = {
        name: 'glissando',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Glissando;
}());
exports.Glissando = Glissando;
/**
 * The `<slide>` element
 *
 * Parent element: `<notations>`
 *
 * The `<glissando>` and `<slide>` elements both indicate rapidly moving from one pitch to the other so that individual
 * notes are not discerned. A `<slide>` is continuous between the two pitches and defaults to a solid line. The optional
 * text is printed alongside the line.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/slide/}
 */
var Slide = /** @class */ (function () {
    function Slide(opts) {
        var _a;
        this.schema = Slide.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Slide.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Slide.schema.contents);
    }
    /** Gets @type {SlideAttributes['type']}. */
    Slide.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {SlideAttributes['type']}. */
    Slide.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {SlideAttributes['accelerate']}. */
    Slide.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {SlideAttributes['accelerate']}. */
    Slide.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {SlideAttributes['beats']}. */
    Slide.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {SlideAttributes['beats']}. */
    Slide.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {SlideAttributes['color']}. */
    Slide.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {SlideAttributes['color']}. */
    Slide.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {SlideAttributes['dash-length']}. */
    Slide.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {SlideAttributes['dash-length']}. */
    Slide.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {SlideAttributes['default-x']}. */
    Slide.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {SlideAttributes['default-x']}. */
    Slide.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {SlideAttributes['default-y']}. */
    Slide.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {SlideAttributes['default-y']}. */
    Slide.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {SlideAttributes['first-beat']}. */
    Slide.prototype.getFirstBeat = function () {
        return this.attributes['first-beat'];
    };
    /** Sets @type {SlideAttributes['first-beat']}. */
    Slide.prototype.setFirstBeat = function (firstBeat) {
        this.attributes['first-beat'] = firstBeat;
        return this;
    };
    /** Gets @type {SlideAttributes['font-family']}. */
    Slide.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {SlideAttributes['font-family']}. */
    Slide.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {SlideAttributes['font-size']}. */
    Slide.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {SlideAttributes['font-size']}. */
    Slide.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {SlideAttributes['font-style']}. */
    Slide.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {SlideAttributes['font-style']}. */
    Slide.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {SlideAttributes['font-weight']}. */
    Slide.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {SlideAttributes['font-weight']}. */
    Slide.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {SlideAttributes['id']}. */
    Slide.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {SlideAttributes['id']}. */
    Slide.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {SlideAttributes['last-beat']}. */
    Slide.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {SlideAttributes['last-beat']}. */
    Slide.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {SlideAttributes['line-type']}. */
    Slide.prototype.getLineType = function () {
        return this.attributes['line-type'];
    };
    /** Sets @type {SlideAttributes['line-type']}. */
    Slide.prototype.setLineType = function (lineType) {
        this.attributes['line-type'] = lineType;
        return this;
    };
    /** Gets @type {SlideAttributes['number']}. */
    Slide.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {SlideAttributes['number']}. */
    Slide.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {SlideAttributes['relative-x']}. */
    Slide.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {SlideAttributes['relative-x']}. */
    Slide.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {SlideAttributes['relative-y']}. */
    Slide.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {SlideAttributes['relative-y']}. */
    Slide.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {SlideAttributes['space-length']}. */
    Slide.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {SlideAttributes['space-length']}. */
    Slide.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    /** Gets @type {string}. */
    Slide.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Slide.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Slide.schema = {
        name: 'slide',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'first-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Slide;
}());
exports.Slide = Slide;
/**
 * The `<trill-mark>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<trill-mark>` element represents the trill symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/trill-mark/}
 */
var TrillMark = /** @class */ (function () {
    function TrillMark(opts) {
        var _a;
        this.schema = TrillMark.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TrillMark.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TrillMark.schema.contents);
    }
    /** Gets @type {TrillMarkAttributes['acccelerate']}. */
    TrillMark.prototype.getAcccelerate = function () {
        return this.attributes['acccelerate'];
    };
    /** Sets @type {TrillMarkAttributes['acccelerate']}. */
    TrillMark.prototype.setAcccelerate = function (acccelerate) {
        this.attributes['acccelerate'] = acccelerate;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['beats']}. */
    TrillMark.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {TrillMarkAttributes['beats']}. */
    TrillMark.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['color']}. */
    TrillMark.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TrillMarkAttributes['color']}. */
    TrillMark.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['default-x']}. */
    TrillMark.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {TrillMarkAttributes['default-x']}. */
    TrillMark.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['default-y']}. */
    TrillMark.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {TrillMarkAttributes['default-y']}. */
    TrillMark.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['font-family']}. */
    TrillMark.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TrillMarkAttributes['font-family']}. */
    TrillMark.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['font-size']}. */
    TrillMark.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TrillMarkAttributes['font-size']}. */
    TrillMark.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['font-style']}. */
    TrillMark.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TrillMarkAttributes['font-style']}. */
    TrillMark.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['font-weight']}. */
    TrillMark.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TrillMarkAttributes['font-weight']}. */
    TrillMark.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['last-beat']}. */
    TrillMark.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {TrillMarkAttributes['last-beat']}. */
    TrillMark.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['placement']}. */
    TrillMark.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {TrillMarkAttributes['placement']}. */
    TrillMark.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['relative-x']}. */
    TrillMark.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {TrillMarkAttributes['relative-x']}. */
    TrillMark.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['relative-y']}. */
    TrillMark.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {TrillMarkAttributes['relative-y']}. */
    TrillMark.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['second-beat']}. */
    TrillMark.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {TrillMarkAttributes['second-beat']}. */
    TrillMark.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['start-note']}. */
    TrillMark.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {TrillMarkAttributes['start-note']}. */
    TrillMark.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['trill-step']}. */
    TrillMark.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {TrillMarkAttributes['trill-step']}. */
    TrillMark.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {TrillMarkAttributes['two-note-turn']}. */
    TrillMark.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {TrillMarkAttributes['two-note-turn']}. */
    TrillMark.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    TrillMark.schema = {
        name: 'trill-mark',
        attributes: {
            acccelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return TrillMark;
}());
exports.TrillMark = TrillMark;
/**
 * The `<turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<turn>` element is the normal turn shape which goes up then down.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/turn/}
 */
var Turn = /** @class */ (function () {
    function Turn(opts) {
        var _a;
        this.schema = Turn.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Turn.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Turn.schema.contents);
    }
    /** Gets @type {TurnAttributes['accelerate']}. */
    Turn.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {TurnAttributes['accelerate']}. */
    Turn.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {TurnAttributes['beats']}. */
    Turn.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {TurnAttributes['beats']}. */
    Turn.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {TurnAttributes['color']}. */
    Turn.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TurnAttributes['color']}. */
    Turn.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TurnAttributes['default-x']}. */
    Turn.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {TurnAttributes['default-x']}. */
    Turn.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {TurnAttributes['default-y']}. */
    Turn.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {TurnAttributes['default-y']}. */
    Turn.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {TurnAttributes['font-family']}. */
    Turn.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TurnAttributes['font-family']}. */
    Turn.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TurnAttributes['font-size']}. */
    Turn.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TurnAttributes['font-size']}. */
    Turn.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TurnAttributes['font-style']}. */
    Turn.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TurnAttributes['font-style']}. */
    Turn.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TurnAttributes['font-weight']}. */
    Turn.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TurnAttributes['font-weight']}. */
    Turn.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {TurnAttributes['last-beat']}. */
    Turn.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {TurnAttributes['last-beat']}. */
    Turn.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {TurnAttributes['placement']}. */
    Turn.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {TurnAttributes['placement']}. */
    Turn.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {TurnAttributes['relative-x']}. */
    Turn.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {TurnAttributes['relative-x']}. */
    Turn.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {TurnAttributes['relative-y']}. */
    Turn.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {TurnAttributes['relative-y']}. */
    Turn.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {TurnAttributes['second-beat']}. */
    Turn.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {TurnAttributes['second-beat']}. */
    Turn.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {TurnAttributes['slash']}. */
    Turn.prototype.getSlash = function () {
        return this.attributes['slash'];
    };
    /** Sets @type {TurnAttributes['slash']}. */
    Turn.prototype.setSlash = function (slash) {
        this.attributes['slash'] = slash;
        return this;
    };
    /** Gets @type {TurnAttributes['start-note']}. */
    Turn.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {TurnAttributes['start-note']}. */
    Turn.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {TurnAttributes['trill-step']}. */
    Turn.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {TurnAttributes['trill-step']}. */
    Turn.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {TurnAttributes['two-note-turn']}. */
    Turn.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {TurnAttributes['two-note-turn']}. */
    Turn.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    Turn.schema = {
        name: 'turn',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return Turn;
}());
exports.Turn = Turn;
/**
 * The `<delayed-turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<delayed-turn>` element indicates a normal turn that is delayed until the end of the current note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/delayed-turn/}
 */
var DelayedTurn = /** @class */ (function () {
    function DelayedTurn(opts) {
        var _a;
        this.schema = DelayedTurn.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DelayedTurn.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DelayedTurn.schema.contents);
    }
    /** Gets @type {DelayedTurnAttributes['accelerate']}. */
    DelayedTurn.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {DelayedTurnAttributes['accelerate']}. */
    DelayedTurn.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['beats']}. */
    DelayedTurn.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {DelayedTurnAttributes['beats']}. */
    DelayedTurn.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['color']}. */
    DelayedTurn.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DelayedTurnAttributes['color']}. */
    DelayedTurn.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['default-x']}. */
    DelayedTurn.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DelayedTurnAttributes['default-x']}. */
    DelayedTurn.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['default-y']}. */
    DelayedTurn.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DelayedTurnAttributes['default-y']}. */
    DelayedTurn.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['font-family']}. */
    DelayedTurn.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DelayedTurnAttributes['font-family']}. */
    DelayedTurn.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['font-size']}. */
    DelayedTurn.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DelayedTurnAttributes['font-size']}. */
    DelayedTurn.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['font-style']}. */
    DelayedTurn.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DelayedTurnAttributes['font-style']}. */
    DelayedTurn.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['font-weight']}. */
    DelayedTurn.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DelayedTurnAttributes['font-weight']}. */
    DelayedTurn.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['last-beat']}. */
    DelayedTurn.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {DelayedTurnAttributes['last-beat']}. */
    DelayedTurn.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['placement']}. */
    DelayedTurn.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {DelayedTurnAttributes['placement']}. */
    DelayedTurn.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['relative-x']}. */
    DelayedTurn.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DelayedTurnAttributes['relative-x']}. */
    DelayedTurn.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['relative-y']}. */
    DelayedTurn.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DelayedTurnAttributes['relative-y']}. */
    DelayedTurn.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['second-beat']}. */
    DelayedTurn.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {DelayedTurnAttributes['second-beat']}. */
    DelayedTurn.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['slash']}. */
    DelayedTurn.prototype.getSlash = function () {
        return this.attributes['slash'];
    };
    /** Sets @type {DelayedTurnAttributes['slash']}. */
    DelayedTurn.prototype.setSlash = function (slash) {
        this.attributes['slash'] = slash;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['start-note']}. */
    DelayedTurn.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {DelayedTurnAttributes['start-note']}. */
    DelayedTurn.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['trill-step']}. */
    DelayedTurn.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {DelayedTurnAttributes['trill-step']}. */
    DelayedTurn.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {DelayedTurnAttributes['two-note-turn']}. */
    DelayedTurn.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {DelayedTurnAttributes['two-note-turn']}. */
    DelayedTurn.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    DelayedTurn.schema = {
        name: 'delayed-turn',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return DelayedTurn;
}());
exports.DelayedTurn = DelayedTurn;
/**
 * The `<inverted-turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<inverted-turn>` element has the shape which goes down and then up.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/inverted-turn/}
 */
var InvertedTurn = /** @class */ (function () {
    function InvertedTurn(opts) {
        var _a;
        this.schema = InvertedTurn.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, InvertedTurn.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(InvertedTurn.schema.contents);
    }
    /** Gets @type {InvertedTurnAttributes['accelerate']}. */
    InvertedTurn.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {InvertedTurnAttributes['accelerate']}. */
    InvertedTurn.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['beats']}. */
    InvertedTurn.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {InvertedTurnAttributes['beats']}. */
    InvertedTurn.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['color']}. */
    InvertedTurn.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {InvertedTurnAttributes['color']}. */
    InvertedTurn.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['default-x']}. */
    InvertedTurn.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {InvertedTurnAttributes['default-x']}. */
    InvertedTurn.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['default-y']}. */
    InvertedTurn.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {InvertedTurnAttributes['default-y']}. */
    InvertedTurn.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['font-family']}. */
    InvertedTurn.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {InvertedTurnAttributes['font-family']}. */
    InvertedTurn.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['font-size']}. */
    InvertedTurn.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {InvertedTurnAttributes['font-size']}. */
    InvertedTurn.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['font-style']}. */
    InvertedTurn.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {InvertedTurnAttributes['font-style']}. */
    InvertedTurn.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['font-weight']}. */
    InvertedTurn.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {InvertedTurnAttributes['font-weight']}. */
    InvertedTurn.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['last-beat']}. */
    InvertedTurn.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {InvertedTurnAttributes['last-beat']}. */
    InvertedTurn.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['placement']}. */
    InvertedTurn.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {InvertedTurnAttributes['placement']}. */
    InvertedTurn.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['relative-x']}. */
    InvertedTurn.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {InvertedTurnAttributes['relative-x']}. */
    InvertedTurn.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['relative-y']}. */
    InvertedTurn.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {InvertedTurnAttributes['relative-y']}. */
    InvertedTurn.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['second-beat']}. */
    InvertedTurn.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {InvertedTurnAttributes['second-beat']}. */
    InvertedTurn.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['slash']}. */
    InvertedTurn.prototype.getSlash = function () {
        return this.attributes['slash'];
    };
    /** Sets @type {InvertedTurnAttributes['slash']}. */
    InvertedTurn.prototype.setSlash = function (slash) {
        this.attributes['slash'] = slash;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['start-note']}. */
    InvertedTurn.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {InvertedTurnAttributes['start-note']}. */
    InvertedTurn.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['trill-step']}. */
    InvertedTurn.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {InvertedTurnAttributes['trill-step']}. */
    InvertedTurn.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {InvertedTurnAttributes['two-note-turn']}. */
    InvertedTurn.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {InvertedTurnAttributes['two-note-turn']}. */
    InvertedTurn.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    InvertedTurn.schema = {
        name: 'inverted-turn',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return InvertedTurn;
}());
exports.InvertedTurn = InvertedTurn;
/**
 * The `<delayed-inverted-turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<delayed-inverted-turn>` element indicates an inverted turn that is delayed until the end of the current note.
 * An inverted turn has the shape which goes down and then up.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/delayed-inverted-turn/}
 */
var DelayedInvertedTurn = /** @class */ (function () {
    function DelayedInvertedTurn(opts) {
        var _a;
        this.schema = DelayedInvertedTurn.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DelayedInvertedTurn.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DelayedInvertedTurn.schema.contents);
    }
    /** Gets @type {DelayedInvertedTurnAttributes['accelerate']}. */
    DelayedInvertedTurn.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['accelerate']}. */
    DelayedInvertedTurn.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['beats']}. */
    DelayedInvertedTurn.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['beats']}. */
    DelayedInvertedTurn.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['color']}. */
    DelayedInvertedTurn.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['color']}. */
    DelayedInvertedTurn.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['default-x']}. */
    DelayedInvertedTurn.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['default-x']}. */
    DelayedInvertedTurn.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['default-y']}. */
    DelayedInvertedTurn.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['default-y']}. */
    DelayedInvertedTurn.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['font-family']}. */
    DelayedInvertedTurn.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['font-family']}. */
    DelayedInvertedTurn.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['font-size']}. */
    DelayedInvertedTurn.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['font-size']}. */
    DelayedInvertedTurn.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['font-style']}. */
    DelayedInvertedTurn.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['font-style']}. */
    DelayedInvertedTurn.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['font-weight']}. */
    DelayedInvertedTurn.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['font-weight']}. */
    DelayedInvertedTurn.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['last-beat']}. */
    DelayedInvertedTurn.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['last-beat']}. */
    DelayedInvertedTurn.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['placement']}. */
    DelayedInvertedTurn.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['placement']}. */
    DelayedInvertedTurn.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['relative-x']}. */
    DelayedInvertedTurn.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['relative-x']}. */
    DelayedInvertedTurn.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['relative-y']}. */
    DelayedInvertedTurn.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['relative-y']}. */
    DelayedInvertedTurn.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['second-beat']}. */
    DelayedInvertedTurn.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['second-beat']}. */
    DelayedInvertedTurn.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['slash']}. */
    DelayedInvertedTurn.prototype.getSlash = function () {
        return this.attributes['slash'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['slash']}. */
    DelayedInvertedTurn.prototype.setSlash = function (slash) {
        this.attributes['slash'] = slash;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['start-note']}. */
    DelayedInvertedTurn.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['start-note']}. */
    DelayedInvertedTurn.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['trill-step']}. */
    DelayedInvertedTurn.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['trill-step']}. */
    DelayedInvertedTurn.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {DelayedInvertedTurnAttributes['two-note-turn']}. */
    DelayedInvertedTurn.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {DelayedInvertedTurnAttributes['two-note-turn']}. */
    DelayedInvertedTurn.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    DelayedInvertedTurn.schema = {
        name: 'delayed-inverted-turn',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return DelayedInvertedTurn;
}());
exports.DelayedInvertedTurn = DelayedInvertedTurn;
/**
 * The `<vertical-turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<vertical-turn>` element has the turn symbol shape arranged vertically going from upper left to lower right.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/vertical-turn/}
 */
var VerticalTurn = /** @class */ (function () {
    function VerticalTurn(opts) {
        var _a;
        this.schema = VerticalTurn.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, VerticalTurn.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(VerticalTurn.schema.contents);
    }
    /** Gets @type {VerticalTurnAttributes['accelerate']}. */
    VerticalTurn.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {VerticalTurnAttributes['accelerate']}. */
    VerticalTurn.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['beats']}. */
    VerticalTurn.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {VerticalTurnAttributes['beats']}. */
    VerticalTurn.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['color']}. */
    VerticalTurn.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {VerticalTurnAttributes['color']}. */
    VerticalTurn.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['default-x']}. */
    VerticalTurn.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {VerticalTurnAttributes['default-x']}. */
    VerticalTurn.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['default-y']}. */
    VerticalTurn.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {VerticalTurnAttributes['default-y']}. */
    VerticalTurn.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['font-family']}. */
    VerticalTurn.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {VerticalTurnAttributes['font-family']}. */
    VerticalTurn.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['font-size']}. */
    VerticalTurn.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {VerticalTurnAttributes['font-size']}. */
    VerticalTurn.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['font-style']}. */
    VerticalTurn.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {VerticalTurnAttributes['font-style']}. */
    VerticalTurn.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['font-weight']}. */
    VerticalTurn.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {VerticalTurnAttributes['font-weight']}. */
    VerticalTurn.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['last-beat']}. */
    VerticalTurn.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {VerticalTurnAttributes['last-beat']}. */
    VerticalTurn.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['placement']}. */
    VerticalTurn.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {VerticalTurnAttributes['placement']}. */
    VerticalTurn.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['relative-x']}. */
    VerticalTurn.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {VerticalTurnAttributes['relative-x']}. */
    VerticalTurn.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['relative-y']}. */
    VerticalTurn.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {VerticalTurnAttributes['relative-y']}. */
    VerticalTurn.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['second-beat']}. */
    VerticalTurn.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {VerticalTurnAttributes['second-beat']}. */
    VerticalTurn.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['start-note']}. */
    VerticalTurn.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {VerticalTurnAttributes['start-note']}. */
    VerticalTurn.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['trill-step']}. */
    VerticalTurn.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {VerticalTurnAttributes['trill-step']}. */
    VerticalTurn.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {VerticalTurnAttributes['two-note-turn']}. */
    VerticalTurn.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {VerticalTurnAttributes['two-note-turn']}. */
    VerticalTurn.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    VerticalTurn.schema = {
        name: 'vertical-turn',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return VerticalTurn;
}());
exports.VerticalTurn = VerticalTurn;
/**
 * The `<inverted-vertical-turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<inverted-vertical-turn>` element has the turn symbol shape arranged vertically going from upper right to lower left.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/inverted-vertical-turn/}
 */
var InvertedVerticalTurn = /** @class */ (function () {
    function InvertedVerticalTurn(opts) {
        var _a;
        this.schema = InvertedVerticalTurn.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, InvertedVerticalTurn.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(InvertedVerticalTurn.schema.contents);
    }
    /** Gets @type {InvertedVerticalTurnAttributes['accelerate']}. */
    InvertedVerticalTurn.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['accelerate']}. */
    InvertedVerticalTurn.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['beats']}. */
    InvertedVerticalTurn.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['beats']}. */
    InvertedVerticalTurn.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['color']}. */
    InvertedVerticalTurn.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['color']}. */
    InvertedVerticalTurn.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['default-x']}. */
    InvertedVerticalTurn.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['default-x']}. */
    InvertedVerticalTurn.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['default-y']}. */
    InvertedVerticalTurn.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['default-y']}. */
    InvertedVerticalTurn.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['font-family']}. */
    InvertedVerticalTurn.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['font-family']}. */
    InvertedVerticalTurn.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['font-size']}. */
    InvertedVerticalTurn.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['font-size']}. */
    InvertedVerticalTurn.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['font-style']}. */
    InvertedVerticalTurn.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['font-style']}. */
    InvertedVerticalTurn.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['font-weight']}. */
    InvertedVerticalTurn.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['font-weight']}. */
    InvertedVerticalTurn.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['last-beat']}. */
    InvertedVerticalTurn.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['last-beat']}. */
    InvertedVerticalTurn.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['placement']}. */
    InvertedVerticalTurn.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['placement']}. */
    InvertedVerticalTurn.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['relative-x']}. */
    InvertedVerticalTurn.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['relative-x']}. */
    InvertedVerticalTurn.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['relative-y']}. */
    InvertedVerticalTurn.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['relative-y']}. */
    InvertedVerticalTurn.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['second-beat']}. */
    InvertedVerticalTurn.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['second-beat']}. */
    InvertedVerticalTurn.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['start-note']}. */
    InvertedVerticalTurn.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['start-note']}. */
    InvertedVerticalTurn.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['trill-step']}. */
    InvertedVerticalTurn.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['trill-step']}. */
    InvertedVerticalTurn.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {InvertedVerticalTurnAttributes['two-note-turn']}. */
    InvertedVerticalTurn.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {InvertedVerticalTurnAttributes['two-note-turn']}. */
    InvertedVerticalTurn.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    InvertedVerticalTurn.schema = {
        name: 'inverted-vertical-turn',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return InvertedVerticalTurn;
}());
exports.InvertedVerticalTurn = InvertedVerticalTurn;
/**
 * The `<shake>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<shake>` element has a similar appearance to an `<inverted-mordent>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/shake/}
 */
var Shake = /** @class */ (function () {
    function Shake(opts) {
        var _a;
        this.schema = Shake.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Shake.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Shake.schema.contents);
    }
    /** Gets @type {ShakeAttributes['accelerate']}. */
    Shake.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {ShakeAttributes['accelerate']}. */
    Shake.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {ShakeAttributes['beats']}. */
    Shake.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {ShakeAttributes['beats']}. */
    Shake.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {ShakeAttributes['color']}. */
    Shake.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {ShakeAttributes['color']}. */
    Shake.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {ShakeAttributes['default-x']}. */
    Shake.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {ShakeAttributes['default-x']}. */
    Shake.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {ShakeAttributes['default-y']}. */
    Shake.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {ShakeAttributes['default-y']}. */
    Shake.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {ShakeAttributes['font-family']}. */
    Shake.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {ShakeAttributes['font-family']}. */
    Shake.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {ShakeAttributes['font-size']}. */
    Shake.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {ShakeAttributes['font-size']}. */
    Shake.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {ShakeAttributes['font-style']}. */
    Shake.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {ShakeAttributes['font-style']}. */
    Shake.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {ShakeAttributes['font-weight']}. */
    Shake.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {ShakeAttributes['font-weight']}. */
    Shake.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {ShakeAttributes['last-beat']}. */
    Shake.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {ShakeAttributes['last-beat']}. */
    Shake.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {ShakeAttributes['placement']}. */
    Shake.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {ShakeAttributes['placement']}. */
    Shake.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {ShakeAttributes['relative-x']}. */
    Shake.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {ShakeAttributes['relative-x']}. */
    Shake.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {ShakeAttributes['relative-y']}. */
    Shake.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {ShakeAttributes['relative-y']}. */
    Shake.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {ShakeAttributes['second-beat']}. */
    Shake.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {ShakeAttributes['second-beat']}. */
    Shake.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {ShakeAttributes['start-note']}. */
    Shake.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {ShakeAttributes['start-note']}. */
    Shake.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {ShakeAttributes['trill-step']}. */
    Shake.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {ShakeAttributes['trill-step']}. */
    Shake.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {ShakeAttributes['two-note-turn']}. */
    Shake.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {ShakeAttributes['two-note-turn']}. */
    Shake.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    Shake.schema = {
        name: 'shake',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return Shake;
}());
exports.Shake = Shake;
/**
 * The `<wavy-line>` element
 *
 * Parent elements: `<barline>`, `<ornaments>`
 *
 * Wavy lines are one way to indicate trills and vibrato.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/wavy-line/}
 */
var WavyLine = /** @class */ (function () {
    function WavyLine(opts) {
        var _a;
        this.schema = WavyLine.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, WavyLine.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(WavyLine.schema.contents);
    }
    /** Gets @type {WavyLineAttributes['type']}. */
    WavyLine.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {WavyLineAttributes['type']}. */
    WavyLine.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {WavyLineAttributes['accelerate']}. */
    WavyLine.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {WavyLineAttributes['accelerate']}. */
    WavyLine.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {WavyLineAttributes['beats']}. */
    WavyLine.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {WavyLineAttributes['beats']}. */
    WavyLine.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {WavyLineAttributes['color']}. */
    WavyLine.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {WavyLineAttributes['color']}. */
    WavyLine.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {WavyLineAttributes['default-x']}. */
    WavyLine.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {WavyLineAttributes['default-x']}. */
    WavyLine.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {WavyLineAttributes['default-y']}. */
    WavyLine.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {WavyLineAttributes['default-y']}. */
    WavyLine.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {WavyLineAttributes['last-beat']}. */
    WavyLine.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {WavyLineAttributes['last-beat']}. */
    WavyLine.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {WavyLineAttributes['number']}. */
    WavyLine.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {WavyLineAttributes['number']}. */
    WavyLine.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {WavyLineAttributes['placement']}. */
    WavyLine.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {WavyLineAttributes['placement']}. */
    WavyLine.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {WavyLineAttributes['relative-x']}. */
    WavyLine.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {WavyLineAttributes['relative-x']}. */
    WavyLine.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {WavyLineAttributes['relative-y']}. */
    WavyLine.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {WavyLineAttributes['relative-y']}. */
    WavyLine.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {WavyLineAttributes['second-beat']}. */
    WavyLine.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {WavyLineAttributes['second-beat']}. */
    WavyLine.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {WavyLineAttributes['smufl']}. */
    WavyLine.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {WavyLineAttributes['smufl']}. */
    WavyLine.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {WavyLineAttributes['start-note']}. */
    WavyLine.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {WavyLineAttributes['start-note']}. */
    WavyLine.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {WavyLineAttributes['trill-step']}. */
    WavyLine.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {WavyLineAttributes['trill-step']}. */
    WavyLine.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {WavyLineAttributes['two-note-turn']}. */
    WavyLine.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {WavyLineAttributes['two-note-turn']}. */
    WavyLine.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    WavyLine.schema = {
        name: 'wavy-line',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            smufl: {
                type: 'optional',
                value: { type: 'regex', pattern: /(wiggle)|(guitar\c*VibratoStroke)/, zero: 'wiggle' },
            },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return WavyLine;
}());
exports.WavyLine = WavyLine;
/**
 * The `<mordent>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<mordent>` element represents the sign with the vertical line. The choice of which mordent sign is inverted
 * differs between MusicXML and the Standard Music Font Layout (SMuFL).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/mordent/}
 */
var Mordent = /** @class */ (function () {
    function Mordent(opts) {
        var _a;
        this.schema = Mordent.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Mordent.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Mordent.schema.contents);
    }
    /** Gets @type {MordentAttributes['accelerate']}. */
    Mordent.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {MordentAttributes['accelerate']}. */
    Mordent.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {MordentAttributes['approach']}. */
    Mordent.prototype.getApproach = function () {
        return this.attributes['approach'];
    };
    /** Sets @type {MordentAttributes['approach']}. */
    Mordent.prototype.setApproach = function (approach) {
        this.attributes['approach'] = approach;
        return this;
    };
    /** Gets @type {MordentAttributes['beats']}. */
    Mordent.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {MordentAttributes['beats']}. */
    Mordent.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {MordentAttributes['color']}. */
    Mordent.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {MordentAttributes['color']}. */
    Mordent.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {MordentAttributes['default-x']}. */
    Mordent.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {MordentAttributes['default-x']}. */
    Mordent.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {MordentAttributes['default-y']}. */
    Mordent.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {MordentAttributes['default-y']}. */
    Mordent.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {MordentAttributes['departure']}. */
    Mordent.prototype.getDeparture = function () {
        return this.attributes['departure'];
    };
    /** Sets @type {MordentAttributes['departure']}. */
    Mordent.prototype.setDeparture = function (departure) {
        this.attributes['departure'] = departure;
        return this;
    };
    /** Gets @type {MordentAttributes['font-family']}. */
    Mordent.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {MordentAttributes['font-family']}. */
    Mordent.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {MordentAttributes['font-size']}. */
    Mordent.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {MordentAttributes['font-size']}. */
    Mordent.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {MordentAttributes['font-style']}. */
    Mordent.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {MordentAttributes['font-style']}. */
    Mordent.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {MordentAttributes['font-weight']}. */
    Mordent.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {MordentAttributes['font-weight']}. */
    Mordent.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {MordentAttributes['last-beat']}. */
    Mordent.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {MordentAttributes['last-beat']}. */
    Mordent.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {MordentAttributes['long']}. */
    Mordent.prototype.getLong = function () {
        return this.attributes['long'];
    };
    /** Sets @type {MordentAttributes['long']}. */
    Mordent.prototype.setLong = function (long) {
        this.attributes['long'] = long;
        return this;
    };
    /** Gets @type {MordentAttributes['placement']}. */
    Mordent.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {MordentAttributes['placement']}. */
    Mordent.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {MordentAttributes['relative-x']}. */
    Mordent.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {MordentAttributes['relative-x']}. */
    Mordent.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {MordentAttributes['relative-y']}. */
    Mordent.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {MordentAttributes['relative-y']}. */
    Mordent.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {MordentAttributes['second-beat']}. */
    Mordent.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {MordentAttributes['second-beat']}. */
    Mordent.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {MordentAttributes['start-note']}. */
    Mordent.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {MordentAttributes['start-note']}. */
    Mordent.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {MordentAttributes['trill-step']}. */
    Mordent.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {MordentAttributes['trill-step']}. */
    Mordent.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {MordentAttributes['two-note-turn']}. */
    Mordent.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {MordentAttributes['two-note-turn']}. */
    Mordent.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    Mordent.schema = {
        name: 'mordent',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            approach: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            departure: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            long: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return Mordent;
}());
exports.Mordent = Mordent;
/**
 * The `<inverted-mordent>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<inverted-mordent>` element represents the sign without the vertical line. The choice of which mordent is
 * inverted differs between MusicXML and the Standard Music Font Layout (SMuFL).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/inverted-mordent/}
 */
var InvertedMordent = /** @class */ (function () {
    function InvertedMordent(opts) {
        var _a;
        this.schema = InvertedMordent.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, InvertedMordent.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(InvertedMordent.schema.contents);
    }
    /** Gets @type {InvertedMordentAttributes['accelerate']}. */
    InvertedMordent.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {InvertedMordentAttributes['accelerate']}. */
    InvertedMordent.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['approach']}. */
    InvertedMordent.prototype.getApproach = function () {
        return this.attributes['approach'];
    };
    /** Sets @type {InvertedMordentAttributes['approach']}. */
    InvertedMordent.prototype.setApproach = function (approach) {
        this.attributes['approach'] = approach;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['beats']}. */
    InvertedMordent.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {InvertedMordentAttributes['beats']}. */
    InvertedMordent.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['color']}. */
    InvertedMordent.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {InvertedMordentAttributes['color']}. */
    InvertedMordent.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['default-x']}. */
    InvertedMordent.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {InvertedMordentAttributes['default-x']}. */
    InvertedMordent.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['default-y']}. */
    InvertedMordent.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {InvertedMordentAttributes['default-y']}. */
    InvertedMordent.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['departure']}. */
    InvertedMordent.prototype.getDeparture = function () {
        return this.attributes['departure'];
    };
    /** Sets @type {InvertedMordentAttributes['departure']}. */
    InvertedMordent.prototype.setDeparture = function (departure) {
        this.attributes['departure'] = departure;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['font-family']}. */
    InvertedMordent.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {InvertedMordentAttributes['font-family']}. */
    InvertedMordent.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['font-size']}. */
    InvertedMordent.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {InvertedMordentAttributes['font-size']}. */
    InvertedMordent.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['font-style']}. */
    InvertedMordent.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {InvertedMordentAttributes['font-style']}. */
    InvertedMordent.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['font-weight']}. */
    InvertedMordent.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {InvertedMordentAttributes['font-weight']}. */
    InvertedMordent.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['last-beat']}. */
    InvertedMordent.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {InvertedMordentAttributes['last-beat']}. */
    InvertedMordent.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['long']}. */
    InvertedMordent.prototype.getLong = function () {
        return this.attributes['long'];
    };
    /** Sets @type {InvertedMordentAttributes['long']}. */
    InvertedMordent.prototype.setLong = function (long) {
        this.attributes['long'] = long;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['placement']}. */
    InvertedMordent.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {InvertedMordentAttributes['placement']}. */
    InvertedMordent.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['relative-x']}. */
    InvertedMordent.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {InvertedMordentAttributes['relative-x']}. */
    InvertedMordent.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['relative-y']}. */
    InvertedMordent.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {InvertedMordentAttributes['relative-y']}. */
    InvertedMordent.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['second-beat']}. */
    InvertedMordent.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {InvertedMordentAttributes['second-beat']}. */
    InvertedMordent.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['start-note']}. */
    InvertedMordent.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {InvertedMordentAttributes['start-note']}. */
    InvertedMordent.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['trill-step']}. */
    InvertedMordent.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {InvertedMordentAttributes['trill-step']}. */
    InvertedMordent.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {InvertedMordentAttributes['two-note-turn']}. */
    InvertedMordent.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {InvertedMordentAttributes['two-note-turn']}. */
    InvertedMordent.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    InvertedMordent.schema = {
        name: 'inverted-mordent',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            approach: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            departure: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            long: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return InvertedMordent;
}());
exports.InvertedMordent = InvertedMordent;
/**
 * The `<schleifer>` element
 *
 * Parent element: `<ornaments>`
 *
 * The name for the `<schleifer>` element is based on the German ornament name, to avoid confusion with the `<slide>`
 * element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/schleifer/}
 */
var Schleifer = /** @class */ (function () {
    function Schleifer(opts) {
        var _a;
        this.schema = Schleifer.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Schleifer.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Schleifer.schema.contents);
    }
    /** Gets @type {SchleiferAttributes['color']}. */
    Schleifer.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {SchleiferAttributes['color']}. */
    Schleifer.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {SchleiferAttributes['default-x']}. */
    Schleifer.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {SchleiferAttributes['default-x']}. */
    Schleifer.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {SchleiferAttributes['default-y']}. */
    Schleifer.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {SchleiferAttributes['default-y']}. */
    Schleifer.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {SchleiferAttributes['font-family']}. */
    Schleifer.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {SchleiferAttributes['font-family']}. */
    Schleifer.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {SchleiferAttributes['font-size']}. */
    Schleifer.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {SchleiferAttributes['font-size']}. */
    Schleifer.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {SchleiferAttributes['font-style']}. */
    Schleifer.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {SchleiferAttributes['font-style']}. */
    Schleifer.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {SchleiferAttributes['font-weight']}. */
    Schleifer.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {SchleiferAttributes['font-weight']}. */
    Schleifer.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {SchleiferAttributes['placement']}. */
    Schleifer.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {SchleiferAttributes['placement']}. */
    Schleifer.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {SchleiferAttributes['relative-x']}. */
    Schleifer.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {SchleiferAttributes['relative-x']}. */
    Schleifer.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {SchleiferAttributes['relative-y']}. */
    Schleifer.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {SchleiferAttributes['relative-y']}. */
    Schleifer.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Schleifer.schema = {
        name: 'schleifer',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Schleifer;
}());
exports.Schleifer = Schleifer;
/**
 * The `<tremolo>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<tremolo>` element can be used to indicate single-note, double-note, or unmeasured tremolos. The text of the
 * element indicates the number of tremolo marks and is an integer from 0 to 8. Note that the number of attached beams
 * is not included in this value, but is represented separately using the `<beam element>`. The value should be 0 for
 * unmeasured tremolos.
 *
 * When using double-note tremolos, the duration of each note in the tremolo should correspond to half of the notated
 * type value. A `<time-modification>` element should also be added with an `<actual-notes>` value of 2 and a
 * `<normal-notes>` value of 1. If used within a tuplet, this 2/1 ratio should be multiplied by the existing tuplet
 * ratio.
 *
 * The smufl attribute specifies the glyph to use from the Standard Music Font Layout (SMuFL) Tremolos range for an
 * unmeasured tremolo. It is ignored for other tremolo types. The SMuFL buzzRoll glyph is used if the attribute is
 * missing.
 *
 * Using repeater beams for indicating tremolos is deprecated as of Version 3.0.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tremolo/}
 */
var Tremolo = /** @class */ (function () {
    function Tremolo(opts) {
        var _a;
        this.schema = Tremolo.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Tremolo.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Tremolo.schema.contents);
    }
    /** Gets @type {TremoloAttributes['color']}. */
    Tremolo.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TremoloAttributes['color']}. */
    Tremolo.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TremoloAttributes['default-x']}. */
    Tremolo.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {TremoloAttributes['default-x']}. */
    Tremolo.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {TremoloAttributes['default-y']}. */
    Tremolo.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {TremoloAttributes['default-y']}. */
    Tremolo.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {TremoloAttributes['font-family']}. */
    Tremolo.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TremoloAttributes['font-family']}. */
    Tremolo.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TremoloAttributes['font-size']}. */
    Tremolo.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TremoloAttributes['font-size']}. */
    Tremolo.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TremoloAttributes['font-style']}. */
    Tremolo.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TremoloAttributes['font-style']}. */
    Tremolo.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TremoloAttributes['font-weight']}. */
    Tremolo.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TremoloAttributes['font-weight']}. */
    Tremolo.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {TremoloAttributes['placement']}. */
    Tremolo.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {TremoloAttributes['placement']}. */
    Tremolo.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {TremoloAttributes['relative-x']}. */
    Tremolo.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {TremoloAttributes['relative-x']}. */
    Tremolo.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {TremoloAttributes['relative-y']}. */
    Tremolo.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {TremoloAttributes['relative-y']}. */
    Tremolo.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {TremoloAttributes['smufl']}. */
    Tremolo.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {TremoloAttributes['smufl']}. */
    Tremolo.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {TremoloAttributes['type']}. */
    Tremolo.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {TremoloAttributes['type']}. */
    Tremolo.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {number}. */
    Tremolo.prototype.getTremoloMarks = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Tremolo.prototype.setTremoloMarks = function (tremoloMarks) {
        this.contents[0] = tremoloMarks;
        return this;
    };
    Tremolo.schema = {
        name: 'tremolo',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: { type: 'optional', value: { type: 'string' } },
            type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop', 'single', 'unmeasured'] } },
        },
        contents: [
            { type: 'required', value: { type: 'label', label: 'tremolo-marks', value: { type: 'int', min: 0, max: 8 } } },
        ],
    };
    return Tremolo;
}());
exports.Tremolo = Tremolo;
/**
 * The `<haydn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<haydn>` element represents the Haydn ornament. This is defined in the Standard Music Font Layout (SMuFL) as
 * ornamentHaydn.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/haydn/}
 */
var Haydn = /** @class */ (function () {
    function Haydn(opts) {
        var _a;
        this.schema = Haydn.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Haydn.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Haydn.schema.contents);
    }
    /** Gets @type {HaydnAttributes['accelerate']}. */
    Haydn.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {HaydnAttributes['accelerate']}. */
    Haydn.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {HaydnAttributes['beats']}. */
    Haydn.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {HaydnAttributes['beats']}. */
    Haydn.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {HaydnAttributes['color']}. */
    Haydn.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {HaydnAttributes['color']}. */
    Haydn.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {HaydnAttributes['default-x']}. */
    Haydn.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {HaydnAttributes['default-x']}. */
    Haydn.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {HaydnAttributes['default-y']}. */
    Haydn.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {HaydnAttributes['default-y']}. */
    Haydn.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {HaydnAttributes['font-family']}. */
    Haydn.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {HaydnAttributes['font-family']}. */
    Haydn.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {HaydnAttributes['font-size']}. */
    Haydn.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {HaydnAttributes['font-size']}. */
    Haydn.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {HaydnAttributes['font-style']}. */
    Haydn.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {HaydnAttributes['font-style']}. */
    Haydn.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {HaydnAttributes['font-weight']}. */
    Haydn.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {HaydnAttributes['font-weight']}. */
    Haydn.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {HaydnAttributes['last-beat']}. */
    Haydn.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {HaydnAttributes['last-beat']}. */
    Haydn.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {HaydnAttributes['placement']}. */
    Haydn.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {HaydnAttributes['placement']}. */
    Haydn.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {HaydnAttributes['relative-x']}. */
    Haydn.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {HaydnAttributes['relative-x']}. */
    Haydn.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {HaydnAttributes['relative-y']}. */
    Haydn.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {HaydnAttributes['relative-y']}. */
    Haydn.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {HaydnAttributes['second-beat']}. */
    Haydn.prototype.getSecondBeat = function () {
        return this.attributes['second-beat'];
    };
    /** Sets @type {HaydnAttributes['second-beat']}. */
    Haydn.prototype.setSecondBeat = function (secondBeat) {
        this.attributes['second-beat'] = secondBeat;
        return this;
    };
    /** Gets @type {HaydnAttributes['start-note']}. */
    Haydn.prototype.getStartNote = function () {
        return this.attributes['start-note'];
    };
    /** Sets @type {HaydnAttributes['start-note']}. */
    Haydn.prototype.setStartNote = function (startNote) {
        this.attributes['start-note'] = startNote;
        return this;
    };
    /** Gets @type {HaydnAttributes['trill-step']}. */
    Haydn.prototype.getTrillStep = function () {
        return this.attributes['trill-step'];
    };
    /** Sets @type {HaydnAttributes['trill-step']}. */
    Haydn.prototype.setTrillStep = function (trillStep) {
        this.attributes['trill-step'] = trillStep;
        return this;
    };
    /** Gets @type {HaydnAttributes['two-note-turn']}. */
    Haydn.prototype.getTwoNoteTurn = function () {
        return this.attributes['two-note-turn'];
    };
    /** Sets @type {HaydnAttributes['two-note-turn']}. */
    Haydn.prototype.setTwoNoteTurn = function (twoNoteTurn) {
        this.attributes['two-note-turn'] = twoNoteTurn;
        return this;
    };
    Haydn.schema = {
        name: 'haydn',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
            'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
            'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
        },
        contents: [],
    };
    return Haydn;
}());
exports.Haydn = Haydn;
/**
 * The `<other-ornament>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<other-ornament>` element is used to define any ornaments not yet in the MusicXML format. The smufl attribute
 * can be used to specify a particular ornament, allowing application interoperability without requiring every Standard
 * Music Font Layout (SMuFL) ornament to have a MusicXML element equivalent. Using the `<other-ornament>` element
 * without the smufl attribute allows for extended representation, though without application interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-ornament/}
 */
var OtherOrnament = /** @class */ (function () {
    function OtherOrnament(opts) {
        var _a;
        this.schema = OtherOrnament.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherOrnament.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherOrnament.schema.contents);
    }
    /** Gets @type {OtherOrnamentAttributes['color']}. */
    OtherOrnament.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {OtherOrnamentAttributes['color']}. */
    OtherOrnament.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {OtherOrnamentAttributes['default-x']}. */
    OtherOrnament.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {OtherOrnamentAttributes['default-x']}. */
    OtherOrnament.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {OtherOrnamentAttributes['default-y']}. */
    OtherOrnament.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {OtherOrnamentAttributes['default-y']}. */
    OtherOrnament.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {OtherOrnamentAttributes['font-family']}. */
    OtherOrnament.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {OtherOrnamentAttributes['font-family']}. */
    OtherOrnament.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {OtherOrnamentAttributes['font-size']}. */
    OtherOrnament.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {OtherOrnamentAttributes['font-size']}. */
    OtherOrnament.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {OtherOrnamentAttributes['font-style']}. */
    OtherOrnament.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {OtherOrnamentAttributes['font-style']}. */
    OtherOrnament.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {OtherOrnamentAttributes['font-weight']}. */
    OtherOrnament.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {OtherOrnamentAttributes['font-weight']}. */
    OtherOrnament.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {OtherOrnamentAttributes['placement']}. */
    OtherOrnament.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {OtherOrnamentAttributes['placement']}. */
    OtherOrnament.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {OtherOrnamentAttributes['relative-x']}. */
    OtherOrnament.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {OtherOrnamentAttributes['relative-x']}. */
    OtherOrnament.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {OtherOrnamentAttributes['relative-y']}. */
    OtherOrnament.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {OtherOrnamentAttributes['relative-y']}. */
    OtherOrnament.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {OtherOrnamentAttributes['smufl']}. */
    OtherOrnament.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {OtherOrnamentAttributes['smufl']}. */
    OtherOrnament.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {string}. */
    OtherOrnament.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    OtherOrnament.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    OtherOrnament.schema = {
        name: 'other-ornament',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: { type: 'optional', value: { type: 'string' } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return OtherOrnament;
}());
exports.OtherOrnament = OtherOrnament;
/**
 * The `<accidental-mark>` element
 *
 * Parent elements: `<notations>`, `<ornaments>`
 *
 * An `<accidental-mark>` element can be used as a separate notation or as part of an ornament. When used in an
 * ornament, position and placement are relative to the ornament, not relative to the note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accidental-mark/}
 */
var AccidentalMark = /** @class */ (function () {
    function AccidentalMark(opts) {
        var _a;
        this.schema = AccidentalMark.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, AccidentalMark.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(AccidentalMark.schema.contents);
    }
    /** Gets @type {AccidentalMarkAttributes['bracket']}. */
    AccidentalMark.prototype.getBracket = function () {
        return this.attributes['bracket'];
    };
    /** Sets @type {AccidentalMarkAttributes['bracket']}. */
    AccidentalMark.prototype.setBracket = function (bracket) {
        this.attributes['bracket'] = bracket;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['color']}. */
    AccidentalMark.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {AccidentalMarkAttributes['color']}. */
    AccidentalMark.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['default-x']}. */
    AccidentalMark.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {AccidentalMarkAttributes['default-x']}. */
    AccidentalMark.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['default-y']}. */
    AccidentalMark.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {AccidentalMarkAttributes['default-y']}. */
    AccidentalMark.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['font-family']}. */
    AccidentalMark.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {AccidentalMarkAttributes['font-family']}. */
    AccidentalMark.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['font-size']}. */
    AccidentalMark.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {AccidentalMarkAttributes['font-size']}. */
    AccidentalMark.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['font-style']}. */
    AccidentalMark.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {AccidentalMarkAttributes['font-style']}. */
    AccidentalMark.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['font-weight']}. */
    AccidentalMark.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {AccidentalMarkAttributes['font-weight']}. */
    AccidentalMark.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['id']}. */
    AccidentalMark.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {AccidentalMarkAttributes['id']}. */
    AccidentalMark.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['parentheses']}. */
    AccidentalMark.prototype.getParentheses = function () {
        return this.attributes['parentheses'];
    };
    /** Sets @type {AccidentalMarkAttributes['parentheses']}. */
    AccidentalMark.prototype.setParentheses = function (parentheses) {
        this.attributes['parentheses'] = parentheses;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['placement']}. */
    AccidentalMark.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {AccidentalMarkAttributes['placement']}. */
    AccidentalMark.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['relative-x']}. */
    AccidentalMark.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {AccidentalMarkAttributes['relative-x']}. */
    AccidentalMark.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['relative-y']}. */
    AccidentalMark.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {AccidentalMarkAttributes['relative-y']}. */
    AccidentalMark.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['size']}. */
    AccidentalMark.prototype.getSize = function () {
        return this.attributes['size'];
    };
    /** Sets @type {AccidentalMarkAttributes['size']}. */
    AccidentalMark.prototype.setSize = function (size) {
        this.attributes['size'] = size;
        return this;
    };
    /** Gets @type {AccidentalMarkAttributes['smufl']}. */
    AccidentalMark.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {AccidentalMarkAttributes['smufl']}. */
    AccidentalMark.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
    AccidentalMark.prototype.getAccidentalValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
    AccidentalMark.prototype.setAccidentalValue = function (accidentalValue) {
        this.contents[0] = accidentalValue;
        return this;
    };
    AccidentalMark.schema = {
        name: 'accidental-mark',
        attributes: {
            bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
            smufl: {
                type: 'optional',
                value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
            },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'accidental-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'other',
                            'sharp',
                            'natural',
                            'flat',
                            'double-sharp',
                            'sharp-sharp',
                            'flat-flat',
                            'natural-sharp',
                            'natural-flat',
                            'quarter-flat',
                            'quarter-sharp',
                            'three-quarters-flat',
                            'three-quarters-sharp',
                            'sharp-down',
                            'sharp-up',
                            'natural-down',
                            'natural-up',
                            'flat-down',
                            'flat-up',
                            'double-sharp-down',
                            'double-sharp-up',
                            'flat-flat-down',
                            'flat-flat-up',
                            'arrow-down',
                            'arrow-up',
                            'triple-sharp',
                            'triple-flat',
                            'slash-quarter-sharp',
                            'slash-sharp',
                            'slash-flat',
                            'double-slash-flat',
                            'sharp-1',
                            'sharp-2',
                            'sharp-3',
                            'sharp-5',
                            'flat-1',
                            'flat-2',
                            'flat-3',
                            'flat-4',
                            'sori',
                            'koron',
                        ],
                    },
                },
            },
        ],
    };
    return AccidentalMark;
}());
exports.AccidentalMark = AccidentalMark;
/**
 * The `<ornaments>` element
 *
 * Parent element: `<notations>`
 *
 * Ornaments can be any of several types, followed optionally by accidentals. The `<accidental-mark>` element's content
 * is represented the same as an `<accidental>` element, but with a different name to reflect the different musical
 * meaning.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ornaments/}
 */
var Ornaments = /** @class */ (function () {
    function Ornaments(opts) {
        var _a;
        this.schema = Ornaments.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Ornaments.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Ornaments.schema.contents);
    }
    /** Gets @type {OrnamentsAttributes['id']}. */
    Ornaments.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {OrnamentsAttributes['id']}. */
    Ornaments.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {Array<TrillMark | Turn | DelayedTurn | InvertedTurn | DelayedInvertedTurn | VerticalTurn | InvertedVerticalTurn | Shake | WavyLine | Mordent | InvertedMordent | Schleifer | Tremolo | Haydn | OtherOrnament>}. */
    Ornaments.prototype.getValues = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<TrillMark | Turn | DelayedTurn | InvertedTurn | DelayedInvertedTurn | VerticalTurn | InvertedVerticalTurn | Shake | WavyLine | Mordent | InvertedMordent | Schleifer | Tremolo | Haydn | OtherOrnament>}. */
    Ornaments.prototype.setValues = function (values) {
        this.contents[0] = values;
        return this;
    };
    /** Gets @type {Array<AccidentalMark>}. */
    Ornaments.prototype.getAccidentalMarks = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<AccidentalMark>}. */
    Ornaments.prototype.setAccidentalMarks = function (accidentalMarks) {
        this.contents[1] = accidentalMarks;
        return this;
    };
    Ornaments.schema = {
        name: 'ornaments',
        attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [
            {
                type: 'label',
                label: 'values',
                value: {
                    type: 'zeroOrMore',
                    value: {
                        type: 'choices',
                        choices: [
                            TrillMark,
                            Turn,
                            DelayedTurn,
                            InvertedTurn,
                            DelayedInvertedTurn,
                            VerticalTurn,
                            InvertedVerticalTurn,
                            Shake,
                            WavyLine,
                            Mordent,
                            InvertedMordent,
                            Schleifer,
                            Tremolo,
                            Haydn,
                            OtherOrnament,
                        ],
                    },
                },
            },
            { type: 'label', label: 'accidental-marks', value: { type: 'zeroOrMore', value: AccidentalMark } },
        ],
    };
    return Ornaments;
}());
exports.Ornaments = Ornaments;
/**
 * The `<up-bow>` element
 *
 * Parent element: `<technical>`
 *
 * The `<up-bow>` element represents the symbol that is used both for up-bowing on bowed instruments, and up-stroke on
 * plucked instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/up-bow/}
 */
var UpBow = /** @class */ (function () {
    function UpBow(opts) {
        var _a;
        this.schema = UpBow.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, UpBow.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(UpBow.schema.contents);
    }
    /** Gets @type {UpBowAttributes['color']}. */
    UpBow.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {UpBowAttributes['color']}. */
    UpBow.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {UpBowAttributes['default-x']}. */
    UpBow.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {UpBowAttributes['default-x']}. */
    UpBow.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {UpBowAttributes['default-y']}. */
    UpBow.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {UpBowAttributes['default-y']}. */
    UpBow.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {UpBowAttributes['font-family']}. */
    UpBow.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {UpBowAttributes['font-family']}. */
    UpBow.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {UpBowAttributes['font-size']}. */
    UpBow.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {UpBowAttributes['font-size']}. */
    UpBow.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {UpBowAttributes['font-style']}. */
    UpBow.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {UpBowAttributes['font-style']}. */
    UpBow.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {UpBowAttributes['font-weight']}. */
    UpBow.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {UpBowAttributes['font-weight']}. */
    UpBow.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {UpBowAttributes['placement']}. */
    UpBow.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {UpBowAttributes['placement']}. */
    UpBow.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {UpBowAttributes['relative-x']}. */
    UpBow.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {UpBowAttributes['relative-x']}. */
    UpBow.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {UpBowAttributes['relative-y']}. */
    UpBow.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {UpBowAttributes['relative-y']}. */
    UpBow.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    UpBow.schema = {
        name: 'up-bow',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return UpBow;
}());
exports.UpBow = UpBow;
/**
 * The `<down-bow> element
 *
 * Parent element: `<technical>
 *
 * The `<down-bow> element represents the symbol that is used both for down-bowing on bowed instruments, and down-stroke
 * on plucked instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/down-bow/}
 */
var DownBow = /** @class */ (function () {
    function DownBow(opts) {
        var _a;
        this.schema = DownBow.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DownBow.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DownBow.schema.contents);
    }
    /** Gets @type {DownBowAttributes['color']}. */
    DownBow.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DownBowAttributes['color']}. */
    DownBow.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DownBowAttributes['default-x']}. */
    DownBow.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DownBowAttributes['default-x']}. */
    DownBow.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DownBowAttributes['default-y']}. */
    DownBow.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DownBowAttributes['default-y']}. */
    DownBow.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DownBowAttributes['font-family']}. */
    DownBow.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DownBowAttributes['font-family']}. */
    DownBow.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DownBowAttributes['font-size']}. */
    DownBow.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DownBowAttributes['font-size']}. */
    DownBow.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DownBowAttributes['font-style']}. */
    DownBow.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DownBowAttributes['font-style']}. */
    DownBow.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DownBowAttributes['font-weight']}. */
    DownBow.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DownBowAttributes['font-weight']}. */
    DownBow.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DownBowAttributes['placement']}. */
    DownBow.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {DownBowAttributes['placement']}. */
    DownBow.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {DownBowAttributes['relative-x']}. */
    DownBow.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DownBowAttributes['relative-x']}. */
    DownBow.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DownBowAttributes['relative-y']}. */
    DownBow.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DownBowAttributes['relative-y']}. */
    DownBow.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    DownBow.schema = {
        name: 'down-bow',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return DownBow;
}());
exports.DownBow = DownBow;
/**
 * The `<natural>` element
 *
 * Parent element: `<harmonic>`
 *
 * The `<natural>` element indicates that this is a natural harmonic. These are usually notated at base pitch rather
 * than sounding pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/natural/}
 */
var Natural = /** @class */ (function () {
    function Natural(opts) {
        var _a;
        this.schema = Natural.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Natural.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Natural.schema.contents);
    }
    Natural.schema = { name: 'natural', attributes: {}, contents: [] };
    return Natural;
}());
exports.Natural = Natural;
/**
 * The `<artificial>` element
 *
 * Parent element: `<harmonic>`
 *
 * The `<artificial>` element indicates that this is an artificial harmonic.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/artificial/}
 */
var Artificial = /** @class */ (function () {
    function Artificial(opts) {
        var _a;
        this.schema = Artificial.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Artificial.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Artificial.schema.contents);
    }
    Artificial.schema = { name: 'artificial', attributes: {}, contents: [] };
    return Artificial;
}());
exports.Artificial = Artificial;
/**
 * The `<base-pitch>` element
 *
 * Parent element: `<harmonic>`
 *
 * The presence of the `<base-pitch>` element indicates this is the pitch at which the string is played before touching
 * to create the harmonic.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/base-pitch/}
 */
var BasePitch = /** @class */ (function () {
    function BasePitch(opts) {
        var _a;
        this.schema = BasePitch.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BasePitch.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BasePitch.schema.contents);
    }
    BasePitch.schema = { name: 'base-pitch', attributes: {}, contents: [] };
    return BasePitch;
}());
exports.BasePitch = BasePitch;
/**
 * The `<touching-pitch>` element
 *
 * Parent element: `<harmonic>`
 *
 * The presence of the `<touching-pitch>` element indicates this is the pitch at which the string is touched lightly to
 * produce the harmonic.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/touching-pitch/}
 */
var TouchingPitch = /** @class */ (function () {
    function TouchingPitch(opts) {
        var _a;
        this.schema = TouchingPitch.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TouchingPitch.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TouchingPitch.schema.contents);
    }
    TouchingPitch.schema = { name: 'touching-pitch', attributes: {}, contents: [] };
    return TouchingPitch;
}());
exports.TouchingPitch = TouchingPitch;
/**
 * The `<sounding-pitch>` element
 *
 * Parent element: `<harmonic>`
 *
 * The presence of the `<sounding-pitch>` element indicates this is the pitch which is heard when playing the harmonic.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sounding-pitch/}
 */
var SoundingPitch = /** @class */ (function () {
    function SoundingPitch(opts) {
        var _a;
        this.schema = SoundingPitch.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SoundingPitch.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SoundingPitch.schema.contents);
    }
    SoundingPitch.schema = { name: 'sounding-pitch', attributes: {}, contents: [] };
    return SoundingPitch;
}());
exports.SoundingPitch = SoundingPitch;
/**
 * The `<harmonic>` element
 *
 * Parent element: `<technical>`
 *
 * The `<harmonic>` element indicates natural and artificial harmonics. Allowing the type of pitch to be specified,
 * combined with controls for appearance/playback differences, allows both the notation and the sound to be represented.
 * Artificial harmonics can add a notated touching pitch; artificial pinch harmonics will usually not notate a touching
 * pitch. The attributes for the `<harmonic>` element refer to the use of the circular harmonic symbol, typically but
 * not always used with natural harmonics.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/harmonic/}
 */
var Harmonic = /** @class */ (function () {
    function Harmonic(opts) {
        var _a;
        this.schema = Harmonic.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Harmonic.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Harmonic.schema.contents);
    }
    /** Gets @type {HarmonicAttributes['color']}. */
    Harmonic.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {HarmonicAttributes['color']}. */
    Harmonic.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {HarmonicAttributes['default-x']}. */
    Harmonic.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {HarmonicAttributes['default-x']}. */
    Harmonic.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {HarmonicAttributes['default-y']}. */
    Harmonic.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {HarmonicAttributes['default-y']}. */
    Harmonic.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {HarmonicAttributes['font-family']}. */
    Harmonic.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {HarmonicAttributes['font-family']}. */
    Harmonic.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {HarmonicAttributes['font-size']}. */
    Harmonic.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {HarmonicAttributes['font-size']}. */
    Harmonic.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {HarmonicAttributes['font-style']}. */
    Harmonic.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {HarmonicAttributes['font-style']}. */
    Harmonic.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {HarmonicAttributes['font-weight']}. */
    Harmonic.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {HarmonicAttributes['font-weight']}. */
    Harmonic.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {HarmonicAttributes['placement']}. */
    Harmonic.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {HarmonicAttributes['placement']}. */
    Harmonic.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {HarmonicAttributes['print-object']}. */
    Harmonic.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {HarmonicAttributes['print-object']}. */
    Harmonic.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {HarmonicAttributes['relative-x']}. */
    Harmonic.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {HarmonicAttributes['relative-x']}. */
    Harmonic.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {HarmonicAttributes['relative-y']}. */
    Harmonic.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {HarmonicAttributes['relative-y']}. */
    Harmonic.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {Array<Natural | Artificial>}. */
    Harmonic.prototype.getTypes = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Natural | Artificial>}. */
    Harmonic.prototype.setTypes = function (types) {
        this.contents[0] = types;
        return this;
    };
    /** Gets @type {Array<BasePitch | TouchingPitch | SoundingPitch>}. */
    Harmonic.prototype.getPitches = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<BasePitch | TouchingPitch | SoundingPitch>}. */
    Harmonic.prototype.setPitches = function (pitches) {
        this.contents[1] = pitches;
        return this;
    };
    Harmonic.schema = {
        name: 'harmonic',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [
            {
                type: 'label',
                label: 'types',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Natural, Artificial] } },
            },
            {
                type: 'label',
                label: 'pitches',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [BasePitch, TouchingPitch, SoundingPitch] } },
            },
        ],
    };
    return Harmonic;
}());
exports.Harmonic = Harmonic;
/**
 * The `<open-string>`   element
 *
 * Parent element: `<technical>`
 *
 * The `<open-string>` element represents the zero-shaped open string symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/open-string/}
 */
var OpenString = /** @class */ (function () {
    function OpenString(opts) {
        var _a;
        this.schema = OpenString.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OpenString.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OpenString.schema.contents);
    }
    /** Gets @type {OpenStringAttributes['color']}. */
    OpenString.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {OpenStringAttributes['color']}. */
    OpenString.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {OpenStringAttributes['default-x']}. */
    OpenString.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {OpenStringAttributes['default-x']}. */
    OpenString.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {OpenStringAttributes['default-y']}. */
    OpenString.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {OpenStringAttributes['default-y']}. */
    OpenString.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {OpenStringAttributes['font-family']}. */
    OpenString.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {OpenStringAttributes['font-family']}. */
    OpenString.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {OpenStringAttributes['font-size']}. */
    OpenString.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {OpenStringAttributes['font-size']}. */
    OpenString.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {OpenStringAttributes['font-style']}. */
    OpenString.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {OpenStringAttributes['font-style']}. */
    OpenString.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {OpenStringAttributes['font-weight']}. */
    OpenString.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {OpenStringAttributes['font-weight']}. */
    OpenString.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {OpenStringAttributes['placement']}. */
    OpenString.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {OpenStringAttributes['placement']}. */
    OpenString.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {OpenStringAttributes['relative-x']}. */
    OpenString.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {OpenStringAttributes['relative-x']}. */
    OpenString.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {OpenStringAttributes['relative-y']}. */
    OpenString.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {OpenStringAttributes['relative-y']}. */
    OpenString.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    OpenString.schema = {
        name: 'open-string',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return OpenString;
}());
exports.OpenString = OpenString;
/**
 * The `<thumb-position>` element
 *
 * Parent element: `<technical>`
 *
 * The `<thumb-position>` element represents the thumb position symbol. This is a circle with a line, where the line
 * does not come within the circle. It is distinct from the `<snap-pizzicato>` symbol, where the line comes inside the
 * circle.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/thumb-position/}
 */
var ThumbPosition = /** @class */ (function () {
    function ThumbPosition(opts) {
        var _a;
        this.schema = ThumbPosition.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ThumbPosition.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ThumbPosition.schema.contents);
    }
    /** Gets @type {ThumbPositionAttributes['color']}. */
    ThumbPosition.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {ThumbPositionAttributes['color']}. */
    ThumbPosition.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {ThumbPositionAttributes['default-x']}. */
    ThumbPosition.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {ThumbPositionAttributes['default-x']}. */
    ThumbPosition.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {ThumbPositionAttributes['default-y']}. */
    ThumbPosition.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {ThumbPositionAttributes['default-y']}. */
    ThumbPosition.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {ThumbPositionAttributes['font-family']}. */
    ThumbPosition.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {ThumbPositionAttributes['font-family']}. */
    ThumbPosition.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {ThumbPositionAttributes['font-size']}. */
    ThumbPosition.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {ThumbPositionAttributes['font-size']}. */
    ThumbPosition.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {ThumbPositionAttributes['font-style']}. */
    ThumbPosition.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {ThumbPositionAttributes['font-style']}. */
    ThumbPosition.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {ThumbPositionAttributes['font-weight']}. */
    ThumbPosition.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {ThumbPositionAttributes['font-weight']}. */
    ThumbPosition.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {ThumbPositionAttributes['placement']}. */
    ThumbPosition.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {ThumbPositionAttributes['placement']}. */
    ThumbPosition.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {ThumbPositionAttributes['relative-x']}. */
    ThumbPosition.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {ThumbPositionAttributes['relative-x']}. */
    ThumbPosition.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {ThumbPositionAttributes['relative-y']}. */
    ThumbPosition.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {ThumbPositionAttributes['relative-y']}. */
    ThumbPosition.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    ThumbPosition.schema = {
        name: 'thumb-position',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return ThumbPosition;
}());
exports.ThumbPosition = ThumbPosition;
/**
 * The `<fingering>` element
 *
 * Parent elements: `<frame-note>`, `<technical>`
 *
 * Fingering is typically indicated 1,2,3,4,5. Multiple fingerings may be given, typically to substitute fingerings in
 * the middle of a note. For guitar and other fretted instruments, the `<fingering>` element represents the fretting
 * finger; the `<pluck>` element represents the plucking finger.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fingering/}
 */
var Fingering = /** @class */ (function () {
    function Fingering(opts) {
        var _a;
        this.schema = Fingering.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Fingering.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Fingering.schema.contents);
    }
    /** Gets @type {FingeringAttributes['alternate']}. */
    Fingering.prototype.getAlternate = function () {
        return this.attributes['alternate'];
    };
    /** Sets @type {FingeringAttributes['alternate']}. */
    Fingering.prototype.setAlternate = function (alternate) {
        this.attributes['alternate'] = alternate;
        return this;
    };
    /** Gets @type {FingeringAttributes['color']}. */
    Fingering.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FingeringAttributes['color']}. */
    Fingering.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FingeringAttributes['default-x']}. */
    Fingering.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {FingeringAttributes['default-x']}. */
    Fingering.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {FingeringAttributes['default-y']}. */
    Fingering.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {FingeringAttributes['default-y']}. */
    Fingering.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {FingeringAttributes['font-family']}. */
    Fingering.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FingeringAttributes['font-family']}. */
    Fingering.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FingeringAttributes['font-size']}. */
    Fingering.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FingeringAttributes['font-size']}. */
    Fingering.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FingeringAttributes['font-style']}. */
    Fingering.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FingeringAttributes['font-style']}. */
    Fingering.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FingeringAttributes['font-weight']}. */
    Fingering.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FingeringAttributes['font-weight']}. */
    Fingering.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {FingeringAttributes['placement']}. */
    Fingering.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {FingeringAttributes['placement']}. */
    Fingering.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {FingeringAttributes['relative-x']}. */
    Fingering.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {FingeringAttributes['relative-x']}. */
    Fingering.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {FingeringAttributes['relative-y']}. */
    Fingering.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {FingeringAttributes['relative-y']}. */
    Fingering.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {FingeringAttributes['substitution']}. */
    Fingering.prototype.getSubstitution = function () {
        return this.attributes['substitution'];
    };
    /** Sets @type {FingeringAttributes['substitution']}. */
    Fingering.prototype.setSubstitution = function (substitution) {
        this.attributes['substitution'] = substitution;
        return this;
    };
    /** Gets @type {string}. */
    Fingering.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Fingering.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Fingering.schema = {
        name: 'fingering',
        attributes: {
            alternate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            substitution: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
        },
        contents: [{ type: 'string' }],
    };
    return Fingering;
}());
exports.Fingering = Fingering;
/**
 * The `<pluck>` element
 *
 * Parent element: `<technical>`
 *
 * The `<pluck>` element is used to specify the plucking fingering on a fretted instrument, where the fingering element
 * refers to the fretting fingering. Typical values are p, i, m, a for pulgar/thumb, indicio/index, medio/middle, and
 * anular/ring fingers.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pluck/}
 */
var Pluck = /** @class */ (function () {
    function Pluck(opts) {
        var _a;
        this.schema = Pluck.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Pluck.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Pluck.schema.contents);
    }
    /** Gets @type {PluckAttributes['color']}. */
    Pluck.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {PluckAttributes['color']}. */
    Pluck.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {PluckAttributes['default-x']}. */
    Pluck.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {PluckAttributes['default-x']}. */
    Pluck.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {PluckAttributes['default-y']}. */
    Pluck.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {PluckAttributes['default-y']}. */
    Pluck.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {PluckAttributes['font-family']}. */
    Pluck.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PluckAttributes['font-family']}. */
    Pluck.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PluckAttributes['font-size']}. */
    Pluck.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PluckAttributes['font-size']}. */
    Pluck.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PluckAttributes['font-style']}. */
    Pluck.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PluckAttributes['font-style']}. */
    Pluck.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PluckAttributes['font-weight']}. */
    Pluck.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PluckAttributes['font-weight']}. */
    Pluck.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {PluckAttributes['placement']}. */
    Pluck.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {PluckAttributes['placement']}. */
    Pluck.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {PluckAttributes['relative-x']}. */
    Pluck.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {PluckAttributes['relative-x']}. */
    Pluck.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {PluckAttributes['relative-y']}. */
    Pluck.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {PluckAttributes['relative-y']}. */
    Pluck.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    Pluck.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Pluck.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Pluck.schema = {
        name: 'pluck',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Pluck;
}());
exports.Pluck = Pluck;
/**
 * The `<double-tongue>` element
 *
 * Parent element: `<technical>`
 *
 * The `<double-tongue>` element represents the double tongue symbol (two dots arranged horizontally).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/double-tongue/}
 */
var DoubleTongue = /** @class */ (function () {
    function DoubleTongue(opts) {
        var _a;
        this.schema = DoubleTongue.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DoubleTongue.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DoubleTongue.schema.contents);
    }
    /** Gets @type {DoubleTongueAttributes['color']}. */
    DoubleTongue.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DoubleTongueAttributes['color']}. */
    DoubleTongue.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DoubleTongueAttributes['default-x']}. */
    DoubleTongue.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DoubleTongueAttributes['default-x']}. */
    DoubleTongue.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DoubleTongueAttributes['default-y']}. */
    DoubleTongue.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DoubleTongueAttributes['default-y']}. */
    DoubleTongue.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DoubleTongueAttributes['font-family']}. */
    DoubleTongue.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DoubleTongueAttributes['font-family']}. */
    DoubleTongue.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DoubleTongueAttributes['font-size']}. */
    DoubleTongue.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DoubleTongueAttributes['font-size']}. */
    DoubleTongue.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DoubleTongueAttributes['font-style']}. */
    DoubleTongue.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DoubleTongueAttributes['font-style']}. */
    DoubleTongue.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DoubleTongueAttributes['font-weight']}. */
    DoubleTongue.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DoubleTongueAttributes['font-weight']}. */
    DoubleTongue.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DoubleTongueAttributes['placement']}. */
    DoubleTongue.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {DoubleTongueAttributes['placement']}. */
    DoubleTongue.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {DoubleTongueAttributes['relative-x']}. */
    DoubleTongue.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DoubleTongueAttributes['relative-x']}. */
    DoubleTongue.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DoubleTongueAttributes['relative-y']}. */
    DoubleTongue.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DoubleTongueAttributes['relative-y']}. */
    DoubleTongue.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    DoubleTongue.schema = {
        name: 'double-tongue',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return DoubleTongue;
}());
exports.DoubleTongue = DoubleTongue;
/**
 * The `<triple-tongue>` element
 *
 * Parent element: `<technical>`
 *
 * The `<triple-tongue>` element represents the triple tongue symbol (three dots arranged horizontally).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/triple-tongue/}
 */
var TripleTongue = /** @class */ (function () {
    function TripleTongue(opts) {
        var _a;
        this.schema = TripleTongue.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TripleTongue.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TripleTongue.schema.contents);
    }
    /** Gets @type {TripleTongueAttributes['color']}. */
    TripleTongue.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TripleTongueAttributes['color']}. */
    TripleTongue.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TripleTongueAttributes['default-x']}. */
    TripleTongue.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {TripleTongueAttributes['default-x']}. */
    TripleTongue.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {TripleTongueAttributes['default-y']}. */
    TripleTongue.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {TripleTongueAttributes['default-y']}. */
    TripleTongue.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {TripleTongueAttributes['font-family']}. */
    TripleTongue.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TripleTongueAttributes['font-family']}. */
    TripleTongue.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TripleTongueAttributes['font-size']}. */
    TripleTongue.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TripleTongueAttributes['font-size']}. */
    TripleTongue.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TripleTongueAttributes['font-style']}. */
    TripleTongue.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TripleTongueAttributes['font-style']}. */
    TripleTongue.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TripleTongueAttributes['font-weight']}. */
    TripleTongue.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TripleTongueAttributes['font-weight']}. */
    TripleTongue.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {TripleTongueAttributes['placement']}. */
    TripleTongue.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {TripleTongueAttributes['placement']}. */
    TripleTongue.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {TripleTongueAttributes['relative-x']}. */
    TripleTongue.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {TripleTongueAttributes['relative-x']}. */
    TripleTongue.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {TripleTongueAttributes['relative-y']}. */
    TripleTongue.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {TripleTongueAttributes['relative-y']}. */
    TripleTongue.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    TripleTongue.schema = {
        name: 'triple-tongue',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return TripleTongue;
}());
exports.TripleTongue = TripleTongue;
/**
 * The `<stopped>` element
 *
 * Parent element: `<technical>`
 *
 * The `<stopped>` element represents the stopped symbol, which looks like a plus sign. The smufl attribute
 * distinguishes different Standard Music Font Layout (SMuFL) glyphs that have a similar appearance such as
 * handbellsMalletBellSuspended and guitarClosePedal. If not present, the default glyph is brassMuteClosed.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stopped/}
 */
var Stopped = /** @class */ (function () {
    function Stopped(opts) {
        var _a;
        this.schema = Stopped.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Stopped.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Stopped.schema.contents);
    }
    /** Gets @type {StoppedAttributes['color']}. */
    Stopped.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {StoppedAttributes['color']}. */
    Stopped.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {StoppedAttributes['default-x']}. */
    Stopped.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {StoppedAttributes['default-x']}. */
    Stopped.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {StoppedAttributes['default-y']}. */
    Stopped.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {StoppedAttributes['default-y']}. */
    Stopped.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {StoppedAttributes['font-family']}. */
    Stopped.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {StoppedAttributes['font-family']}. */
    Stopped.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {StoppedAttributes['font-size']}. */
    Stopped.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {StoppedAttributes['font-size']}. */
    Stopped.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {StoppedAttributes['font-style']}. */
    Stopped.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {StoppedAttributes['font-style']}. */
    Stopped.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {StoppedAttributes['font-weight']}. */
    Stopped.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {StoppedAttributes['font-weight']}. */
    Stopped.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {StoppedAttributes['placement']}. */
    Stopped.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {StoppedAttributes['placement']}. */
    Stopped.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {StoppedAttributes['relative-x']}. */
    Stopped.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {StoppedAttributes['relative-x']}. */
    Stopped.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {StoppedAttributes['relative-y']}. */
    Stopped.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {StoppedAttributes['relative-y']}. */
    Stopped.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Stopped.schema = {
        name: 'stopped',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Stopped;
}());
exports.Stopped = Stopped;
/**
 * The `<snap-pizzicato>` element
 *
 * Parent element: `<technical>`
 *
 * The `<snap-pizzicato>` element represents the snap pizzicato symbol. This is a circle with a line, where the line
 * comes inside the circle. It is distinct from the `<thumb-position>` symbol, where the line does not come inside the
 * circle.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/snap-pizzicato/}
 */
var SnapPizzicato = /** @class */ (function () {
    function SnapPizzicato(opts) {
        var _a;
        this.schema = SnapPizzicato.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SnapPizzicato.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SnapPizzicato.schema.contents);
    }
    /** Gets @type {SnapPizzicatoAttributes['color']}. */
    SnapPizzicato.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {SnapPizzicatoAttributes['color']}. */
    SnapPizzicato.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {SnapPizzicatoAttributes['default-x']}. */
    SnapPizzicato.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {SnapPizzicatoAttributes['default-x']}. */
    SnapPizzicato.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {SnapPizzicatoAttributes['default-y']}. */
    SnapPizzicato.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {SnapPizzicatoAttributes['default-y']}. */
    SnapPizzicato.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {SnapPizzicatoAttributes['font-family']}. */
    SnapPizzicato.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {SnapPizzicatoAttributes['font-family']}. */
    SnapPizzicato.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {SnapPizzicatoAttributes['font-size']}. */
    SnapPizzicato.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {SnapPizzicatoAttributes['font-size']}. */
    SnapPizzicato.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {SnapPizzicatoAttributes['font-style']}. */
    SnapPizzicato.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {SnapPizzicatoAttributes['font-style']}. */
    SnapPizzicato.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {SnapPizzicatoAttributes['font-weight']}. */
    SnapPizzicato.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {SnapPizzicatoAttributes['font-weight']}. */
    SnapPizzicato.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {SnapPizzicatoAttributes['placement']}. */
    SnapPizzicato.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {SnapPizzicatoAttributes['placement']}. */
    SnapPizzicato.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {SnapPizzicatoAttributes['relative-x']}. */
    SnapPizzicato.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {SnapPizzicatoAttributes['relative-x']}. */
    SnapPizzicato.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {SnapPizzicatoAttributes['relative-y']}. */
    SnapPizzicato.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {SnapPizzicatoAttributes['relative-y']}. */
    SnapPizzicato.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    SnapPizzicato.schema = {
        name: 'snap-pizzicato',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return SnapPizzicato;
}());
exports.SnapPizzicato = SnapPizzicato;
/**
 * The `<fret>` element
 *
 * Parent elements: `<frame-note>`, `<technical>`
 *
 * The `<fret>` element is used with tablature notation and chord diagrams. Fret numbers start with 0 for an open string
 * and 1 for the first fret.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fret/}
 */
var Fret = /** @class */ (function () {
    function Fret(opts) {
        var _a;
        this.schema = Fret.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Fret.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Fret.schema.contents);
    }
    /** Gets @type {FretAttributes['color']}. */
    Fret.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FretAttributes['color']}. */
    Fret.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FretAttributes['font-family']}. */
    Fret.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FretAttributes['font-family']}. */
    Fret.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FretAttributes['font-size']}. */
    Fret.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FretAttributes['font-size']}. */
    Fret.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FretAttributes['font-style']}. */
    Fret.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FretAttributes['font-style']}. */
    Fret.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FretAttributes['font-weight']}. */
    Fret.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FretAttributes['font-weight']}. */
    Fret.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {number}. */
    Fret.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Fret.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Fret.schema = {
        name: 'fret',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
        },
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
        ],
    };
    return Fret;
}());
exports.Fret = Fret;
/**
 * The `<string>` element
 *
 * Parent elements: `<frame-note>`, `<technical>`
 *
 * The `<string>` element is used with tablature notation, regular notation (where it is often circled), and chord
 * diagrams. String numbers start with 1 for the highest pitched full-length string.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/string/}
 */
var String = /** @class */ (function () {
    function String(opts) {
        var _a;
        this.schema = String.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, String.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(String.schema.contents);
    }
    /** Gets @type {StringAttributes['color']}. */
    String.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {StringAttributes['color']}. */
    String.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {StringAttributes['default-x']}. */
    String.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {StringAttributes['default-x']}. */
    String.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {StringAttributes['default-y']}. */
    String.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {StringAttributes['default-y']}. */
    String.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {StringAttributes['font-family']}. */
    String.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {StringAttributes['font-family']}. */
    String.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {StringAttributes['font-size']}. */
    String.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {StringAttributes['font-size']}. */
    String.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {StringAttributes['font-style']}. */
    String.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {StringAttributes['font-style']}. */
    String.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {StringAttributes['font-weight']}. */
    String.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {StringAttributes['font-weight']}. */
    String.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {StringAttributes['placement']}. */
    String.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {StringAttributes['placement']}. */
    String.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {StringAttributes['relative-x']}. */
    String.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {StringAttributes['relative-x']}. */
    String.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {StringAttributes['relative-y']}. */
    String.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {StringAttributes['relative-y']}. */
    String.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {number}. */
    String.prototype.getStringNumber = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    String.prototype.setStringNumber = function (stringNumber) {
        this.contents[0] = stringNumber;
        return this;
    };
    String.schema = {
        name: 'string',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'label', label: 'string-number', value: { type: 'int', min: 1, max: Infinity } }],
    };
    return String;
}());
exports.String = String;
/**
 * The `<hammer-on>` element
 *
 * Parent element: `<technical>`
 *
 * The `<hammer-on>` element is used in guitar and fretted instrument notation. Since a single slur can be marked over many notes, the `<hammer-on>` element is separate so the individual pair of notes can be specified. The element content can be used to specify how the `<hammer-on>` should be notated. An empty element leaves this choice up to the application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/hammer-on/}
 */
var HammerOn = /** @class */ (function () {
    function HammerOn(opts) {
        var _a;
        this.schema = HammerOn.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, HammerOn.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(HammerOn.schema.contents);
    }
    /** Gets @type {HammerOnAttributes['type']}. */
    HammerOn.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {HammerOnAttributes['type']}. */
    HammerOn.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {HammerOnAttributes['color']}. */
    HammerOn.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {HammerOnAttributes['color']}. */
    HammerOn.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {HammerOnAttributes['default-x']}. */
    HammerOn.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {HammerOnAttributes['default-x']}. */
    HammerOn.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {HammerOnAttributes['default-y']}. */
    HammerOn.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {HammerOnAttributes['default-y']}. */
    HammerOn.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {HammerOnAttributes['font-family']}. */
    HammerOn.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {HammerOnAttributes['font-family']}. */
    HammerOn.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {HammerOnAttributes['font-size']}. */
    HammerOn.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {HammerOnAttributes['font-size']}. */
    HammerOn.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {HammerOnAttributes['font-style']}. */
    HammerOn.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {HammerOnAttributes['font-style']}. */
    HammerOn.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {HammerOnAttributes['font-weight']}. */
    HammerOn.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {HammerOnAttributes['font-weight']}. */
    HammerOn.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {HammerOnAttributes['number']}. */
    HammerOn.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {HammerOnAttributes['number']}. */
    HammerOn.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {HammerOnAttributes['placement']}. */
    HammerOn.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {HammerOnAttributes['placement']}. */
    HammerOn.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {HammerOnAttributes['relative-x']}. */
    HammerOn.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {HammerOnAttributes['relative-x']}. */
    HammerOn.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {HammerOnAttributes['relative-y']}. */
    HammerOn.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {HammerOnAttributes['relative-y']}. */
    HammerOn.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    HammerOn.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    HammerOn.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    HammerOn.schema = {
        name: 'hammer-on',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return HammerOn;
}());
exports.HammerOn = HammerOn;
/**
 * The `<pull-off>` element
 *
 * Parent element: `<technical>`
 *
 * The `<pull-off>` element is used in guitar and fretted instrument notation. Since a single slur can be marked over
 * many notes, the `<pull-off>` element is separate so the individual pair of notes can be specified. The element
 * content can be used to specify how the `<pull-off>` should be notated. An empty element leaves this choice up to the
 * application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pull-off/}
 */
var PullOff = /** @class */ (function () {
    function PullOff(opts) {
        var _a;
        this.schema = PullOff.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PullOff.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PullOff.schema.contents);
    }
    /** Gets @type {PullOffAttributes['type']}. */
    PullOff.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {PullOffAttributes['type']}. */
    PullOff.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {PullOffAttributes['color']}. */
    PullOff.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {PullOffAttributes['color']}. */
    PullOff.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {PullOffAttributes['default-x']}. */
    PullOff.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {PullOffAttributes['default-x']}. */
    PullOff.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {PullOffAttributes['default-y']}. */
    PullOff.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {PullOffAttributes['default-y']}. */
    PullOff.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {PullOffAttributes['font-family']}. */
    PullOff.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PullOffAttributes['font-family']}. */
    PullOff.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PullOffAttributes['font-size']}. */
    PullOff.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PullOffAttributes['font-size']}. */
    PullOff.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PullOffAttributes['font-style']}. */
    PullOff.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PullOffAttributes['font-style']}. */
    PullOff.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PullOffAttributes['font-weight']}. */
    PullOff.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PullOffAttributes['font-weight']}. */
    PullOff.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {PullOffAttributes['number']}. */
    PullOff.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {PullOffAttributes['number']}. */
    PullOff.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {PullOffAttributes['placement']}. */
    PullOff.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {PullOffAttributes['placement']}. */
    PullOff.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {PullOffAttributes['relative-x']}. */
    PullOff.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {PullOffAttributes['relative-x']}. */
    PullOff.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {PullOffAttributes['relative-y']}. */
    PullOff.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {PullOffAttributes['relative-y']}. */
    PullOff.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    PullOff.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    PullOff.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    PullOff.schema = {
        name: 'pull-off',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'string' }],
    };
    return PullOff;
}());
exports.PullOff = PullOff;
/**
 * The `<bend-alter>` element
 *
 * Parent element: `<bend>`
 *
 * The `<bend-alter>` element indicates the number of semitones in the bend, similar to the `<alter>` element. As with
 * the `<alter>` element, numbers like 0.5 can be used to indicate microtones. Negative values indicate pre-bends or
 * releases. The `<pre-bend>` and `<release>` elements are used to distinguish what is intended. Because the
 * `<bend-alter>` element represents the number of steps in the bend, a release after a bend has a negative
 * `<bend-alter>` value, not a zero value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bend-alter/}
 */
var BendAlter = /** @class */ (function () {
    function BendAlter(opts) {
        var _a;
        this.schema = BendAlter.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BendAlter.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BendAlter.schema.contents);
    }
    /** Gets @type {number}. */
    BendAlter.prototype.getSemitones = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    BendAlter.prototype.setSemitones = function (semitones) {
        this.contents[0] = semitones;
        return this;
    };
    BendAlter.schema = {
        name: 'bend-alter',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return BendAlter;
}());
exports.BendAlter = BendAlter;
/**
 * The `<pre-bend> element
 *
 * Parent element: `<bend>
 *
 * The `<pre-bend> element indicates that a bend is a pre-bend rather than a normal bend or a release.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pre-bend/}
 */
var PreBend = /** @class */ (function () {
    function PreBend(opts) {
        var _a;
        this.schema = PreBend.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PreBend.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PreBend.schema.contents);
    }
    PreBend.schema = { name: 'pre-bend', attributes: {}, contents: [] };
    return PreBend;
}());
exports.PreBend = PreBend;
/**
 * The `<release>` element
 *
 * Parent element: `<bend>`
 *
 * The `<release>` element indicates that a bend is a release rather than a normal bend or pre-bend. The first-beat and
 * last-beat attributes of the parent `<bend>` element are relative to the original note position, not this offset
 * value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/release/}
 */
var Release = /** @class */ (function () {
    function Release(opts) {
        var _a;
        this.schema = Release.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Release.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Release.schema.contents);
    }
    /** Gets @type {ReleaseAttributes['offset']}. */
    Release.prototype.getOffset = function () {
        return this.attributes['offset'];
    };
    /** Sets @type {ReleaseAttributes['offset']}. */
    Release.prototype.setOffset = function (offset) {
        this.attributes['offset'] = offset;
        return this;
    };
    Release.schema = {
        name: 'release',
        attributes: { offset: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } } },
        contents: [],
    };
    return Release;
}());
exports.Release = Release;
/**
 * The `<with-bar>` element
 *
 * Parent element: `<bend>`
 *
 * The `<with-bar>` element indicates that the bend is to be done at the bridge with a whammy or vibrato bar. The
 * content of the element indicates how this should be notated. Content values of "scoop" and "dip" refer to the
 * Standard Music Font Layout (SMuFL) guitarVibratoBarScoop and guitarVibratoBarDip glyphs.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/with-bar/}
 */
var WithBar = /** @class */ (function () {
    function WithBar(opts) {
        var _a;
        this.schema = WithBar.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, WithBar.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(WithBar.schema.contents);
    }
    /** Gets @type {WithBarAttributes['color']}. */
    WithBar.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {WithBarAttributes['color']}. */
    WithBar.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {WithBarAttributes['default-x']}. */
    WithBar.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {WithBarAttributes['default-x']}. */
    WithBar.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {WithBarAttributes['default-y']}. */
    WithBar.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {WithBarAttributes['default-y']}. */
    WithBar.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {WithBarAttributes['first-beat']}. */
    WithBar.prototype.getFirstBeat = function () {
        return this.attributes['first-beat'];
    };
    /** Sets @type {WithBarAttributes['first-beat']}. */
    WithBar.prototype.setFirstBeat = function (firstBeat) {
        this.attributes['first-beat'] = firstBeat;
        return this;
    };
    /** Gets @type {WithBarAttributes['font-family']}. */
    WithBar.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {WithBarAttributes['font-family']}. */
    WithBar.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {WithBarAttributes['font-size']}. */
    WithBar.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {WithBarAttributes['font-size']}. */
    WithBar.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {WithBarAttributes['font-style']}. */
    WithBar.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {WithBarAttributes['font-style']}. */
    WithBar.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {WithBarAttributes['font-weight']}. */
    WithBar.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {WithBarAttributes['font-weight']}. */
    WithBar.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {WithBarAttributes['placement']}. */
    WithBar.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {WithBarAttributes['placement']}. */
    WithBar.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {WithBarAttributes['relative-x']}. */
    WithBar.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {WithBarAttributes['relative-x']}. */
    WithBar.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {WithBarAttributes['relative-y']}. */
    WithBar.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {WithBarAttributes['relative-y']}. */
    WithBar.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    WithBar.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    WithBar.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    WithBar.schema = {
        name: 'with-bar',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'first-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return WithBar;
}());
exports.WithBar = WithBar;
/**
 * The `<bend>` element
 *
 * Parent element: `<technical>`
 *
 * The `<bend>` element is used in guitar notation and tablature. A single note with a bend and release will contain two
 * `<bend>` elements: the first to represent the bend and the second to represent the release.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bend/}
 */
var Bend = /** @class */ (function () {
    function Bend(opts) {
        var _a;
        this.schema = Bend.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Bend.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Bend.schema.contents);
    }
    /** Gets @type {BendAttributes['accelerate']}. */
    Bend.prototype.getAccelerate = function () {
        return this.attributes['accelerate'];
    };
    /** Sets @type {BendAttributes['accelerate']}. */
    Bend.prototype.setAccelerate = function (accelerate) {
        this.attributes['accelerate'] = accelerate;
        return this;
    };
    /** Gets @type {BendAttributes['beats']}. */
    Bend.prototype.getBeats = function () {
        return this.attributes['beats'];
    };
    /** Sets @type {BendAttributes['beats']}. */
    Bend.prototype.setBeats = function (beats) {
        this.attributes['beats'] = beats;
        return this;
    };
    /** Gets @type {BendAttributes['color']}. */
    Bend.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {BendAttributes['color']}. */
    Bend.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {BendAttributes['default-x']}. */
    Bend.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {BendAttributes['default-x']}. */
    Bend.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {BendAttributes['default-y']}. */
    Bend.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {BendAttributes['default-y']}. */
    Bend.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {BendAttributes['first-beat']}. */
    Bend.prototype.getFirstBeat = function () {
        return this.attributes['first-beat'];
    };
    /** Sets @type {BendAttributes['first-beat']}. */
    Bend.prototype.setFirstBeat = function (firstBeat) {
        this.attributes['first-beat'] = firstBeat;
        return this;
    };
    /** Gets @type {BendAttributes['font-family']}. */
    Bend.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {BendAttributes['font-family']}. */
    Bend.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {BendAttributes['font-size']}. */
    Bend.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {BendAttributes['font-size']}. */
    Bend.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {BendAttributes['font-style']}. */
    Bend.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {BendAttributes['font-style']}. */
    Bend.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {BendAttributes['font-weight']}. */
    Bend.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {BendAttributes['font-weight']}. */
    Bend.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {BendAttributes['last-beat']}. */
    Bend.prototype.getLastBeat = function () {
        return this.attributes['last-beat'];
    };
    /** Sets @type {BendAttributes['last-beat']}. */
    Bend.prototype.setLastBeat = function (lastBeat) {
        this.attributes['last-beat'] = lastBeat;
        return this;
    };
    /** Gets @type {BendAttributes['relative-x']}. */
    Bend.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {BendAttributes['relative-x']}. */
    Bend.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {BendAttributes['relative-y']}. */
    Bend.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {BendAttributes['relative-y']}. */
    Bend.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {BendAttributes['shape']}. */
    Bend.prototype.getShape = function () {
        return this.attributes['shape'];
    };
    /** Sets @type {BendAttributes['shape']}. */
    Bend.prototype.setShape = function (shape) {
        this.attributes['shape'] = shape;
        return this;
    };
    /** Gets @type {BendAlter}. */
    Bend.prototype.getBendAlter = function () {
        return this.contents[0];
    };
    /** Sets @type {BendAlter}. */
    Bend.prototype.setBendAlter = function (bendAlter) {
        this.contents[0] = bendAlter;
        return this;
    };
    /** Gets @type {Array<PreBend | Release>}. */
    Bend.prototype.getBends = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<PreBend | Release>}. */
    Bend.prototype.setBends = function (bends) {
        this.contents[1] = bends;
        return this;
    };
    /** Gets @type {WithBar | null}. */
    Bend.prototype.getWithBar = function () {
        return this.contents[2];
    };
    /** Sets @type {WithBar | null}. */
    Bend.prototype.setWithBar = function (withBar) {
        this.contents[2] = withBar;
        return this;
    };
    Bend.schema = {
        name: 'bend',
        attributes: {
            accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'first-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            shape: { type: 'optional', value: { type: 'choices', choices: ['angled', 'curved'] } },
        },
        contents: [
            { type: 'required', value: BendAlter },
            {
                type: 'label',
                label: 'bends',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [PreBend, Release] } },
            },
            { type: 'optional', value: WithBar },
        ],
    };
    return Bend;
}());
exports.Bend = Bend;
/**
 * The `<tap>` element
 *
 * Parent element: `<technical>`
 *
 * The `<tap>` element indicates a tap on the fretboard. The element content allows specification of the notation; + and
 * T are common choices.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tap/}
 */
var Tap = /** @class */ (function () {
    function Tap(opts) {
        var _a;
        this.schema = Tap.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Tap.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Tap.schema.contents);
    }
    /** Gets @type {TapAttributes['color']}. */
    Tap.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TapAttributes['color']}. */
    Tap.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TapAttributes['default-x']}. */
    Tap.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {TapAttributes['default-x']}. */
    Tap.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {TapAttributes['default-y']}. */
    Tap.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {TapAttributes['default-y']}. */
    Tap.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {TapAttributes['font-family']}. */
    Tap.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TapAttributes['font-family']}. */
    Tap.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TapAttributes['font-size']}. */
    Tap.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TapAttributes['font-size']}. */
    Tap.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TapAttributes['font-style']}. */
    Tap.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TapAttributes['font-style']}. */
    Tap.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TapAttributes['font-weight']}. */
    Tap.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TapAttributes['font-weight']}. */
    Tap.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {TapAttributes['hand']}. */
    Tap.prototype.getHand = function () {
        return this.attributes['hand'];
    };
    /** Sets @type {TapAttributes['hand']}. */
    Tap.prototype.setHand = function (hand) {
        this.attributes['hand'] = hand;
        return this;
    };
    /** Gets @type {TapAttributes['placement']}. */
    Tap.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {TapAttributes['placement']}. */
    Tap.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {TapAttributes['relative-x']}. */
    Tap.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {TapAttributes['relative-x']}. */
    Tap.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {TapAttributes['relative-y']}. */
    Tap.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {TapAttributes['relative-y']}. */
    Tap.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string | null}. */
    Tap.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string | null}. */
    Tap.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Tap.schema = {
        name: 'tap',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            hand: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'optional', value: { type: 'string' } }],
    };
    return Tap;
}());
exports.Tap = Tap;
/**
 * The `<heel>` element
 *
 * Parent element: `<technical>`
 *
 * The `<heel>` element is used with organ pedals.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/heel/}
 */
var Heel = /** @class */ (function () {
    function Heel(opts) {
        var _a;
        this.schema = Heel.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Heel.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Heel.schema.contents);
    }
    /** Gets @type {HeelAttributes['color']}. */
    Heel.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {HeelAttributes['color']}. */
    Heel.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {HeelAttributes['default-x']}. */
    Heel.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {HeelAttributes['default-x']}. */
    Heel.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {HeelAttributes['default-y']}. */
    Heel.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {HeelAttributes['default-y']}. */
    Heel.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {HeelAttributes['font-family']}. */
    Heel.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {HeelAttributes['font-family']}. */
    Heel.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {HeelAttributes['font-size']}. */
    Heel.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {HeelAttributes['font-size']}. */
    Heel.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {HeelAttributes['font-style']}. */
    Heel.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {HeelAttributes['font-style']}. */
    Heel.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {HeelAttributes['font-weight']}. */
    Heel.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {HeelAttributes['font-weight']}. */
    Heel.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {HeelAttributes['placement']}. */
    Heel.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {HeelAttributes['placement']}. */
    Heel.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {HeelAttributes['relative-x']}. */
    Heel.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {HeelAttributes['relative-x']}. */
    Heel.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {HeelAttributes['relative-y']}. */
    Heel.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {HeelAttributes['relative-y']}. */
    Heel.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {HeelAttributes['substitution']}. */
    Heel.prototype.getSubstitution = function () {
        return this.attributes['substitution'];
    };
    /** Sets @type {HeelAttributes['substitution']}. */
    Heel.prototype.setSubstitution = function (substitution) {
        this.attributes['substitution'] = substitution;
        return this;
    };
    Heel.schema = {
        name: 'heel',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            substitution: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
        },
        contents: [],
    };
    return Heel;
}());
exports.Heel = Heel;
/**
 * The `<toe>` element
 *
 * Parent element: `<technical>`
 *
 * The `<toe>` element is used with organ pedals.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/toe/}
 */
var Toe = /** @class */ (function () {
    function Toe(opts) {
        var _a;
        this.schema = Toe.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Toe.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Toe.schema.contents);
    }
    /** Gets @type {ToeAttributes['color']}. */
    Toe.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {ToeAttributes['color']}. */
    Toe.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {ToeAttributes['default-x']}. */
    Toe.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {ToeAttributes['default-x']}. */
    Toe.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {ToeAttributes['default-y']}. */
    Toe.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {ToeAttributes['default-y']}. */
    Toe.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {ToeAttributes['font-family']}. */
    Toe.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {ToeAttributes['font-family']}. */
    Toe.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {ToeAttributes['font-size']}. */
    Toe.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {ToeAttributes['font-size']}. */
    Toe.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {ToeAttributes['font-style']}. */
    Toe.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {ToeAttributes['font-style']}. */
    Toe.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {ToeAttributes['font-weight']}. */
    Toe.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {ToeAttributes['font-weight']}. */
    Toe.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {ToeAttributes['placement']}. */
    Toe.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {ToeAttributes['placement']}. */
    Toe.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {ToeAttributes['relative-x']}. */
    Toe.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {ToeAttributes['relative-x']}. */
    Toe.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {ToeAttributes['relative-y']}. */
    Toe.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {ToeAttributes['relative-y']}. */
    Toe.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {ToeAttributes['substitution']}. */
    Toe.prototype.getSubstitution = function () {
        return this.attributes['substitution'];
    };
    /** Sets @type {ToeAttributes['substitution']}. */
    Toe.prototype.setSubstitution = function (substitution) {
        this.attributes['substitution'] = substitution;
        return this;
    };
    Toe.schema = {
        name: 'toe',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            substitution: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
        },
        contents: [],
    };
    return Toe;
}());
exports.Toe = Toe;
/**
 * The `<fingernails>` element
 *
 * Parent element: `<technical>`
 *
 * The `<fingernails>` element is used in notation for harp and other plucked string instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fingernails/}
 */
var Fingernails = /** @class */ (function () {
    function Fingernails(opts) {
        var _a;
        this.schema = Fingernails.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Fingernails.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Fingernails.schema.contents);
    }
    /** Gets @type {FingernailsAttributes['color']}. */
    Fingernails.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FingernailsAttributes['color']}. */
    Fingernails.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FingernailsAttributes['default-x']}. */
    Fingernails.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {FingernailsAttributes['default-x']}. */
    Fingernails.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {FingernailsAttributes['default-y']}. */
    Fingernails.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {FingernailsAttributes['default-y']}. */
    Fingernails.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {FingernailsAttributes['font-family']}. */
    Fingernails.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FingernailsAttributes['font-family']}. */
    Fingernails.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FingernailsAttributes['font-size']}. */
    Fingernails.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FingernailsAttributes['font-size']}. */
    Fingernails.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FingernailsAttributes['font-style']}. */
    Fingernails.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FingernailsAttributes['font-style']}. */
    Fingernails.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FingernailsAttributes['font-weight']}. */
    Fingernails.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FingernailsAttributes['font-weight']}. */
    Fingernails.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {FingernailsAttributes['placement']}. */
    Fingernails.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {FingernailsAttributes['placement']}. */
    Fingernails.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {FingernailsAttributes['relative-x']}. */
    Fingernails.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {FingernailsAttributes['relative-x']}. */
    Fingernails.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {FingernailsAttributes['relative-y']}. */
    Fingernails.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {FingernailsAttributes['relative-y']}. */
    Fingernails.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Fingernails.schema = {
        name: 'fingernails',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Fingernails;
}());
exports.Fingernails = Fingernails;
/**
 * The `<hole-type>` element
 *
 * Parent element: `<hole>`
 *
 * The content of the `<hole-type>` element indicates what the hole symbol represents in terms of instrument fingering
 * or other techniques.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/hole-type/}
 */
var HoleType = /** @class */ (function () {
    function HoleType(opts) {
        var _a;
        this.schema = HoleType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, HoleType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(HoleType.schema.contents);
    }
    /** Gets @type {string}. */
    HoleType.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    HoleType.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    HoleType.schema = {
        name: 'hole-type',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return HoleType;
}());
exports.HoleType = HoleType;
/**
 * The `<hole-closed>` element
 *
 * Parent element: `<hole>`
 *
 * The `<hole-closed>` element represents whether the hole is closed, open, or half-open.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/hole-closed/}
 */
var HoleClosed = /** @class */ (function () {
    function HoleClosed(opts) {
        var _a;
        this.schema = HoleClosed.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, HoleClosed.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(HoleClosed.schema.contents);
    }
    /** Gets @type {HoleClosedAttributes['location']}. */
    HoleClosed.prototype.getLocation = function () {
        return this.attributes['location'];
    };
    /** Sets @type {HoleClosedAttributes['location']}. */
    HoleClosed.prototype.setLocation = function (location) {
        this.attributes['location'] = location;
        return this;
    };
    /** Gets @type {'yes' | 'no' | 'half'}. */
    HoleClosed.prototype.getHoleClosedValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'yes' | 'no' | 'half'}. */
    HoleClosed.prototype.setHoleClosedValue = function (holeClosedValue) {
        this.contents[0] = holeClosedValue;
        return this;
    };
    HoleClosed.schema = {
        name: 'hole-closed',
        attributes: {
            location: { type: 'optional', value: { type: 'choices', choices: ['bottom', 'left', 'right', 'top'] } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'hole-closed-value',
                    value: { type: 'choices', choices: ['yes', 'no', 'half'] },
                },
            },
        ],
    };
    return HoleClosed;
}());
exports.HoleClosed = HoleClosed;
/**
 * The `<hole-shape>` element
 *
 * Parent element: `<hole>`
 *
 * The `<hole-shape>` element indicates the shape of the hole symbol. It is a circle if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/hole-shape/}
 */
var HoleShape = /** @class */ (function () {
    function HoleShape(opts) {
        var _a;
        this.schema = HoleShape.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, HoleShape.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(HoleShape.schema.contents);
    }
    /** Gets @type {string}. */
    HoleShape.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    HoleShape.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    HoleShape.schema = {
        name: 'hole-shape',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return HoleShape;
}());
exports.HoleShape = HoleShape;
/**
 * The `<hole>` element
 *
 * Parent element: `<technical>`
 *
 * The `<hole>` element represents the symbols used for woodwind and brass fingerings as well as other notations.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/hole/}
 */
var Hole = /** @class */ (function () {
    function Hole(opts) {
        var _a;
        this.schema = Hole.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Hole.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Hole.schema.contents);
    }
    /** Gets @type {HoleAttributes['color']}. */
    Hole.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {HoleAttributes['color']}. */
    Hole.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {HoleAttributes['default-x']}. */
    Hole.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {HoleAttributes['default-x']}. */
    Hole.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {HoleAttributes['default-y']}. */
    Hole.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {HoleAttributes['default-y']}. */
    Hole.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {HoleAttributes['font-family']}. */
    Hole.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {HoleAttributes['font-family']}. */
    Hole.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {HoleAttributes['font-size']}. */
    Hole.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {HoleAttributes['font-size']}. */
    Hole.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {HoleAttributes['font-style']}. */
    Hole.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {HoleAttributes['font-style']}. */
    Hole.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {HoleAttributes['font-weight']}. */
    Hole.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {HoleAttributes['font-weight']}. */
    Hole.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {HoleAttributes['placement']}. */
    Hole.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {HoleAttributes['placement']}. */
    Hole.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {HoleAttributes['relative-x']}. */
    Hole.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {HoleAttributes['relative-x']}. */
    Hole.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {HoleAttributes['relative-y']}. */
    Hole.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {HoleAttributes['relative-y']}. */
    Hole.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {HoleType | null}. */
    Hole.prototype.getHoleType = function () {
        return this.contents[0];
    };
    /** Sets @type {HoleType | null}. */
    Hole.prototype.setHoleType = function (holeType) {
        this.contents[0] = holeType;
        return this;
    };
    /** Gets @type {HoleClosed}. */
    Hole.prototype.getHoleClosed = function () {
        return this.contents[1];
    };
    /** Sets @type {HoleClosed}. */
    Hole.prototype.setHoleClosed = function (holeClosed) {
        this.contents[1] = holeClosed;
        return this;
    };
    /** Gets @type {HoleShape | null}. */
    Hole.prototype.getHoleShape = function () {
        return this.contents[2];
    };
    /** Sets @type {HoleShape | null}. */
    Hole.prototype.setHoleShape = function (holeShape) {
        this.contents[2] = holeShape;
        return this;
    };
    Hole.schema = {
        name: 'hole',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [
            { type: 'optional', value: HoleType },
            { type: 'required', value: HoleClosed },
            { type: 'optional', value: HoleShape },
        ],
    };
    return Hole;
}());
exports.Hole = Hole;
/**
 * The `<arrow-direction>` element
 *
 * Parent element: `<arrow>`
 *
 * The `<arrow-direction>` element represents the direction in which an arrow points, using Unicode arrow terminology.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/arrow-direction/}
 */
var ArrowDirection = /** @class */ (function () {
    function ArrowDirection(opts) {
        var _a;
        this.schema = ArrowDirection.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ArrowDirection.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ArrowDirection.schema.contents);
    }
    /** Gets @type {'down' | 'left' | 'left right' | 'northeast' | 'northeast southwest' | 'northwest' | 'northwest southeast' | 'other' | 'right' | 'southeast' | 'southwest' | 'up' | 'up down'}. */
    ArrowDirection.prototype.getArrowDirection = function () {
        return this.contents[0];
    };
    /** Sets @type {'down' | 'left' | 'left right' | 'northeast' | 'northeast southwest' | 'northwest' | 'northwest southeast' | 'other' | 'right' | 'southeast' | 'southwest' | 'up' | 'up down'}. */
    ArrowDirection.prototype.setArrowDirection = function (arrowDirection) {
        this.contents[0] = arrowDirection;
        return this;
    };
    ArrowDirection.schema = {
        name: 'arrow-direction',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'arrow-direction',
                    value: {
                        type: 'choices',
                        choices: [
                            'down',
                            'left',
                            'left right',
                            'northeast',
                            'northeast southwest',
                            'northwest',
                            'northwest southeast',
                            'other',
                            'right',
                            'southeast',
                            'southwest',
                            'up',
                            'up down',
                        ],
                    },
                },
            },
        ],
    };
    return ArrowDirection;
}());
exports.ArrowDirection = ArrowDirection;
/**
 * The `<arrow-style>` element
 *
 * Parent element: `<arrow>`
 *
 * The `<arrow-style>` element represents the style of an arrow, using Unicode arrow terminology.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/arrow-style/}
 */
var ArrowStyle = /** @class */ (function () {
    function ArrowStyle(opts) {
        var _a;
        this.schema = ArrowStyle.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ArrowStyle.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ArrowStyle.schema.contents);
    }
    /** Gets @type {'combined' | 'double' | 'filled' | 'hollow' | 'other' | 'paired' | 'single'}. */
    ArrowStyle.prototype.getArrowStyle = function () {
        return this.contents[0];
    };
    /** Sets @type {'combined' | 'double' | 'filled' | 'hollow' | 'other' | 'paired' | 'single'}. */
    ArrowStyle.prototype.setArrowStyle = function (arrowStyle) {
        this.contents[0] = arrowStyle;
        return this;
    };
    ArrowStyle.schema = {
        name: 'arrow-style',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'arrow-style',
                    value: { type: 'choices', choices: ['combined', 'double', 'filled', 'hollow', 'other', 'paired', 'single'] },
                },
            },
        ],
    };
    return ArrowStyle;
}());
exports.ArrowStyle = ArrowStyle;
/**
 * The `<arrowhead>` element
 *
 * Parent element: `<arrow>`
 *
 * The presence of an `<arrowhead>` element indicates that only the arrowhead is displayed within the `<arrow>`, not the
 * arrow stem.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/arrowhead/}
 */
var Arrowhead = /** @class */ (function () {
    function Arrowhead(opts) {
        var _a;
        this.schema = Arrowhead.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Arrowhead.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Arrowhead.schema.contents);
    }
    Arrowhead.schema = { name: 'arrowhead', attributes: {}, contents: [] };
    return Arrowhead;
}());
exports.Arrowhead = Arrowhead;
/**
 * The `<circular-arrow>` element
 *
 * Parent element: `<arrow>`
 *
 * The `<circular-arrow>` element represents a circular arrow, using Unicode arrow terminology to specify the arrow
 * direction.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/circular-arrow/}
 */
var CircularArrow = /** @class */ (function () {
    function CircularArrow(opts) {
        var _a;
        this.schema = CircularArrow.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, CircularArrow.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(CircularArrow.schema.contents);
    }
    /** Gets @type {'anticlockwise' | 'clockwise'}. */
    CircularArrow.prototype.getCircularArrow = function () {
        return this.contents[0];
    };
    /** Sets @type {'anticlockwise' | 'clockwise'}. */
    CircularArrow.prototype.setCircularArrow = function (circularArrow) {
        this.contents[0] = circularArrow;
        return this;
    };
    CircularArrow.schema = {
        name: 'circular-arrow',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'circular-arrow',
                    value: { type: 'choices', choices: ['anticlockwise', 'clockwise'] },
                },
            },
        ],
    };
    return CircularArrow;
}());
exports.CircularArrow = CircularArrow;
/**
 * The `<arrow>` element
 *
 * Parent element: `<technical>`
 *
 * The `<arrow>` element represents an arrow used for a musical technical indication. It can represent both Unicode and
 * Standard Music Font Layout (SMuFL) arrows. The smufl attribute distinguishes different SMuFL glyphs that have an
 * arrow appearance such as arrowBlackUp, guitarStrumUp, or handbellsSwingUp. The specified glyph should match the
 * descriptive representation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/arrow/}
 */
var Arrow = /** @class */ (function () {
    function Arrow(opts) {
        var _a;
        this.schema = Arrow.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Arrow.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Arrow.schema.contents);
    }
    /** Gets @type {ArrowAttributes['color']}. */
    Arrow.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {ArrowAttributes['color']}. */
    Arrow.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {ArrowAttributes['default-x']}. */
    Arrow.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {ArrowAttributes['default-x']}. */
    Arrow.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {ArrowAttributes['default-y']}. */
    Arrow.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {ArrowAttributes['default-y']}. */
    Arrow.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {ArrowAttributes['font-family']}. */
    Arrow.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {ArrowAttributes['font-family']}. */
    Arrow.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {ArrowAttributes['font-size']}. */
    Arrow.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {ArrowAttributes['font-size']}. */
    Arrow.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {ArrowAttributes['font-style']}. */
    Arrow.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {ArrowAttributes['font-style']}. */
    Arrow.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {ArrowAttributes['font-weight']}. */
    Arrow.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {ArrowAttributes['font-weight']}. */
    Arrow.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {ArrowAttributes['placement']}. */
    Arrow.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {ArrowAttributes['placement']}. */
    Arrow.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {ArrowAttributes['relative-x']}. */
    Arrow.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {ArrowAttributes['relative-x']}. */
    Arrow.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {ArrowAttributes['relative-y']}. */
    Arrow.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {ArrowAttributes['relative-y']}. */
    Arrow.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {ArrowAttributes['smufl']}. */
    Arrow.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {ArrowAttributes['smufl']}. */
    Arrow.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {ArrowDirection}. */
    Arrow.prototype.getArrowDirection = function () {
        return this.contents[0];
    };
    /** Sets @type {ArrowDirection}. */
    Arrow.prototype.setArrowDirection = function (arrowDirection) {
        this.contents[0] = arrowDirection;
        return this;
    };
    /** Gets @type {ArrowStyle | null}. */
    Arrow.prototype.getArrowStyle = function () {
        return this.contents[1];
    };
    /** Sets @type {ArrowStyle | null}. */
    Arrow.prototype.setArrowStyle = function (arrowStyle) {
        this.contents[1] = arrowStyle;
        return this;
    };
    /** Gets @type {Arrowhead | null}. */
    Arrow.prototype.getArrowhead = function () {
        return this.contents[2];
    };
    /** Sets @type {Arrowhead | null}. */
    Arrow.prototype.setArrowhead = function (arrowhead) {
        this.contents[2] = arrowhead;
        return this;
    };
    /** Gets @type {CircularArrow | null}. */
    Arrow.prototype.getCircularArrow = function () {
        return this.contents[3];
    };
    /** Sets @type {CircularArrow | null}. */
    Arrow.prototype.setCircularArrow = function (circularArrow) {
        this.contents[3] = circularArrow;
        return this;
    };
    Arrow.schema = {
        name: 'arrow',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            { type: 'required', value: ArrowDirection },
            { type: 'optional', value: ArrowStyle },
            { type: 'optional', value: Arrowhead },
            { type: 'optional', value: CircularArrow },
        ],
    };
    return Arrow;
}());
exports.Arrow = Arrow;
/**
 * The `<handbell>` element
 *
 * Parent element: `<technical>`
 *
 * The `<handbell>` element represents notation for various techniques used in handbell and handchime music.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/handbell/}
 */
var Handbell = /** @class */ (function () {
    function Handbell(opts) {
        var _a;
        this.schema = Handbell.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Handbell.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Handbell.schema.contents);
    }
    /** Gets @type {HandbellAttributes['color']}. */
    Handbell.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {HandbellAttributes['color']}. */
    Handbell.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {HandbellAttributes['default-x']}. */
    Handbell.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {HandbellAttributes['default-x']}. */
    Handbell.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {HandbellAttributes['default-y']}. */
    Handbell.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {HandbellAttributes['default-y']}. */
    Handbell.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {HandbellAttributes['font-family']}. */
    Handbell.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {HandbellAttributes['font-family']}. */
    Handbell.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {HandbellAttributes['font-size']}. */
    Handbell.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {HandbellAttributes['font-size']}. */
    Handbell.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {HandbellAttributes['font-style']}. */
    Handbell.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {HandbellAttributes['font-style']}. */
    Handbell.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {HandbellAttributes['font-weight']}. */
    Handbell.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {HandbellAttributes['font-weight']}. */
    Handbell.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {HandbellAttributes['placement']}. */
    Handbell.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {HandbellAttributes['placement']}. */
    Handbell.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {HandbellAttributes['relative-x']}. */
    Handbell.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {HandbellAttributes['relative-x']}. */
    Handbell.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {HandbellAttributes['relative-y']}. */
    Handbell.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {HandbellAttributes['relative-y']}. */
    Handbell.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {'belltree' | 'damp' | 'echo' | 'gyro' | 'hand martellato' | 'mallet lift' | 'mallet table' | 'martellato' | 'martellato lift' | 'muted martellato' | 'pluck lift' | 'swing'}. */
    Handbell.prototype.getHandbellValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'belltree' | 'damp' | 'echo' | 'gyro' | 'hand martellato' | 'mallet lift' | 'mallet table' | 'martellato' | 'martellato lift' | 'muted martellato' | 'pluck lift' | 'swing'}. */
    Handbell.prototype.setHandbellValue = function (handbellValue) {
        this.contents[0] = handbellValue;
        return this;
    };
    Handbell.schema = {
        name: 'handbell',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'handbell-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'belltree',
                            'damp',
                            'echo',
                            'gyro',
                            'hand martellato',
                            'mallet lift',
                            'mallet table',
                            'martellato',
                            'martellato lift',
                            'muted martellato',
                            'pluck lift',
                            'swing',
                        ],
                    },
                },
            },
        ],
    };
    return Handbell;
}());
exports.Handbell = Handbell;
/**
 * The `<brass-bend>` element
 *
 * Parent element: `<technical>`
 *
 * The `<brass-bend>` element represents the u-shaped bend symbol used in brass notation, distinct from the `<bend>`
 * element used in guitar music.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/brass-bend/}
 */
var BrassBend = /** @class */ (function () {
    function BrassBend(opts) {
        var _a;
        this.schema = BrassBend.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BrassBend.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BrassBend.schema.contents);
    }
    /** Gets @type {BrassBendAttributes['color']}. */
    BrassBend.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {BrassBendAttributes['color']}. */
    BrassBend.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {BrassBendAttributes['default-x']}. */
    BrassBend.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {BrassBendAttributes['default-x']}. */
    BrassBend.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {BrassBendAttributes['default-y']}. */
    BrassBend.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {BrassBendAttributes['default-y']}. */
    BrassBend.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {BrassBendAttributes['font-family']}. */
    BrassBend.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {BrassBendAttributes['font-family']}. */
    BrassBend.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {BrassBendAttributes['font-size']}. */
    BrassBend.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {BrassBendAttributes['font-size']}. */
    BrassBend.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {BrassBendAttributes['font-style']}. */
    BrassBend.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {BrassBendAttributes['font-style']}. */
    BrassBend.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {BrassBendAttributes['font-weight']}. */
    BrassBend.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {BrassBendAttributes['font-weight']}. */
    BrassBend.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {BrassBendAttributes['placement']}. */
    BrassBend.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {BrassBendAttributes['placement']}. */
    BrassBend.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {BrassBendAttributes['relative-x']}. */
    BrassBend.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {BrassBendAttributes['relative-x']}. */
    BrassBend.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {BrassBendAttributes['relative-y']}. */
    BrassBend.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {BrassBendAttributes['relative-y']}. */
    BrassBend.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    BrassBend.schema = {
        name: 'brass-bend',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return BrassBend;
}());
exports.BrassBend = BrassBend;
/**
 * The `<flip>` element
 *
 * Parent element: `<technical>`
 *
 * The `<flip>` element represents the flip symbol used in brass notation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/flip/}
 */
var Flip = /** @class */ (function () {
    function Flip(opts) {
        var _a;
        this.schema = Flip.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Flip.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Flip.schema.contents);
    }
    /** Gets @type {FlipAttributes['color']}. */
    Flip.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FlipAttributes['color']}. */
    Flip.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FlipAttributes['default-x']}. */
    Flip.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {FlipAttributes['default-x']}. */
    Flip.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {FlipAttributes['default-y']}. */
    Flip.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {FlipAttributes['default-y']}. */
    Flip.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {FlipAttributes['font-family']}. */
    Flip.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FlipAttributes['font-family']}. */
    Flip.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FlipAttributes['font-size']}. */
    Flip.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FlipAttributes['font-size']}. */
    Flip.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FlipAttributes['font-style']}. */
    Flip.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FlipAttributes['font-style']}. */
    Flip.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FlipAttributes['font-weight']}. */
    Flip.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FlipAttributes['font-weight']}. */
    Flip.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {FlipAttributes['placement']}. */
    Flip.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {FlipAttributes['placement']}. */
    Flip.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {FlipAttributes['relative-x']}. */
    Flip.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {FlipAttributes['relative-x']}. */
    Flip.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {FlipAttributes['relative-y']}. */
    Flip.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {FlipAttributes['relative-y']}. */
    Flip.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Flip.schema = {
        name: 'flip',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Flip;
}());
exports.Flip = Flip;
/**
 * The `<smear>` element
 *
 * Parent element: `<technical>`
 *
 * The `<smear>` element represents the tilde-shaped smear symbol used in brass notation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/smear/}
 */
var Smear = /** @class */ (function () {
    function Smear(opts) {
        var _a;
        this.schema = Smear.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Smear.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Smear.schema.contents);
    }
    /** Gets @type {SmearAttributes['color']}. */
    Smear.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {SmearAttributes['color']}. */
    Smear.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {SmearAttributes['default-x']}. */
    Smear.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {SmearAttributes['default-x']}. */
    Smear.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {SmearAttributes['default-y']}. */
    Smear.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {SmearAttributes['default-y']}. */
    Smear.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {SmearAttributes['font-family']}. */
    Smear.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {SmearAttributes['font-family']}. */
    Smear.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {SmearAttributes['font-size']}. */
    Smear.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {SmearAttributes['font-size']}. */
    Smear.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {SmearAttributes['font-style']}. */
    Smear.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {SmearAttributes['font-style']}. */
    Smear.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {SmearAttributes['font-weight']}. */
    Smear.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {SmearAttributes['font-weight']}. */
    Smear.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {SmearAttributes['placement']}. */
    Smear.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {SmearAttributes['placement']}. */
    Smear.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {SmearAttributes['relative-x']}. */
    Smear.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {SmearAttributes['relative-x']}. */
    Smear.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {SmearAttributes['relative-y']}. */
    Smear.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {SmearAttributes['relative-y']}. */
    Smear.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Smear.schema = {
        name: 'smear',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Smear;
}());
exports.Smear = Smear;
/**
 * The `<open>` element
 *
 * Parent element: `<technical>`
 *
 * The `<open>` element represents the open symbol, which looks like a circle. The smufl attribute can be used to
 * distinguish different Standard Music Font Layout (SMuFL) glyphs that have a similar appearance such as brassMuteOpen
 * and guitarOpenPedal. If not present, the default glyph is brassMuteOpen.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/open/}
 */
var Open = /** @class */ (function () {
    function Open(opts) {
        var _a;
        this.schema = Open.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Open.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Open.schema.contents);
    }
    /** Gets @type {OpenAttributes['color']}. */
    Open.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {OpenAttributes['color']}. */
    Open.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {OpenAttributes['default-x']}. */
    Open.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {OpenAttributes['default-x']}. */
    Open.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {OpenAttributes['default-y']}. */
    Open.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {OpenAttributes['default-y']}. */
    Open.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {OpenAttributes['font-family']}. */
    Open.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {OpenAttributes['font-family']}. */
    Open.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {OpenAttributes['font-size']}. */
    Open.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {OpenAttributes['font-size']}. */
    Open.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {OpenAttributes['font-style']}. */
    Open.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {OpenAttributes['font-style']}. */
    Open.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {OpenAttributes['font-weight']}. */
    Open.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {OpenAttributes['font-weight']}. */
    Open.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {OpenAttributes['placement']}. */
    Open.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {OpenAttributes['placement']}. */
    Open.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {OpenAttributes['relative-x']}. */
    Open.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {OpenAttributes['relative-x']}. */
    Open.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {OpenAttributes['relative-y']}. */
    Open.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {OpenAttributes['relative-y']}. */
    Open.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {OpenAttributes['smufl']}. */
    Open.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {OpenAttributes['smufl']}. */
    Open.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    Open.schema = {
        name: 'open',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: { type: 'optional', value: { type: 'string' } },
        },
        contents: [],
    };
    return Open;
}());
exports.Open = Open;
/**
 * The `<half-muted>` element
 *
 * Parent element: `<technical>`
 *
 * The `<half-muted>` element represents the half-muted symbol, which looks like a circle with a plus sign inside. The
 * smufl attribute can be used to distinguish different SMuFL glyphs that have a similar appearance such as
 * brassMuteHalfClosed and guitarHalfOpenPedal. If not present, the default glyph is brassMuteHalfClosed.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/half-muted/}
 */
var HalfMuted = /** @class */ (function () {
    function HalfMuted(opts) {
        var _a;
        this.schema = HalfMuted.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, HalfMuted.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(HalfMuted.schema.contents);
    }
    /** Gets @type {HalfMutedAttributes['color']}. */
    HalfMuted.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {HalfMutedAttributes['color']}. */
    HalfMuted.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {HalfMutedAttributes['default-x']}. */
    HalfMuted.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {HalfMutedAttributes['default-x']}. */
    HalfMuted.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {HalfMutedAttributes['default-y']}. */
    HalfMuted.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {HalfMutedAttributes['default-y']}. */
    HalfMuted.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {HalfMutedAttributes['font-family']}. */
    HalfMuted.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {HalfMutedAttributes['font-family']}. */
    HalfMuted.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {HalfMutedAttributes['font-size']}. */
    HalfMuted.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {HalfMutedAttributes['font-size']}. */
    HalfMuted.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {HalfMutedAttributes['font-style']}. */
    HalfMuted.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {HalfMutedAttributes['font-style']}. */
    HalfMuted.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {HalfMutedAttributes['font-weight']}. */
    HalfMuted.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {HalfMutedAttributes['font-weight']}. */
    HalfMuted.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {HalfMutedAttributes['placement']}. */
    HalfMuted.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {HalfMutedAttributes['placement']}. */
    HalfMuted.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {HalfMutedAttributes['relative-x']}. */
    HalfMuted.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {HalfMutedAttributes['relative-x']}. */
    HalfMuted.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {HalfMutedAttributes['relative-y']}. */
    HalfMuted.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {HalfMutedAttributes['relative-y']}. */
    HalfMuted.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {HalfMutedAttributes['smufl']}. */
    HalfMuted.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {HalfMutedAttributes['smufl']}. */
    HalfMuted.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    HalfMuted.schema = {
        name: 'half-muted',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: { type: 'optional', value: { type: 'string' } },
        },
        contents: [],
    };
    return HalfMuted;
}());
exports.HalfMuted = HalfMuted;
/**
 * The `<harmon-closed>` element
 *
 * Parent element: `<harmon-mute>`
 *
 * The `<harmon-closed>` element represents whether the harmon mute is closed, open, or half-open.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/harmon-closed/}
 */
var HarmonClosed = /** @class */ (function () {
    function HarmonClosed(opts) {
        var _a;
        this.schema = HarmonClosed.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, HarmonClosed.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(HarmonClosed.schema.contents);
    }
    /** Gets @type {HarmonClosedAttributes['location']}. */
    HarmonClosed.prototype.getLocation = function () {
        return this.attributes['location'];
    };
    /** Sets @type {HarmonClosedAttributes['location']}. */
    HarmonClosed.prototype.setLocation = function (location) {
        this.attributes['location'] = location;
        return this;
    };
    /** Gets @type {'yes' | 'no' | 'half'}. */
    HarmonClosed.prototype.getHarmonClosedValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'yes' | 'no' | 'half'}. */
    HarmonClosed.prototype.setHarmonClosedValue = function (harmonClosedValue) {
        this.contents[0] = harmonClosedValue;
        return this;
    };
    HarmonClosed.schema = {
        name: 'harmon-closed',
        attributes: {
            location: { type: 'optional', value: { type: 'choices', choices: ['bottom', 'left', 'right', 'top'] } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'harmon-closed-value',
                    value: { type: 'choices', choices: ['yes', 'no', 'half'] },
                },
            },
        ],
    };
    return HarmonClosed;
}());
exports.HarmonClosed = HarmonClosed;
/**
 * The `<harmon-mute>` element
 *
 * Parent element: `<technical>`
 *
 * The `<harmon-mute>` element represents the symbols used for harmon mutes in brass notation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/harmon-mute/}
 */
var HarmonMute = /** @class */ (function () {
    function HarmonMute(opts) {
        var _a;
        this.schema = HarmonMute.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, HarmonMute.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(HarmonMute.schema.contents);
    }
    /** Gets @type {HarmonMuteAttributes['color']}. */
    HarmonMute.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {HarmonMuteAttributes['color']}. */
    HarmonMute.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {HarmonMuteAttributes['default-x']}. */
    HarmonMute.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {HarmonMuteAttributes['default-x']}. */
    HarmonMute.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {HarmonMuteAttributes['default-y']}. */
    HarmonMute.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {HarmonMuteAttributes['default-y']}. */
    HarmonMute.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {HarmonMuteAttributes['font-family']}. */
    HarmonMute.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {HarmonMuteAttributes['font-family']}. */
    HarmonMute.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {HarmonMuteAttributes['font-size']}. */
    HarmonMute.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {HarmonMuteAttributes['font-size']}. */
    HarmonMute.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {HarmonMuteAttributes['font-style']}. */
    HarmonMute.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {HarmonMuteAttributes['font-style']}. */
    HarmonMute.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {HarmonMuteAttributes['font-weight']}. */
    HarmonMute.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {HarmonMuteAttributes['font-weight']}. */
    HarmonMute.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {HarmonMuteAttributes['placement']}. */
    HarmonMute.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {HarmonMuteAttributes['placement']}. */
    HarmonMute.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {HarmonMuteAttributes['relative-x']}. */
    HarmonMute.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {HarmonMuteAttributes['relative-x']}. */
    HarmonMute.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {HarmonMuteAttributes['relative-y']}. */
    HarmonMute.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {HarmonMuteAttributes['relative-y']}. */
    HarmonMute.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {HarmonMuteAttributes['smufl']}. */
    HarmonMute.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {HarmonMuteAttributes['smufl']}. */
    HarmonMute.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {HarmonClosed}. */
    HarmonMute.prototype.getHarmonClosed = function () {
        return this.contents[0];
    };
    /** Sets @type {HarmonClosed}. */
    HarmonMute.prototype.setHarmonClosed = function (harmonClosed) {
        this.contents[0] = harmonClosed;
        return this;
    };
    HarmonMute.schema = {
        name: 'harmon-mute',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: { type: 'optional', value: { type: 'string' } },
        },
        contents: [{ type: 'required', value: HarmonClosed }],
    };
    return HarmonMute;
}());
exports.HarmonMute = HarmonMute;
/**
 * The `<golpe>` element
 *
 * Parent element: `<technical>`
 *
 * The `<golpe>` element represents the golpe symbol that is used for tapping the pick guard in guitar music.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/golpe/}
 */
var Golpe = /** @class */ (function () {
    function Golpe(opts) {
        var _a;
        this.schema = Golpe.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Golpe.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Golpe.schema.contents);
    }
    /** Gets @type {GolpeAttributes['color']}. */
    Golpe.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {GolpeAttributes['color']}. */
    Golpe.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {GolpeAttributes['default-x']}. */
    Golpe.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {GolpeAttributes['default-x']}. */
    Golpe.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {GolpeAttributes['default-y']}. */
    Golpe.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {GolpeAttributes['default-y']}. */
    Golpe.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {GolpeAttributes['font-family']}. */
    Golpe.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {GolpeAttributes['font-family']}. */
    Golpe.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {GolpeAttributes['font-size']}. */
    Golpe.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {GolpeAttributes['font-size']}. */
    Golpe.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {GolpeAttributes['font-style']}. */
    Golpe.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {GolpeAttributes['font-style']}. */
    Golpe.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {GolpeAttributes['font-weight']}. */
    Golpe.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {GolpeAttributes['font-weight']}. */
    Golpe.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {GolpeAttributes['placement']}. */
    Golpe.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {GolpeAttributes['placement']}. */
    Golpe.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {GolpeAttributes['relative-x']}. */
    Golpe.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {GolpeAttributes['relative-x']}. */
    Golpe.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {GolpeAttributes['relative-y']}. */
    Golpe.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {GolpeAttributes['relative-y']}. */
    Golpe.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Golpe.schema = {
        name: 'golpe',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Golpe;
}());
exports.Golpe = Golpe;
/**
 * The `<other-technical>` element
 *
 * Parent element: `<technical>`
 *
 * The `<other-technical>` element is used to define any technical indications not yet in the MusicXML format. The smufl
 * attribute can be used to specify a particular glyph, allowing application interoperability without requiring every
 * Standard Music Font Layout (SMuFL) technical indication to have a MusicXML element equivalent. Using the
 * `<other-technical>` element without the smufl attribute allows for extended representation, though without
 * application interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-technical/}
 */
var OtherTechnical = /** @class */ (function () {
    function OtherTechnical(opts) {
        var _a;
        this.schema = OtherTechnical.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherTechnical.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherTechnical.schema.contents);
    }
    /** Gets @type {OtherTechnicalAttributes['color']}. */
    OtherTechnical.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {OtherTechnicalAttributes['color']}. */
    OtherTechnical.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {OtherTechnicalAttributes['default-x']}. */
    OtherTechnical.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {OtherTechnicalAttributes['default-x']}. */
    OtherTechnical.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {OtherTechnicalAttributes['default-y']}. */
    OtherTechnical.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {OtherTechnicalAttributes['default-y']}. */
    OtherTechnical.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {OtherTechnicalAttributes['font-family']}. */
    OtherTechnical.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {OtherTechnicalAttributes['font-family']}. */
    OtherTechnical.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {OtherTechnicalAttributes['font-size']}. */
    OtherTechnical.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {OtherTechnicalAttributes['font-size']}. */
    OtherTechnical.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {OtherTechnicalAttributes['font-style']}. */
    OtherTechnical.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {OtherTechnicalAttributes['font-style']}. */
    OtherTechnical.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {OtherTechnicalAttributes['font-weight']}. */
    OtherTechnical.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {OtherTechnicalAttributes['font-weight']}. */
    OtherTechnical.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {OtherTechnicalAttributes['placement']}. */
    OtherTechnical.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {OtherTechnicalAttributes['placement']}. */
    OtherTechnical.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {OtherTechnicalAttributes['relative-x']}. */
    OtherTechnical.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {OtherTechnicalAttributes['relative-x']}. */
    OtherTechnical.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {OtherTechnicalAttributes['relative-y']}. */
    OtherTechnical.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {OtherTechnicalAttributes['relative-y']}. */
    OtherTechnical.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {OtherTechnicalAttributes['smufl']}. */
    OtherTechnical.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {OtherTechnicalAttributes['smufl']}. */
    OtherTechnical.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {string | null}. */
    OtherTechnical.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string | null}. */
    OtherTechnical.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    OtherTechnical.schema = {
        name: 'other-technical',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: { type: 'optional', value: { type: 'string' } },
        },
        contents: [{ type: 'optional', value: { type: 'string' } }],
    };
    return OtherTechnical;
}());
exports.OtherTechnical = OtherTechnical;
/**
 * The `<technical>` element
 *
 * Parent element: `<notations>`
 *
 * The `<technical>` element groups together technical indications that give performance information for specific
 * instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/technical/}
 */
var Technical = /** @class */ (function () {
    function Technical(opts) {
        var _a;
        this.schema = Technical.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Technical.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Technical.schema.contents);
    }
    /** Gets @type {TechnicalAttributes['id']}. */
    Technical.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {TechnicalAttributes['id']}. */
    Technical.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {Array<UpBow | DownBow | Harmonic | OpenString | ThumbPosition | Fingering | Pluck | DoubleTongue | TripleTongue | Stopped | SnapPizzicato | Fret | String | HammerOn | PullOff | Bend | Tap | Heel | Toe | Fingernails | Hole | Arrow | Handbell | BrassBend | Flip | Smear | Open | HalfMuted | HarmonMute | Golpe | OtherTechnical>}. */
    Technical.prototype.getValues = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<UpBow | DownBow | Harmonic | OpenString | ThumbPosition | Fingering | Pluck | DoubleTongue | TripleTongue | Stopped | SnapPizzicato | Fret | String | HammerOn | PullOff | Bend | Tap | Heel | Toe | Fingernails | Hole | Arrow | Handbell | BrassBend | Flip | Smear | Open | HalfMuted | HarmonMute | Golpe | OtherTechnical>}. */
    Technical.prototype.setValues = function (values) {
        this.contents[0] = values;
        return this;
    };
    Technical.schema = {
        name: 'technical',
        attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [
            {
                type: 'label',
                label: 'values',
                value: {
                    type: 'zeroOrMore',
                    value: {
                        type: 'choices',
                        choices: [
                            UpBow,
                            DownBow,
                            Harmonic,
                            OpenString,
                            ThumbPosition,
                            Fingering,
                            Pluck,
                            DoubleTongue,
                            TripleTongue,
                            Stopped,
                            SnapPizzicato,
                            Fret,
                            String,
                            HammerOn,
                            PullOff,
                            Bend,
                            Tap,
                            Heel,
                            Toe,
                            Fingernails,
                            Hole,
                            Arrow,
                            Handbell,
                            BrassBend,
                            Flip,
                            Smear,
                            Open,
                            HalfMuted,
                            HarmonMute,
                            Golpe,
                            OtherTechnical,
                        ],
                    },
                },
            },
        ],
    };
    return Technical;
}());
exports.Technical = Technical;
/**
 * The `<accent>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<accent>` element indicates a regular horizontal accent mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accent/}
 */
var Accent = /** @class */ (function () {
    function Accent(opts) {
        var _a;
        this.schema = Accent.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Accent.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Accent.schema.contents);
    }
    /** Gets @type {AccentAttributes['color']}. */
    Accent.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {AccentAttributes['color']}. */
    Accent.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {AccentAttributes['default-x']}. */
    Accent.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {AccentAttributes['default-x']}. */
    Accent.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {AccentAttributes['default-y']}. */
    Accent.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {AccentAttributes['default-y']}. */
    Accent.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {AccentAttributes['font-family']}. */
    Accent.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {AccentAttributes['font-family']}. */
    Accent.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {AccentAttributes['font-size']}. */
    Accent.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {AccentAttributes['font-size']}. */
    Accent.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {AccentAttributes['font-style']}. */
    Accent.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {AccentAttributes['font-style']}. */
    Accent.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {AccentAttributes['font-weight']}. */
    Accent.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {AccentAttributes['font-weight']}. */
    Accent.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {AccentAttributes['placement']}. */
    Accent.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {AccentAttributes['placement']}. */
    Accent.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {AccentAttributes['relative-x']}. */
    Accent.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {AccentAttributes['relative-x']}. */
    Accent.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {AccentAttributes['relative-y']}. */
    Accent.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {AccentAttributes['relative-y']}. */
    Accent.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Accent.schema = {
        name: 'accent',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Accent;
}());
exports.Accent = Accent;
/**
 * The `<strong-accent>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<strong-accent>` element indicates a vertical accent mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/strong-accent/}
 */
var StrongAccent = /** @class */ (function () {
    function StrongAccent(opts) {
        var _a;
        this.schema = StrongAccent.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StrongAccent.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StrongAccent.schema.contents);
    }
    /** Gets @type {StrongAccentAttributes['color']}. */
    StrongAccent.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {StrongAccentAttributes['color']}. */
    StrongAccent.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {StrongAccentAttributes['default-x']}. */
    StrongAccent.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {StrongAccentAttributes['default-x']}. */
    StrongAccent.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {StrongAccentAttributes['default-y']}. */
    StrongAccent.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {StrongAccentAttributes['default-y']}. */
    StrongAccent.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {StrongAccentAttributes['font-family']}. */
    StrongAccent.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {StrongAccentAttributes['font-family']}. */
    StrongAccent.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {StrongAccentAttributes['font-size']}. */
    StrongAccent.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {StrongAccentAttributes['font-size']}. */
    StrongAccent.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {StrongAccentAttributes['font-style']}. */
    StrongAccent.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {StrongAccentAttributes['font-style']}. */
    StrongAccent.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {StrongAccentAttributes['font-weight']}. */
    StrongAccent.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {StrongAccentAttributes['font-weight']}. */
    StrongAccent.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {StrongAccentAttributes['placement']}. */
    StrongAccent.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {StrongAccentAttributes['placement']}. */
    StrongAccent.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {StrongAccentAttributes['relative-x']}. */
    StrongAccent.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {StrongAccentAttributes['relative-x']}. */
    StrongAccent.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {StrongAccentAttributes['relative-y']}. */
    StrongAccent.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {StrongAccentAttributes['relative-y']}. */
    StrongAccent.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {StrongAccentAttributes['type']}. */
    StrongAccent.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {StrongAccentAttributes['type']}. */
    StrongAccent.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    StrongAccent.schema = {
        name: 'strong-accent',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            type: { type: 'optional', value: { type: 'choices', choices: ['up', 'down'] } },
        },
        contents: [],
    };
    return StrongAccent;
}());
exports.StrongAccent = StrongAccent;
/**
 * The `<staccato>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<staccato>` element is used for a dot articulation, as opposed to a stroke or a wedge.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staccato/}
 */
var Staccato = /** @class */ (function () {
    function Staccato(opts) {
        var _a;
        this.schema = Staccato.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Staccato.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Staccato.schema.contents);
    }
    /** Gets @type {StaccatoAttributes['color']}. */
    Staccato.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {StaccatoAttributes['color']}. */
    Staccato.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {StaccatoAttributes['default-x']}. */
    Staccato.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {StaccatoAttributes['default-x']}. */
    Staccato.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {StaccatoAttributes['default-y']}. */
    Staccato.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {StaccatoAttributes['default-y']}. */
    Staccato.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {StaccatoAttributes['font-family']}. */
    Staccato.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {StaccatoAttributes['font-family']}. */
    Staccato.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {StaccatoAttributes['font-size']}. */
    Staccato.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {StaccatoAttributes['font-size']}. */
    Staccato.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {StaccatoAttributes['font-style']}. */
    Staccato.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {StaccatoAttributes['font-style']}. */
    Staccato.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {StaccatoAttributes['font-weight']}. */
    Staccato.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {StaccatoAttributes['font-weight']}. */
    Staccato.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {StaccatoAttributes['placement']}. */
    Staccato.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {StaccatoAttributes['placement']}. */
    Staccato.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {StaccatoAttributes['relative-x']}. */
    Staccato.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {StaccatoAttributes['relative-x']}. */
    Staccato.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {StaccatoAttributes['relative-y']}. */
    Staccato.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {StaccatoAttributes['relative-y']}. */
    Staccato.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Staccato.schema = {
        name: 'staccato',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Staccato;
}());
exports.Staccato = Staccato;
/**
 * The `<tenuto>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<tenuto>` element indicates a tenuto line symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tenuto/}
 */
var Tenuto = /** @class */ (function () {
    function Tenuto(opts) {
        var _a;
        this.schema = Tenuto.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Tenuto.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Tenuto.schema.contents);
    }
    /** Gets @type {TenutoAttributes['color']}. */
    Tenuto.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TenutoAttributes['color']}. */
    Tenuto.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TenutoAttributes['default-x']}. */
    Tenuto.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {TenutoAttributes['default-x']}. */
    Tenuto.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {TenutoAttributes['default-y']}. */
    Tenuto.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {TenutoAttributes['default-y']}. */
    Tenuto.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {TenutoAttributes['font-family']}. */
    Tenuto.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TenutoAttributes['font-family']}. */
    Tenuto.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TenutoAttributes['font-size']}. */
    Tenuto.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TenutoAttributes['font-size']}. */
    Tenuto.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TenutoAttributes['font-style']}. */
    Tenuto.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TenutoAttributes['font-style']}. */
    Tenuto.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TenutoAttributes['font-weight']}. */
    Tenuto.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TenutoAttributes['font-weight']}. */
    Tenuto.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {TenutoAttributes['placement']}. */
    Tenuto.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {TenutoAttributes['placement']}. */
    Tenuto.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {TenutoAttributes['relative-x']}. */
    Tenuto.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {TenutoAttributes['relative-x']}. */
    Tenuto.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {TenutoAttributes['relative-y']}. */
    Tenuto.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {TenutoAttributes['relative-y']}. */
    Tenuto.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Tenuto.schema = {
        name: 'tenuto',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Tenuto;
}());
exports.Tenuto = Tenuto;
/**
 * The `<detached-legato>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<detached-legato>` element indicates the combination of a tenuto line and staccato dot symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/detached-legato/}
 */
var DetachedLegato = /** @class */ (function () {
    function DetachedLegato(opts) {
        var _a;
        this.schema = DetachedLegato.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DetachedLegato.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DetachedLegato.schema.contents);
    }
    /** Gets @type {DetachedLegatoAttributes['color']}. */
    DetachedLegato.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DetachedLegatoAttributes['color']}. */
    DetachedLegato.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DetachedLegatoAttributes['default-x']}. */
    DetachedLegato.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DetachedLegatoAttributes['default-x']}. */
    DetachedLegato.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DetachedLegatoAttributes['default-y']}. */
    DetachedLegato.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DetachedLegatoAttributes['default-y']}. */
    DetachedLegato.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DetachedLegatoAttributes['font-family']}. */
    DetachedLegato.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DetachedLegatoAttributes['font-family']}. */
    DetachedLegato.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DetachedLegatoAttributes['font-size']}. */
    DetachedLegato.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DetachedLegatoAttributes['font-size']}. */
    DetachedLegato.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DetachedLegatoAttributes['font-style']}. */
    DetachedLegato.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DetachedLegatoAttributes['font-style']}. */
    DetachedLegato.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DetachedLegatoAttributes['font-weight']}. */
    DetachedLegato.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DetachedLegatoAttributes['font-weight']}. */
    DetachedLegato.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DetachedLegatoAttributes['placement']}. */
    DetachedLegato.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {DetachedLegatoAttributes['placement']}. */
    DetachedLegato.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {DetachedLegatoAttributes['relative-x']}. */
    DetachedLegato.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DetachedLegatoAttributes['relative-x']}. */
    DetachedLegato.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DetachedLegatoAttributes['relative-y']}. */
    DetachedLegato.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DetachedLegatoAttributes['relative-y']}. */
    DetachedLegato.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    DetachedLegato.schema = {
        name: 'detached-legato',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return DetachedLegato;
}());
exports.DetachedLegato = DetachedLegato;
/**
 * The `<staccatissimo>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<staccatissimo>` element is used for a wedge articulation, as opposed to a dot or a stroke.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staccatissimo/}
 */
var Staccatissimo = /** @class */ (function () {
    function Staccatissimo(opts) {
        var _a;
        this.schema = Staccatissimo.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Staccatissimo.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Staccatissimo.schema.contents);
    }
    /** Gets @type {StaccatissimoAttributes['color']}. */
    Staccatissimo.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {StaccatissimoAttributes['color']}. */
    Staccatissimo.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {StaccatissimoAttributes['default-x']}. */
    Staccatissimo.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {StaccatissimoAttributes['default-x']}. */
    Staccatissimo.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {StaccatissimoAttributes['default-y']}. */
    Staccatissimo.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {StaccatissimoAttributes['default-y']}. */
    Staccatissimo.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {StaccatissimoAttributes['font-family']}. */
    Staccatissimo.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {StaccatissimoAttributes['font-family']}. */
    Staccatissimo.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {StaccatissimoAttributes['font-size']}. */
    Staccatissimo.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {StaccatissimoAttributes['font-size']}. */
    Staccatissimo.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {StaccatissimoAttributes['font-style']}. */
    Staccatissimo.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {StaccatissimoAttributes['font-style']}. */
    Staccatissimo.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {StaccatissimoAttributes['font-weight']}. */
    Staccatissimo.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {StaccatissimoAttributes['font-weight']}. */
    Staccatissimo.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {StaccatissimoAttributes['placement']}. */
    Staccatissimo.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {StaccatissimoAttributes['placement']}. */
    Staccatissimo.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {StaccatissimoAttributes['relative-x']}. */
    Staccatissimo.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {StaccatissimoAttributes['relative-x']}. */
    Staccatissimo.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {StaccatissimoAttributes['relative-y']}. */
    Staccatissimo.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {StaccatissimoAttributes['relative-y']}. */
    Staccatissimo.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Staccatissimo.schema = {
        name: 'staccatissimo',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Staccatissimo;
}());
exports.Staccatissimo = Staccatissimo;
/**
 * The `<spiccato>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<spiccato>` element is used for a stroke articulation, as opposed to a dot or a wedge.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/spiccato/}
 */
var Spiccato = /** @class */ (function () {
    function Spiccato(opts) {
        var _a;
        this.schema = Spiccato.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Spiccato.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Spiccato.schema.contents);
    }
    /** Gets @type {SpiccatoAttributes['color']}. */
    Spiccato.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {SpiccatoAttributes['color']}. */
    Spiccato.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {SpiccatoAttributes['default-x']}. */
    Spiccato.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {SpiccatoAttributes['default-x']}. */
    Spiccato.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {SpiccatoAttributes['default-y']}. */
    Spiccato.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {SpiccatoAttributes['default-y']}. */
    Spiccato.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {SpiccatoAttributes['font-family']}. */
    Spiccato.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {SpiccatoAttributes['font-family']}. */
    Spiccato.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {SpiccatoAttributes['font-size']}. */
    Spiccato.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {SpiccatoAttributes['font-size']}. */
    Spiccato.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {SpiccatoAttributes['font-style']}. */
    Spiccato.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {SpiccatoAttributes['font-style']}. */
    Spiccato.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {SpiccatoAttributes['font-weight']}. */
    Spiccato.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {SpiccatoAttributes['font-weight']}. */
    Spiccato.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {SpiccatoAttributes['placement']}. */
    Spiccato.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {SpiccatoAttributes['placement']}. */
    Spiccato.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {SpiccatoAttributes['relative-x']}. */
    Spiccato.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {SpiccatoAttributes['relative-x']}. */
    Spiccato.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {SpiccatoAttributes['relative-y']}. */
    Spiccato.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {SpiccatoAttributes['relative-y']}. */
    Spiccato.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Spiccato.schema = {
        name: 'spiccato',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Spiccato;
}());
exports.Spiccato = Spiccato;
/**
 * The `<scoop>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<scoop>` element is an indeterminate slide attached to a single note. The scoop appears before the main note and
 * comes from below the main pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/scoop/}
 */
var Scoop = /** @class */ (function () {
    function Scoop(opts) {
        var _a;
        this.schema = Scoop.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Scoop.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Scoop.schema.contents);
    }
    /** Gets @type {ScoopAttributes['color']}. */
    Scoop.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {ScoopAttributes['color']}. */
    Scoop.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {ScoopAttributes['default-x']}. */
    Scoop.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {ScoopAttributes['default-x']}. */
    Scoop.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {ScoopAttributes['default-y']}. */
    Scoop.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {ScoopAttributes['default-y']}. */
    Scoop.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {ScoopAttributes['font-family']}. */
    Scoop.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {ScoopAttributes['font-family']}. */
    Scoop.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {ScoopAttributes['font-size']}. */
    Scoop.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {ScoopAttributes['font-size']}. */
    Scoop.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {ScoopAttributes['font-style']}. */
    Scoop.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {ScoopAttributes['font-style']}. */
    Scoop.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {ScoopAttributes['font-weight']}. */
    Scoop.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {ScoopAttributes['font-weight']}. */
    Scoop.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {ScoopAttributes['placement']}. */
    Scoop.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {ScoopAttributes['placement']}. */
    Scoop.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {ScoopAttributes['relative-x']}. */
    Scoop.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {ScoopAttributes['relative-x']}. */
    Scoop.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {ScoopAttributes['relative-y']}. */
    Scoop.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {ScoopAttributes['relative-y']}. */
    Scoop.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Scoop.schema = {
        name: 'scoop',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Scoop;
}());
exports.Scoop = Scoop;
/**
 * The `<plop>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<plop>` element is an indeterminate slide attached to a single note. The plop appears before the main note and
 * comes from above the main pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/plop/}
 */
var Plop = /** @class */ (function () {
    function Plop(opts) {
        var _a;
        this.schema = Plop.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Plop.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Plop.schema.contents);
    }
    /** Gets @type {PlopAttributes['color']}. */
    Plop.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {PlopAttributes['color']}. */
    Plop.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {PlopAttributes['dash-length']}. */
    Plop.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {PlopAttributes['dash-length']}. */
    Plop.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {PlopAttributes['default-x']}. */
    Plop.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {PlopAttributes['default-x']}. */
    Plop.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {PlopAttributes['default-y']}. */
    Plop.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {PlopAttributes['default-y']}. */
    Plop.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {PlopAttributes['font-family']}. */
    Plop.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PlopAttributes['font-family']}. */
    Plop.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PlopAttributes['font-size']}. */
    Plop.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PlopAttributes['font-size']}. */
    Plop.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PlopAttributes['font-style']}. */
    Plop.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PlopAttributes['font-style']}. */
    Plop.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PlopAttributes['font-weight']}. */
    Plop.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PlopAttributes['font-weight']}. */
    Plop.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {PlopAttributes['line-length']}. */
    Plop.prototype.getLineLength = function () {
        return this.attributes['line-length'];
    };
    /** Sets @type {PlopAttributes['line-length']}. */
    Plop.prototype.setLineLength = function (lineLength) {
        this.attributes['line-length'] = lineLength;
        return this;
    };
    /** Gets @type {PlopAttributes['line-shape']}. */
    Plop.prototype.getLineShape = function () {
        return this.attributes['line-shape'];
    };
    /** Sets @type {PlopAttributes['line-shape']}. */
    Plop.prototype.setLineShape = function (lineShape) {
        this.attributes['line-shape'] = lineShape;
        return this;
    };
    /** Gets @type {PlopAttributes['line-type']}. */
    Plop.prototype.getLineType = function () {
        return this.attributes['line-type'];
    };
    /** Sets @type {PlopAttributes['line-type']}. */
    Plop.prototype.setLineType = function (lineType) {
        this.attributes['line-type'] = lineType;
        return this;
    };
    /** Gets @type {PlopAttributes['placement']}. */
    Plop.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {PlopAttributes['placement']}. */
    Plop.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {PlopAttributes['relative-x']}. */
    Plop.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {PlopAttributes['relative-x']}. */
    Plop.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {PlopAttributes['relative-y']}. */
    Plop.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {PlopAttributes['relative-y']}. */
    Plop.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {PlopAttributes['space-length']}. */
    Plop.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {PlopAttributes['space-length']}. */
    Plop.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    Plop.schema = {
        name: 'plop',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'line-length': { type: 'optional', value: { type: 'choices', choices: ['short', 'medium', 'long'] } },
            'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
            'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return Plop;
}());
exports.Plop = Plop;
/**
 * The `<doit>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<doit>` element is an indeterminate slide attached to a single note. The doit appears after the main note and
 * goes above the main pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/doit/}
 */
var Doit = /** @class */ (function () {
    function Doit(opts) {
        var _a;
        this.schema = Doit.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Doit.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Doit.schema.contents);
    }
    /** Gets @type {DoitAttributes['color']}. */
    Doit.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DoitAttributes['color']}. */
    Doit.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DoitAttributes['dash-length']}. */
    Doit.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {DoitAttributes['dash-length']}. */
    Doit.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {DoitAttributes['default-x']}. */
    Doit.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DoitAttributes['default-x']}. */
    Doit.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DoitAttributes['default-y']}. */
    Doit.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DoitAttributes['default-y']}. */
    Doit.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DoitAttributes['font-family']}. */
    Doit.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DoitAttributes['font-family']}. */
    Doit.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DoitAttributes['font-size']}. */
    Doit.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DoitAttributes['font-size']}. */
    Doit.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DoitAttributes['font-style']}. */
    Doit.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DoitAttributes['font-style']}. */
    Doit.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DoitAttributes['font-weight']}. */
    Doit.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DoitAttributes['font-weight']}. */
    Doit.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DoitAttributes['line-length']}. */
    Doit.prototype.getLineLength = function () {
        return this.attributes['line-length'];
    };
    /** Sets @type {DoitAttributes['line-length']}. */
    Doit.prototype.setLineLength = function (lineLength) {
        this.attributes['line-length'] = lineLength;
        return this;
    };
    /** Gets @type {DoitAttributes['line-shape']}. */
    Doit.prototype.getLineShape = function () {
        return this.attributes['line-shape'];
    };
    /** Sets @type {DoitAttributes['line-shape']}. */
    Doit.prototype.setLineShape = function (lineShape) {
        this.attributes['line-shape'] = lineShape;
        return this;
    };
    /** Gets @type {DoitAttributes['line-type']}. */
    Doit.prototype.getLineType = function () {
        return this.attributes['line-type'];
    };
    /** Sets @type {DoitAttributes['line-type']}. */
    Doit.prototype.setLineType = function (lineType) {
        this.attributes['line-type'] = lineType;
        return this;
    };
    /** Gets @type {DoitAttributes['placement']}. */
    Doit.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {DoitAttributes['placement']}. */
    Doit.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {DoitAttributes['relative-x']}. */
    Doit.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DoitAttributes['relative-x']}. */
    Doit.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DoitAttributes['relative-y']}. */
    Doit.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DoitAttributes['relative-y']}. */
    Doit.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DoitAttributes['space-length']}. */
    Doit.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {DoitAttributes['space-length']}. */
    Doit.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    Doit.schema = {
        name: 'doit',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'line-length': { type: 'optional', value: { type: 'choices', choices: ['short', 'medium', 'long'] } },
            'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
            'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return Doit;
}());
exports.Doit = Doit;
/**
 * The `<falloff>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<falloff>` element is an indeterminate slide attached to a single note. The falloff appears after the main note
 * and goes below the main pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/falloff/}
 */
var Falloff = /** @class */ (function () {
    function Falloff(opts) {
        var _a;
        this.schema = Falloff.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Falloff.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Falloff.schema.contents);
    }
    /** Gets @type {FalloffAttributes['color']}. */
    Falloff.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FalloffAttributes['color']}. */
    Falloff.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FalloffAttributes['dash-length']}. */
    Falloff.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {FalloffAttributes['dash-length']}. */
    Falloff.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {FalloffAttributes['default-x']}. */
    Falloff.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {FalloffAttributes['default-x']}. */
    Falloff.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {FalloffAttributes['default-y']}. */
    Falloff.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {FalloffAttributes['default-y']}. */
    Falloff.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {FalloffAttributes['font-family']}. */
    Falloff.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FalloffAttributes['font-family']}. */
    Falloff.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FalloffAttributes['font-size']}. */
    Falloff.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FalloffAttributes['font-size']}. */
    Falloff.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FalloffAttributes['font-style']}. */
    Falloff.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FalloffAttributes['font-style']}. */
    Falloff.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FalloffAttributes['font-weight']}. */
    Falloff.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FalloffAttributes['font-weight']}. */
    Falloff.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {FalloffAttributes['line-length']}. */
    Falloff.prototype.getLineLength = function () {
        return this.attributes['line-length'];
    };
    /** Sets @type {FalloffAttributes['line-length']}. */
    Falloff.prototype.setLineLength = function (lineLength) {
        this.attributes['line-length'] = lineLength;
        return this;
    };
    /** Gets @type {FalloffAttributes['line-shape']}. */
    Falloff.prototype.getLineShape = function () {
        return this.attributes['line-shape'];
    };
    /** Sets @type {FalloffAttributes['line-shape']}. */
    Falloff.prototype.setLineShape = function (lineShape) {
        this.attributes['line-shape'] = lineShape;
        return this;
    };
    /** Gets @type {FalloffAttributes['line-type']}. */
    Falloff.prototype.getLineType = function () {
        return this.attributes['line-type'];
    };
    /** Sets @type {FalloffAttributes['line-type']}. */
    Falloff.prototype.setLineType = function (lineType) {
        this.attributes['line-type'] = lineType;
        return this;
    };
    /** Gets @type {FalloffAttributes['placement']}. */
    Falloff.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {FalloffAttributes['placement']}. */
    Falloff.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {FalloffAttributes['relative-x']}. */
    Falloff.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {FalloffAttributes['relative-x']}. */
    Falloff.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {FalloffAttributes['relative-y']}. */
    Falloff.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {FalloffAttributes['relative-y']}. */
    Falloff.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {FalloffAttributes['space-length']}. */
    Falloff.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {FalloffAttributes['space-length']}. */
    Falloff.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    Falloff.schema = {
        name: 'falloff',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'line-length': { type: 'optional', value: { type: 'choices', choices: ['short', 'medium', 'long'] } },
            'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
            'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return Falloff;
}());
exports.Falloff = Falloff;
/**
 * The `<breath-mark>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<breath-mark>` element indicates a place to take a breath.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/breath-mark/}
 */
var BreathMark = /** @class */ (function () {
    function BreathMark(opts) {
        var _a;
        this.schema = BreathMark.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BreathMark.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BreathMark.schema.contents);
    }
    /** Gets @type {BreathMarkAttributes['color']}. */
    BreathMark.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {BreathMarkAttributes['color']}. */
    BreathMark.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {BreathMarkAttributes['default-x']}. */
    BreathMark.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {BreathMarkAttributes['default-x']}. */
    BreathMark.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {BreathMarkAttributes['default-y']}. */
    BreathMark.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {BreathMarkAttributes['default-y']}. */
    BreathMark.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {BreathMarkAttributes['font-family']}. */
    BreathMark.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {BreathMarkAttributes['font-family']}. */
    BreathMark.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {BreathMarkAttributes['font-size']}. */
    BreathMark.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {BreathMarkAttributes['font-size']}. */
    BreathMark.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {BreathMarkAttributes['font-style']}. */
    BreathMark.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {BreathMarkAttributes['font-style']}. */
    BreathMark.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {BreathMarkAttributes['font-weight']}. */
    BreathMark.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {BreathMarkAttributes['font-weight']}. */
    BreathMark.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {BreathMarkAttributes['placement']}. */
    BreathMark.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {BreathMarkAttributes['placement']}. */
    BreathMark.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {BreathMarkAttributes['relative-x']}. */
    BreathMark.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {BreathMarkAttributes['relative-x']}. */
    BreathMark.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {BreathMarkAttributes['relative-y']}. */
    BreathMark.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {BreathMarkAttributes['relative-y']}. */
    BreathMark.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {'comma' | 'tick' | 'upbow' | 'salzedo' | '' | null}. */
    BreathMark.prototype.getBreathMarkValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'comma' | 'tick' | 'upbow' | 'salzedo' | '' | null}. */
    BreathMark.prototype.setBreathMarkValue = function (breathMarkValue) {
        this.contents[0] = breathMarkValue;
        return this;
    };
    BreathMark.schema = {
        name: 'breath-mark',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [
            {
                type: 'optional',
                value: {
                    type: 'label',
                    label: 'breath-mark-value',
                    value: { type: 'choices', choices: ['comma', 'tick', 'upbow', 'salzedo', ''] },
                },
            },
        ],
    };
    return BreathMark;
}());
exports.BreathMark = BreathMark;
/**
 * The `<caesura>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<caesura>` element indicates a slight pause. It is notated using a "railroad tracks" symbol or other variations
 * specified in the element content.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/caesura/}
 */
var Caesura = /** @class */ (function () {
    function Caesura(opts) {
        var _a;
        this.schema = Caesura.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Caesura.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Caesura.schema.contents);
    }
    /** Gets @type {CaesuraAttributes['color']}. */
    Caesura.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {CaesuraAttributes['color']}. */
    Caesura.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {CaesuraAttributes['default-x']}. */
    Caesura.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {CaesuraAttributes['default-x']}. */
    Caesura.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {CaesuraAttributes['default-y']}. */
    Caesura.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {CaesuraAttributes['default-y']}. */
    Caesura.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {CaesuraAttributes['font-family']}. */
    Caesura.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {CaesuraAttributes['font-family']}. */
    Caesura.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {CaesuraAttributes['font-size']}. */
    Caesura.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {CaesuraAttributes['font-size']}. */
    Caesura.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {CaesuraAttributes['font-style']}. */
    Caesura.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {CaesuraAttributes['font-style']}. */
    Caesura.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {CaesuraAttributes['font-weight']}. */
    Caesura.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {CaesuraAttributes['font-weight']}. */
    Caesura.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {CaesuraAttributes['placement']}. */
    Caesura.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {CaesuraAttributes['placement']}. */
    Caesura.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {CaesuraAttributes['relative-x']}. */
    Caesura.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {CaesuraAttributes['relative-x']}. */
    Caesura.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {CaesuraAttributes['relative-y']}. */
    Caesura.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {CaesuraAttributes['relative-y']}. */
    Caesura.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {'normal' | 'thick' | 'short' | 'curved' | 'single' | '' | null}. */
    Caesura.prototype.getCaesuraValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'normal' | 'thick' | 'short' | 'curved' | 'single' | '' | null}. */
    Caesura.prototype.setCaesuraValue = function (caesuraValue) {
        this.contents[0] = caesuraValue;
        return this;
    };
    Caesura.schema = {
        name: 'caesura',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [
            {
                type: 'optional',
                value: {
                    type: 'label',
                    label: 'caesura-value',
                    value: { type: 'choices', choices: ['normal', 'thick', 'short', 'curved', 'single', ''] },
                },
            },
        ],
    };
    return Caesura;
}());
exports.Caesura = Caesura;
/**
 * The `<stress>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<stress>` element indicates a stressed note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stress/}
 */
var Stress = /** @class */ (function () {
    function Stress(opts) {
        var _a;
        this.schema = Stress.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Stress.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Stress.schema.contents);
    }
    /** Gets @type {StressAttributes['color']}. */
    Stress.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {StressAttributes['color']}. */
    Stress.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {StressAttributes['default-x']}. */
    Stress.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {StressAttributes['default-x']}. */
    Stress.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {StressAttributes['default-y']}. */
    Stress.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {StressAttributes['default-y']}. */
    Stress.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {StressAttributes['font-family']}. */
    Stress.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {StressAttributes['font-family']}. */
    Stress.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {StressAttributes['font-size']}. */
    Stress.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {StressAttributes['font-size']}. */
    Stress.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {StressAttributes['font-style']}. */
    Stress.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {StressAttributes['font-style']}. */
    Stress.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {StressAttributes['font-weight']}. */
    Stress.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {StressAttributes['font-weight']}. */
    Stress.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {StressAttributes['placement']}. */
    Stress.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {StressAttributes['placement']}. */
    Stress.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {StressAttributes['relative-x']}. */
    Stress.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {StressAttributes['relative-x']}. */
    Stress.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {StressAttributes['relative-y']}. */
    Stress.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {StressAttributes['relative-y']}. */
    Stress.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Stress.schema = {
        name: 'stress',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Stress;
}());
exports.Stress = Stress;
/**
 * The `<unstress>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<unstress>` element indicates an unstressed note. It is often notated using a u-shaped symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/unstress/}
 */
var Unstress = /** @class */ (function () {
    function Unstress(opts) {
        var _a;
        this.schema = Unstress.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Unstress.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Unstress.schema.contents);
    }
    /** Gets @type {UnstressAttributes['color']}. */
    Unstress.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {UnstressAttributes['color']}. */
    Unstress.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {UnstressAttributes['default-x']}. */
    Unstress.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {UnstressAttributes['default-x']}. */
    Unstress.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {UnstressAttributes['default-y']}. */
    Unstress.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {UnstressAttributes['default-y']}. */
    Unstress.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {UnstressAttributes['font-family']}. */
    Unstress.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {UnstressAttributes['font-family']}. */
    Unstress.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {UnstressAttributes['font-size']}. */
    Unstress.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {UnstressAttributes['font-size']}. */
    Unstress.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {UnstressAttributes['font-style']}. */
    Unstress.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {UnstressAttributes['font-style']}. */
    Unstress.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {UnstressAttributes['font-weight']}. */
    Unstress.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {UnstressAttributes['font-weight']}. */
    Unstress.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {UnstressAttributes['placement']}. */
    Unstress.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {UnstressAttributes['placement']}. */
    Unstress.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {UnstressAttributes['relative-x']}. */
    Unstress.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {UnstressAttributes['relative-x']}. */
    Unstress.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {UnstressAttributes['relative-y']}. */
    Unstress.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {UnstressAttributes['relative-y']}. */
    Unstress.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    Unstress.schema = {
        name: 'unstress',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return Unstress;
}());
exports.Unstress = Unstress;
/**
 * The `<soft-accent>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<soft-accent>` element indicates a soft accent that is not as heavy as a normal accent. It is often notated as
 * <>. It can be combined with other articulations to implement the first eight symbols in the Standard Music Font
 * Layout (SMuFL) [Articulation supplement](https://www.w3.org/2021/03/smufl14/tables/articulation-supplement.html)
 * range.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/soft-accent/}
 */
var SoftAccent = /** @class */ (function () {
    function SoftAccent(opts) {
        var _a;
        this.schema = SoftAccent.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SoftAccent.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SoftAccent.schema.contents);
    }
    /** Gets @type {SoftAccentAttributes['color']}. */
    SoftAccent.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {SoftAccentAttributes['color']}. */
    SoftAccent.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {SoftAccentAttributes['default-x']}. */
    SoftAccent.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {SoftAccentAttributes['default-x']}. */
    SoftAccent.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {SoftAccentAttributes['default-y']}. */
    SoftAccent.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {SoftAccentAttributes['default-y']}. */
    SoftAccent.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {SoftAccentAttributes['font-family']}. */
    SoftAccent.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {SoftAccentAttributes['font-family']}. */
    SoftAccent.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {SoftAccentAttributes['font-size']}. */
    SoftAccent.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {SoftAccentAttributes['font-size']}. */
    SoftAccent.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {SoftAccentAttributes['font-style']}. */
    SoftAccent.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {SoftAccentAttributes['font-style']}. */
    SoftAccent.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {SoftAccentAttributes['font-weight']}. */
    SoftAccent.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {SoftAccentAttributes['font-weight']}. */
    SoftAccent.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {SoftAccentAttributes['placement']}. */
    SoftAccent.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {SoftAccentAttributes['placement']}. */
    SoftAccent.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {SoftAccentAttributes['relative-x']}. */
    SoftAccent.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {SoftAccentAttributes['relative-x']}. */
    SoftAccent.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {SoftAccentAttributes['relative-y']}. */
    SoftAccent.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {SoftAccentAttributes['relative-y']}. */
    SoftAccent.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    SoftAccent.schema = {
        name: 'soft-accent',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return SoftAccent;
}());
exports.SoftAccent = SoftAccent;
/**
 * The `<other-articulation>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<other-articulation>` element is used to define any articulations not yet in the MusicXML format. The smufl
 * attribute can be used to specify a particular articulation, allowing application interoperability without requiring
 * every Standard Music Font Layout (SMuFL) articulation to have a MusicXML element equivalent. Using the
 * `<other-articulation>` element without the smufl attribute allows for extended representation, though without
 * application interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-articulation/}
 */
var OtherArticulation = /** @class */ (function () {
    function OtherArticulation(opts) {
        var _a;
        this.schema = OtherArticulation.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherArticulation.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherArticulation.schema.contents);
    }
    /** Gets @type {OtherArticulationAttributes['color']}. */
    OtherArticulation.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {OtherArticulationAttributes['color']}. */
    OtherArticulation.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {OtherArticulationAttributes['default-x']}. */
    OtherArticulation.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {OtherArticulationAttributes['default-x']}. */
    OtherArticulation.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {OtherArticulationAttributes['default-y']}. */
    OtherArticulation.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {OtherArticulationAttributes['default-y']}. */
    OtherArticulation.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {OtherArticulationAttributes['font-family']}. */
    OtherArticulation.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {OtherArticulationAttributes['font-family']}. */
    OtherArticulation.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {OtherArticulationAttributes['font-size']}. */
    OtherArticulation.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {OtherArticulationAttributes['font-size']}. */
    OtherArticulation.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {OtherArticulationAttributes['font-style']}. */
    OtherArticulation.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {OtherArticulationAttributes['font-style']}. */
    OtherArticulation.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {OtherArticulationAttributes['font-weight']}. */
    OtherArticulation.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {OtherArticulationAttributes['font-weight']}. */
    OtherArticulation.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {OtherArticulationAttributes['placement']}. */
    OtherArticulation.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {OtherArticulationAttributes['placement']}. */
    OtherArticulation.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {OtherArticulationAttributes['relative-x']}. */
    OtherArticulation.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {OtherArticulationAttributes['relative-x']}. */
    OtherArticulation.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {OtherArticulationAttributes['relative-y']}. */
    OtherArticulation.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {OtherArticulationAttributes['relative-y']}. */
    OtherArticulation.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {OtherArticulationAttributes['smufl']}. */
    OtherArticulation.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {OtherArticulationAttributes['smufl']}. */
    OtherArticulation.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    OtherArticulation.schema = {
        name: 'other-articulation',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: { type: 'optional', value: { type: 'string' } },
        },
        contents: [],
    };
    return OtherArticulation;
}());
exports.OtherArticulation = OtherArticulation;
/**
 * The `<articulations>` element
 *
 * Parent element: `<notations>`
 *
 * The `<articulations>` element groups together articulations and accents.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/articulations/}
 */
var Articulations = /** @class */ (function () {
    function Articulations(opts) {
        var _a;
        this.schema = Articulations.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Articulations.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Articulations.schema.contents);
    }
    /** Gets @type {ArticulationsAttributes['id']}. */
    Articulations.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {ArticulationsAttributes['id']}. */
    Articulations.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {Array<Accent | StrongAccent | Staccato | Tenuto | DetachedLegato | Staccatissimo | Spiccato | Scoop | Plop | Doit | Falloff | BreathMark | Caesura | Stress | Unstress | SoftAccent | OtherArticulation>}. */
    Articulations.prototype.getArticulations = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Accent | StrongAccent | Staccato | Tenuto | DetachedLegato | Staccatissimo | Spiccato | Scoop | Plop | Doit | Falloff | BreathMark | Caesura | Stress | Unstress | SoftAccent | OtherArticulation>}. */
    Articulations.prototype.setArticulations = function (articulations) {
        this.contents[0] = articulations;
        return this;
    };
    Articulations.schema = {
        name: 'articulations',
        attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [
            {
                type: 'label',
                label: 'articulations',
                value: {
                    type: 'zeroOrMore',
                    value: {
                        type: 'choices',
                        choices: [
                            Accent,
                            StrongAccent,
                            Staccato,
                            Tenuto,
                            DetachedLegato,
                            Staccatissimo,
                            Spiccato,
                            Scoop,
                            Plop,
                            Doit,
                            Falloff,
                            BreathMark,
                            Caesura,
                            Stress,
                            Unstress,
                            SoftAccent,
                            OtherArticulation,
                        ],
                    },
                },
            },
        ],
    };
    return Articulations;
}());
exports.Articulations = Articulations;
/**
 * The `<p>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<p>` element represents a piano dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/p/}
 */
var P = /** @class */ (function () {
    function P(opts) {
        var _a;
        this.schema = P.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, P.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(P.schema.contents);
    }
    P.schema = { name: 'p', attributes: {}, contents: [] };
    return P;
}());
exports.P = P;
/**
 * The `<pp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<pp>` element represents a pianissimo dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pp/}
 */
var Pp = /** @class */ (function () {
    function Pp(opts) {
        var _a;
        this.schema = Pp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Pp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Pp.schema.contents);
    }
    Pp.schema = { name: 'pp', attributes: {}, contents: [] };
    return Pp;
}());
exports.Pp = Pp;
/**
 * The `<ppp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<ppp>` element represents a triple piano dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ppp/}
 */
var Ppp = /** @class */ (function () {
    function Ppp(opts) {
        var _a;
        this.schema = Ppp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Ppp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Ppp.schema.contents);
    }
    Ppp.schema = { name: 'ppp', attributes: {}, contents: [] };
    return Ppp;
}());
exports.Ppp = Ppp;
/**
 * The `<pppp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<pppp>` element represents a pppp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pppp/}
 */
var Pppp = /** @class */ (function () {
    function Pppp(opts) {
        var _a;
        this.schema = Pppp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Pppp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Pppp.schema.contents);
    }
    Pppp.schema = { name: 'pppp', attributes: {}, contents: [] };
    return Pppp;
}());
exports.Pppp = Pppp;
/**
 * The `<ppppp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<ppppp>` element represents a ppppp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ppppp/}
 */
var Ppppp = /** @class */ (function () {
    function Ppppp(opts) {
        var _a;
        this.schema = Ppppp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Ppppp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Ppppp.schema.contents);
    }
    Ppppp.schema = { name: 'ppppp', attributes: {}, contents: [] };
    return Ppppp;
}());
exports.Ppppp = Ppppp;
/**
 * The `<pppppp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<pppppp>` element represents a pppppp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pppppp/}
 */
var Pppppp = /** @class */ (function () {
    function Pppppp(opts) {
        var _a;
        this.schema = Pppppp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Pppppp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Pppppp.schema.contents);
    }
    Pppppp.schema = { name: 'pppppp', attributes: {}, contents: [] };
    return Pppppp;
}());
exports.Pppppp = Pppppp;
/**
 * The `<f>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<f>` element represents a forte dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/f/}
 */
var F = /** @class */ (function () {
    function F(opts) {
        var _a;
        this.schema = F.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, F.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(F.schema.contents);
    }
    F.schema = { name: 'f', attributes: {}, contents: [] };
    return F;
}());
exports.F = F;
/**
 * The `<ff>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<ff>` element represents a fortissimo dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ff/}
 */
var Ff = /** @class */ (function () {
    function Ff(opts) {
        var _a;
        this.schema = Ff.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Ff.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Ff.schema.contents);
    }
    Ff.schema = { name: 'ff', attributes: {}, contents: [] };
    return Ff;
}());
exports.Ff = Ff;
/**
 * The `<fff>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<fff>` element represents a triple forte dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fff/}
 */
var Fff = /** @class */ (function () {
    function Fff(opts) {
        var _a;
        this.schema = Fff.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Fff.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Fff.schema.contents);
    }
    Fff.schema = { name: 'fff', attributes: {}, contents: [] };
    return Fff;
}());
exports.Fff = Fff;
/**
 * The `<ffff>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<ffff>` element represents an ffff dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ffff/}
 */
var Ffff = /** @class */ (function () {
    function Ffff(opts) {
        var _a;
        this.schema = Ffff.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Ffff.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Ffff.schema.contents);
    }
    Ffff.schema = { name: 'ffff', attributes: {}, contents: [] };
    return Ffff;
}());
exports.Ffff = Ffff;
/**
 * The `<fffff>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<fffff>` element represents an fffff dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fffff/}
 */
var Fffff = /** @class */ (function () {
    function Fffff(opts) {
        var _a;
        this.schema = Fffff.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Fffff.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Fffff.schema.contents);
    }
    Fffff.schema = { name: 'fffff', attributes: {}, contents: [] };
    return Fffff;
}());
exports.Fffff = Fffff;
/**
 * The `<ffffff>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<ffffff>` element represents an ffffff dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ffffff/}
 */
var Ffffff = /** @class */ (function () {
    function Ffffff(opts) {
        var _a;
        this.schema = Ffffff.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Ffffff.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Ffffff.schema.contents);
    }
    Ffffff.schema = { name: 'ffffff', attributes: {}, contents: [] };
    return Ffffff;
}());
exports.Ffffff = Ffffff;
/**
 * The `<mp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<mp>` element represents a mezzo piano dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/mp/}
 */
var Mp = /** @class */ (function () {
    function Mp(opts) {
        var _a;
        this.schema = Mp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Mp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Mp.schema.contents);
    }
    Mp.schema = { name: 'mp', attributes: {}, contents: [] };
    return Mp;
}());
exports.Mp = Mp;
/**
 * The `<mf>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<mf>` element represents a mezzo forte dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/mf/}
 */
var Mf = /** @class */ (function () {
    function Mf(opts) {
        var _a;
        this.schema = Mf.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Mf.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Mf.schema.contents);
    }
    Mf.schema = { name: 'mf', attributes: {}, contents: [] };
    return Mf;
}());
exports.Mf = Mf;
/**
 * The `<sf>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sf>` element represents a sforzando sf dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sf/}
 */
var Sf = /** @class */ (function () {
    function Sf(opts) {
        var _a;
        this.schema = Sf.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Sf.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Sf.schema.contents);
    }
    Sf.schema = { name: 'sf', attributes: {}, contents: [] };
    return Sf;
}());
exports.Sf = Sf;
/**
 * The `<sfp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sfp>` element represents a sforzando piano sfp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sfp/}
 */
var Sfp = /** @class */ (function () {
    function Sfp(opts) {
        var _a;
        this.schema = Sfp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Sfp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Sfp.schema.contents);
    }
    Sfp.schema = { name: 'sfp', attributes: {}, contents: [] };
    return Sfp;
}());
exports.Sfp = Sfp;
/**
 * The `<sfpp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sfpp>` element represents a sforzando pianissimo sfpp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sfpp/}
 */
var Sfpp = /** @class */ (function () {
    function Sfpp(opts) {
        var _a;
        this.schema = Sfpp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Sfpp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Sfpp.schema.contents);
    }
    Sfpp.schema = { name: 'sfpp', attributes: {}, contents: [] };
    return Sfpp;
}());
exports.Sfpp = Sfpp;
/**
 * The `<fp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<fp>` element represents a forte piano dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fp/}
 */
var Fp = /** @class */ (function () {
    function Fp(opts) {
        var _a;
        this.schema = Fp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Fp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Fp.schema.contents);
    }
    Fp.schema = { name: 'fp', attributes: {}, contents: [] };
    return Fp;
}());
exports.Fp = Fp;
/**
 * The `<rf>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<rf>` element represents a rinforzando rf dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/rf/}
 */
var Rf = /** @class */ (function () {
    function Rf(opts) {
        var _a;
        this.schema = Rf.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Rf.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Rf.schema.contents);
    }
    Rf.schema = { name: 'rf', attributes: {}, contents: [] };
    return Rf;
}());
exports.Rf = Rf;
/**
 * The `<rfz>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<rfz>` element represents a rinforzando rfz dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/rfz/}
 */
var Rfz = /** @class */ (function () {
    function Rfz(opts) {
        var _a;
        this.schema = Rfz.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Rfz.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Rfz.schema.contents);
    }
    Rfz.schema = { name: 'rfz', attributes: {}, contents: [] };
    return Rfz;
}());
exports.Rfz = Rfz;
/**
 * The `<sfz>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sfz>` element represents a sforzando sfz dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sfz/}
 */
var Sfz = /** @class */ (function () {
    function Sfz(opts) {
        var _a;
        this.schema = Sfz.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Sfz.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Sfz.schema.contents);
    }
    Sfz.schema = { name: 'sfz', attributes: {}, contents: [] };
    return Sfz;
}());
exports.Sfz = Sfz;
/**
 * The `<sffz>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sffz>` element represents a sforzando sffz dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sffz/}
 */
var Sffz = /** @class */ (function () {
    function Sffz(opts) {
        var _a;
        this.schema = Sffz.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Sffz.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Sffz.schema.contents);
    }
    Sffz.schema = { name: 'sffz', attributes: {}, contents: [] };
    return Sffz;
}());
exports.Sffz = Sffz;
/**
 * The `<fz>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<fz>` element represents a forzando fz dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fz/}
 */
var Fz = /** @class */ (function () {
    function Fz(opts) {
        var _a;
        this.schema = Fz.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Fz.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Fz.schema.contents);
    }
    Fz.schema = { name: 'fz', attributes: {}, contents: [] };
    return Fz;
}());
exports.Fz = Fz;
/**
 * The `<n>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<n>` element represents a niente dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/n/}
 */
var N = /** @class */ (function () {
    function N(opts) {
        var _a;
        this.schema = N.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, N.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(N.schema.contents);
    }
    N.schema = { name: 'n', attributes: {}, contents: [] };
    return N;
}());
exports.N = N;
/**
 * The `<pf>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<pf>` element represents a piano forte dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pf/}
 */
var Pf = /** @class */ (function () {
    function Pf(opts) {
        var _a;
        this.schema = Pf.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Pf.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Pf.schema.contents);
    }
    Pf.schema = { name: 'pf', attributes: {}, contents: [] };
    return Pf;
}());
exports.Pf = Pf;
/**
 * The `<sfzp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sfzp>` element represents a sforzando piano sfzp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sfzp/}
 */
var Sfzp = /** @class */ (function () {
    function Sfzp(opts) {
        var _a;
        this.schema = Sfzp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Sfzp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Sfzp.schema.contents);
    }
    Sfzp.schema = { name: 'sfzp', attributes: {}, contents: [] };
    return Sfzp;
}());
exports.Sfzp = Sfzp;
/**
 * The `<other-dynamics>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<other-dynamics>` element allows other dynamic marks that are not covered by combinations of the individual
 * `<dynamics>` child elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-dynamics/}
 */
var OtherDynamics = /** @class */ (function () {
    function OtherDynamics(opts) {
        var _a;
        this.schema = OtherDynamics.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherDynamics.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherDynamics.schema.contents);
    }
    /** Gets @type {OtherDynamicsAttributes['smufl']}. */
    OtherDynamics.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {OtherDynamicsAttributes['smufl']}. */
    OtherDynamics.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {string}. */
    OtherDynamics.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    OtherDynamics.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    OtherDynamics.schema = {
        name: 'other-dynamics',
        attributes: { smufl: { type: 'optional', value: { type: 'string' } } },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return OtherDynamics;
}());
exports.OtherDynamics = OtherDynamics;
/**
 * The `<dynamics>` element
 *
 * Parent elements: `<direction-type>`, `<notations>`
 *
 * Dynamics can be associated either with a note or a general musical direction. To avoid inconsistencies between and
 * amongst the letter abbreviations for dynamics (what is sf vs. sfz, standing alone or with a trailing dynamic that is
 * not always piano), we use the actual letters as the names of these dynamic elements. The `<other-dynamics>` element
 * allows other dynamic marks that are not covered here. Dynamics elements may also be combined to create marks not
 * covered by a single element, such as `<sf/>``<mp/>`.
 *
 * These letter dynamic symbols are separated from crescendo, decrescendo, and wedge indications. Dynamic representation
 * is inconsistent in scores. Many things are assumed by the composer and left out, such as returns to original
 * dynamics. The MusicXML format captures what is in the score, but does not try to be optimal for analysis or synthesis
 * of dynamics.
 *
 * The placement attribute is used when the dynamics are associated with a `<note>`. It is ignored when the dynamics are
 * associated with a `<direction>`. In that case the `<direction>` element's placement attribute is used instead.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/dynamics/}
 */
var Dynamics = /** @class */ (function () {
    function Dynamics(opts) {
        var _a;
        this.schema = Dynamics.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Dynamics.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Dynamics.schema.contents);
    }
    /** Gets @type {DynamicsAttributes['color']}. */
    Dynamics.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DynamicsAttributes['color']}. */
    Dynamics.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DynamicsAttributes['default-x']}. */
    Dynamics.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DynamicsAttributes['default-x']}. */
    Dynamics.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DynamicsAttributes['default-y']}. */
    Dynamics.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DynamicsAttributes['default-y']}. */
    Dynamics.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DynamicsAttributes['enclosure']}. */
    Dynamics.prototype.getEnclosure = function () {
        return this.attributes['enclosure'];
    };
    /** Sets @type {DynamicsAttributes['enclosure']}. */
    Dynamics.prototype.setEnclosure = function (enclosure) {
        this.attributes['enclosure'] = enclosure;
        return this;
    };
    /** Gets @type {DynamicsAttributes['font-family']}. */
    Dynamics.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DynamicsAttributes['font-family']}. */
    Dynamics.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DynamicsAttributes['font-size']}. */
    Dynamics.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DynamicsAttributes['font-size']}. */
    Dynamics.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DynamicsAttributes['font-style']}. */
    Dynamics.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DynamicsAttributes['font-style']}. */
    Dynamics.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DynamicsAttributes['font-weight']}. */
    Dynamics.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DynamicsAttributes['font-weight']}. */
    Dynamics.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DynamicsAttributes['halign']}. */
    Dynamics.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {DynamicsAttributes['halign']}. */
    Dynamics.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {DynamicsAttributes['id']}. */
    Dynamics.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {DynamicsAttributes['id']}. */
    Dynamics.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {DynamicsAttributes['overline']}. */
    Dynamics.prototype.getOverline = function () {
        return this.attributes['overline'];
    };
    /** Sets @type {DynamicsAttributes['overline']}. */
    Dynamics.prototype.setOverline = function (overline) {
        this.attributes['overline'] = overline;
        return this;
    };
    /** Gets @type {DynamicsAttributes['placement']}. */
    Dynamics.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {DynamicsAttributes['placement']}. */
    Dynamics.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {DynamicsAttributes['line-through']}. */
    Dynamics.prototype.getLineThrough = function () {
        return this.attributes['line-through'];
    };
    /** Sets @type {DynamicsAttributes['line-through']}. */
    Dynamics.prototype.setLineThrough = function (lineThrough) {
        this.attributes['line-through'] = lineThrough;
        return this;
    };
    /** Gets @type {DynamicsAttributes['relative-x']}. */
    Dynamics.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DynamicsAttributes['relative-x']}. */
    Dynamics.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DynamicsAttributes['relative-y']}. */
    Dynamics.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DynamicsAttributes['relative-y']}. */
    Dynamics.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DynamicsAttributes['underline']}. */
    Dynamics.prototype.getUnderline = function () {
        return this.attributes['underline'];
    };
    /** Sets @type {DynamicsAttributes['underline']}. */
    Dynamics.prototype.setUnderline = function (underline) {
        this.attributes['underline'] = underline;
        return this;
    };
    /** Gets @type {DynamicsAttributes['valign']}. */
    Dynamics.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {DynamicsAttributes['valign']}. */
    Dynamics.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {Array<P | Pp | Ppp | Pppp | Ppppp | Pppppp | F | Ff | Fff | Ffff | Fffff | Fffff | Ffffff | Mp | Mf | Sf | Sfp | Sfpp | Fp | Rf | Rfz | Sfz | Sffz | Fz | N | Pf | Sfzp | OtherDynamics>}. */
    Dynamics.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<P | Pp | Ppp | Pppp | Ppppp | Pppppp | F | Ff | Fff | Ffff | Fffff | Fffff | Ffffff | Mp | Mf | Sf | Sfp | Sfpp | Fp | Rf | Rfz | Sfz | Sffz | Fz | N | Pf | Sfzp | OtherDynamics>}. */
    Dynamics.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Dynamics.schema = {
        name: 'dynamics',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            enclosure: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        'none',
                        'rectangle',
                        'square',
                        'oval',
                        'circle',
                        'bracket',
                        'inverted-bracket',
                        'triangle',
                        'diamond',
                        'pentagon',
                        'hexagon',
                        'heptagon',
                        'octagon',
                        'nonagon',
                        'decagon',
                    ],
                },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [
            {
                type: 'label',
                label: 'value',
                value: {
                    type: 'zeroOrMore',
                    value: {
                        type: 'choices',
                        choices: [
                            P,
                            Pp,
                            Ppp,
                            Pppp,
                            Ppppp,
                            Pppppp,
                            F,
                            Ff,
                            Fff,
                            Ffff,
                            Fffff,
                            Fffff,
                            Ffffff,
                            Mp,
                            Mf,
                            Sf,
                            Sfp,
                            Sfpp,
                            Fp,
                            Rf,
                            Rfz,
                            Sfz,
                            Sffz,
                            Fz,
                            N,
                            Pf,
                            Sfzp,
                            OtherDynamics,
                        ],
                    },
                },
            },
        ],
    };
    return Dynamics;
}());
exports.Dynamics = Dynamics;
/**
 * The `<fermata>` element
 *
 * Parent elements: `<barline>`, `<notations>`
 *
 * The `<fermata>` element content represents the shape of the fermata sign. An empty `<fermata>` element represents a
 * normal fermata.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fermata/}
 */
var Fermata = /** @class */ (function () {
    function Fermata(opts) {
        var _a;
        this.schema = Fermata.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Fermata.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Fermata.schema.contents);
    }
    /** Gets @type {FermataAttributes['color']}. */
    Fermata.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FermataAttributes['color']}. */
    Fermata.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FermataAttributes['default-x']}. */
    Fermata.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {FermataAttributes['default-x']}. */
    Fermata.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {FermataAttributes['default-y']}. */
    Fermata.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {FermataAttributes['default-y']}. */
    Fermata.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {FermataAttributes['font-family']}. */
    Fermata.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FermataAttributes['font-family']}. */
    Fermata.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FermataAttributes['font-size']}. */
    Fermata.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FermataAttributes['font-size']}. */
    Fermata.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FermataAttributes['font-style']}. */
    Fermata.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FermataAttributes['font-style']}. */
    Fermata.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FermataAttributes['font-weight']}. */
    Fermata.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FermataAttributes['font-weight']}. */
    Fermata.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {FermataAttributes['id']}. */
    Fermata.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {FermataAttributes['id']}. */
    Fermata.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {FermataAttributes['relative-x']}. */
    Fermata.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {FermataAttributes['relative-x']}. */
    Fermata.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {FermataAttributes['relative-y']}. */
    Fermata.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {FermataAttributes['relative-y']}. */
    Fermata.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {FermataAttributes['type']}. */
    Fermata.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {FermataAttributes['type']}. */
    Fermata.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {'' | 'normal' | 'angled' | 'square' | 'double-angled' | 'double-square' | 'double-dot' | 'half-curve' | 'curlew'}. */
    Fermata.prototype.getFermataShape = function () {
        return this.contents[0];
    };
    /** Sets @type {'' | 'normal' | 'angled' | 'square' | 'double-angled' | 'double-square' | 'double-dot' | 'half-curve' | 'curlew'}. */
    Fermata.prototype.setFermataShape = function (fermataShape) {
        this.contents[0] = fermataShape;
        return this;
    };
    Fermata.schema = {
        name: 'fermata',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            type: { type: 'optional', value: { type: 'choices', choices: ['upright', 'inverted'] } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'fermata-shape',
                    value: {
                        type: 'choices',
                        choices: [
                            '',
                            'normal',
                            'angled',
                            'square',
                            'double-angled',
                            'double-square',
                            'double-dot',
                            'half-curve',
                            'curlew',
                        ],
                    },
                },
            },
        ],
    };
    return Fermata;
}());
exports.Fermata = Fermata;
/**
 * The `<arpeggiate>` element
 *
 * Parent element: `<notations>`
 *
 * The `<arpeggiate>` element indicates that this note is part of an arpeggiated chord. The length of the sign can be
 * determined from the position attributes for the `<arpeggiate>` elements used with the top and bottom notes of the
 * arpeggiated chord.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/arpeggiate/}
 */
var Arpeggiate = /** @class */ (function () {
    function Arpeggiate(opts) {
        var _a;
        this.schema = Arpeggiate.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Arpeggiate.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Arpeggiate.schema.contents);
    }
    /** Gets @type {ArpeggiateAttributes['color']}. */
    Arpeggiate.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {ArpeggiateAttributes['color']}. */
    Arpeggiate.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {ArpeggiateAttributes['default-x']}. */
    Arpeggiate.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {ArpeggiateAttributes['default-x']}. */
    Arpeggiate.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {ArpeggiateAttributes['default-y']}. */
    Arpeggiate.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {ArpeggiateAttributes['default-y']}. */
    Arpeggiate.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {ArpeggiateAttributes['direction']}. */
    Arpeggiate.prototype.getDirection = function () {
        return this.attributes['direction'];
    };
    /** Sets @type {ArpeggiateAttributes['direction']}. */
    Arpeggiate.prototype.setDirection = function (direction) {
        this.attributes['direction'] = direction;
        return this;
    };
    /** Gets @type {ArpeggiateAttributes['id']}. */
    Arpeggiate.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {ArpeggiateAttributes['id']}. */
    Arpeggiate.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {ArpeggiateAttributes['number']}. */
    Arpeggiate.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {ArpeggiateAttributes['number']}. */
    Arpeggiate.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {ArpeggiateAttributes['placement']}. */
    Arpeggiate.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {ArpeggiateAttributes['placement']}. */
    Arpeggiate.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {ArpeggiateAttributes['relative-x']}. */
    Arpeggiate.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {ArpeggiateAttributes['relative-x']}. */
    Arpeggiate.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {ArpeggiateAttributes['relative-y']}. */
    Arpeggiate.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {ArpeggiateAttributes['relative-y']}. */
    Arpeggiate.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {ArpeggiateAttributes['unbroken']}. */
    Arpeggiate.prototype.getUnbroken = function () {
        return this.attributes['unbroken'];
    };
    /** Sets @type {ArpeggiateAttributes['unbroken']}. */
    Arpeggiate.prototype.setUnbroken = function (unbroken) {
        this.attributes['unbroken'] = unbroken;
        return this;
    };
    Arpeggiate.schema = {
        name: 'arpeggiate',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            direction: { type: 'optional', value: { type: 'choices', choices: ['up', 'down'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            unbroken: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
        },
        contents: [],
    };
    return Arpeggiate;
}());
exports.Arpeggiate = Arpeggiate;
/**
 * The `<non-arpeggiate>` element
 *
 * Parent element: `<notations>`
 *
 * The `<non-arpeggiate>` element indicates that this `<note>` is at the top or bottom of a bracket indicating to not
 * arpeggiate these notes. Since this does not involve playback, it is only used on the top or bottom notes, not on each
 * `<note>` as for the `<arpeggiate>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/non-arpeggiate/}
 */
var NonArpeggiate = /** @class */ (function () {
    function NonArpeggiate(opts) {
        var _a;
        this.schema = NonArpeggiate.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NonArpeggiate.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NonArpeggiate.schema.contents);
    }
    /** Gets @type {NonArpeggiateAttributes['type']}. */
    NonArpeggiate.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {NonArpeggiateAttributes['type']}. */
    NonArpeggiate.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {NonArpeggiateAttributes['color']}. */
    NonArpeggiate.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {NonArpeggiateAttributes['color']}. */
    NonArpeggiate.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {NonArpeggiateAttributes['default-x']}. */
    NonArpeggiate.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {NonArpeggiateAttributes['default-x']}. */
    NonArpeggiate.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {NonArpeggiateAttributes['default-y']}. */
    NonArpeggiate.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {NonArpeggiateAttributes['default-y']}. */
    NonArpeggiate.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {NonArpeggiateAttributes['id']}. */
    NonArpeggiate.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {NonArpeggiateAttributes['id']}. */
    NonArpeggiate.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {NonArpeggiateAttributes['number']}. */
    NonArpeggiate.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {NonArpeggiateAttributes['number']}. */
    NonArpeggiate.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {NonArpeggiateAttributes['placement']}. */
    NonArpeggiate.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {NonArpeggiateAttributes['placement']}. */
    NonArpeggiate.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {NonArpeggiateAttributes['relative-x']}. */
    NonArpeggiate.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {NonArpeggiateAttributes['relative-x']}. */
    NonArpeggiate.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {NonArpeggiateAttributes['relative-y']}. */
    NonArpeggiate.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {NonArpeggiateAttributes['relative-y']}. */
    NonArpeggiate.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    NonArpeggiate.schema = {
        name: 'non-arpeggiate',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['top', 'bottom'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [],
    };
    return NonArpeggiate;
}());
exports.NonArpeggiate = NonArpeggiate;
/**
 * The `<other-notation>` element
 *
 * Parent element: `<notations>`
 *
 * The `<other-notation>` element is used to define any notations not yet in the MusicXML format. It handles notations
 * where more specific extension elements such as `<other-dynamics>` and `<other-technical>` are not appropriate.
 *
 * The smufl attribute can be used to specify a particular notation, allowing application interoperability without
 * requiring every Standard Music Font Layout (SMuFL) glyph to have a MusicXML element equivalent. Using the
 * `<other-notation>` element without the smufl attribute allows for extended representation, though without application
 * interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-notation/}
 */
var OtherNotation = /** @class */ (function () {
    function OtherNotation(opts) {
        var _a;
        this.schema = OtherNotation.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherNotation.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherNotation.schema.contents);
    }
    /** Gets @type {OtherNotationAttributes['type']}. */
    OtherNotation.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {OtherNotationAttributes['type']}. */
    OtherNotation.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {OtherNotationAttributes['color']}. */
    OtherNotation.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {OtherNotationAttributes['color']}. */
    OtherNotation.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {OtherNotationAttributes['default-x']}. */
    OtherNotation.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {OtherNotationAttributes['default-x']}. */
    OtherNotation.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {OtherNotationAttributes['default-y']}. */
    OtherNotation.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {OtherNotationAttributes['default-y']}. */
    OtherNotation.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {OtherNotationAttributes['id']}. */
    OtherNotation.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {OtherNotationAttributes['id']}. */
    OtherNotation.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {OtherNotationAttributes['number']}. */
    OtherNotation.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {OtherNotationAttributes['number']}. */
    OtherNotation.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {OtherNotationAttributes['placement']}. */
    OtherNotation.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {OtherNotationAttributes['placement']}. */
    OtherNotation.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {OtherNotationAttributes['relative-x']}. */
    OtherNotation.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {OtherNotationAttributes['relative-x']}. */
    OtherNotation.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {OtherNotationAttributes['relative-y']}. */
    OtherNotation.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {OtherNotationAttributes['relative-y']}. */
    OtherNotation.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {OtherNotationAttributes['smufl']}. */
    OtherNotation.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {OtherNotationAttributes['smufl']}. */
    OtherNotation.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {string}. */
    OtherNotation.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    OtherNotation.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    OtherNotation.schema = {
        name: 'other-notation',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'single'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: { type: 'optional', value: { type: 'string' } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return OtherNotation;
}());
exports.OtherNotation = OtherNotation;
/**
 * The `<notations>` element
 *
 * Parent element: `<note>`
 *
 * The `<notations>` element collects musical notations that apply to a specific note or chord. Multiple `<notations>`
 * elements are allowed in order to represent multiple editorial levels. The print-object attribute allows `<notations>`
 * to represent details of performance technique, such as fingerings, without having them appear in the score. This
 * element is not related to the concept of XML notations.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/notations/}
 */
var Notations = /** @class */ (function () {
    function Notations(opts) {
        var _a;
        this.schema = Notations.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Notations.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Notations.schema.contents);
    }
    /** Gets @type {NotationsAttributes['id']}. */
    Notations.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {NotationsAttributes['id']}. */
    Notations.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {NotationsAttributes['print-object']}. */
    Notations.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {NotationsAttributes['print-object']}. */
    Notations.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    Notations.prototype.getFootnote = function () {
        return this.contents[0];
    };
    /** Sets @type {Footnote | null}. */
    Notations.prototype.setFootnote = function (footnote) {
        this.contents[0] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    Notations.prototype.getLevel = function () {
        return this.contents[1];
    };
    /** Sets @type {Level | null}. */
    Notations.prototype.setLevel = function (level) {
        this.contents[1] = level;
        return this;
    };
    /** Gets @type {Array<Tied | Slur | Tuplet | Glissando | Slide | Ornaments | Technical | Articulations | Dynamics | Fermata | Arpeggiate | NonArpeggiate | AccidentalMark | OtherNotation>}. */
    Notations.prototype.getValues = function () {
        return this.contents[2];
    };
    /** Sets @type {Array<Tied | Slur | Tuplet | Glissando | Slide | Ornaments | Technical | Articulations | Dynamics | Fermata | Arpeggiate | NonArpeggiate | AccidentalMark | OtherNotation>}. */
    Notations.prototype.setValues = function (values) {
        this.contents[2] = values;
        return this;
    };
    Notations.schema = {
        name: 'notations',
        attributes: {
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
        },
        contents: [
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
            {
                type: 'label',
                label: 'values',
                value: {
                    type: 'zeroOrMore',
                    value: {
                        type: 'choices',
                        choices: [
                            Tied,
                            Slur,
                            Tuplet,
                            Glissando,
                            Slide,
                            Ornaments,
                            Technical,
                            Articulations,
                            Dynamics,
                            Fermata,
                            Arpeggiate,
                            NonArpeggiate,
                            AccidentalMark,
                            OtherNotation,
                        ],
                    },
                },
            },
        ],
    };
    return Notations;
}());
exports.Notations = Notations;
/**
 * The `<syllabic>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<syllabic>` element indicates lyric hyphenation. The single, begin, end, and middle values represent
 * single-syllable words, word-beginning syllables, word-ending syllables, and mid-word syllables, respectively.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/syllabic/}
 */
var Syllabic = /** @class */ (function () {
    function Syllabic(opts) {
        var _a;
        this.schema = Syllabic.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Syllabic.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Syllabic.schema.contents);
    }
    /** Gets @type {'begin' | 'end' | 'middle' | 'single'}. */
    Syllabic.prototype.getSyllabic = function () {
        return this.contents[0];
    };
    /** Sets @type {'begin' | 'end' | 'middle' | 'single'}. */
    Syllabic.prototype.setSyllabic = function (syllabic) {
        this.contents[0] = syllabic;
        return this;
    };
    Syllabic.schema = {
        name: 'syllabic',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'syllabic',
                    value: { type: 'choices', choices: ['begin', 'end', 'middle', 'single'] },
                },
            },
        ],
    };
    return Syllabic;
}());
exports.Syllabic = Syllabic;
/**
 * The `<text>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<text>` element represents a syllable or portion of a syllable for lyric text underlay. A hyphen in the element
 * content should only be used for an actual hyphenated word.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/text/}
 */
var Text = /** @class */ (function () {
    function Text(opts) {
        var _a;
        this.schema = Text.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Text.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Text.schema.contents);
    }
    /** Gets @type {TextAttributes['color']}. */
    Text.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TextAttributes['color']}. */
    Text.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TextAttributes['dir']}. */
    Text.prototype.getDir = function () {
        return this.attributes['dir'];
    };
    /** Sets @type {TextAttributes['dir']}. */
    Text.prototype.setDir = function (dir) {
        this.attributes['dir'] = dir;
        return this;
    };
    /** Gets @type {TextAttributes['default-x']}. */
    Text.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {TextAttributes['default-x']}. */
    Text.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {TextAttributes['default-y']}. */
    Text.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {TextAttributes['default-y']}. */
    Text.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {TextAttributes['font-family']}. */
    Text.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TextAttributes['font-family']}. */
    Text.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TextAttributes['font-size']}. */
    Text.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TextAttributes['font-size']}. */
    Text.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TextAttributes['font-style']}. */
    Text.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TextAttributes['font-style']}. */
    Text.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TextAttributes['font-weight']}. */
    Text.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TextAttributes['font-weight']}. */
    Text.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {TextAttributes['letter-spacing']}. */
    Text.prototype.getLetterSpacing = function () {
        return this.attributes['letter-spacing'];
    };
    /** Sets @type {TextAttributes['letter-spacing']}. */
    Text.prototype.setLetterSpacing = function (letterSpacing) {
        this.attributes['letter-spacing'] = letterSpacing;
        return this;
    };
    /** Gets @type {TextAttributes['line-through']}. */
    Text.prototype.getLineThrough = function () {
        return this.attributes['line-through'];
    };
    /** Sets @type {TextAttributes['line-through']}. */
    Text.prototype.setLineThrough = function (lineThrough) {
        this.attributes['line-through'] = lineThrough;
        return this;
    };
    /** Gets @type {TextAttributes['overline']}. */
    Text.prototype.getOverline = function () {
        return this.attributes['overline'];
    };
    /** Sets @type {TextAttributes['overline']}. */
    Text.prototype.setOverline = function (overline) {
        this.attributes['overline'] = overline;
        return this;
    };
    /** Gets @type {TextAttributes['rotation']}. */
    Text.prototype.getRotation = function () {
        return this.attributes['rotation'];
    };
    /** Sets @type {TextAttributes['rotation']}. */
    Text.prototype.setRotation = function (rotation) {
        this.attributes['rotation'] = rotation;
        return this;
    };
    /** Gets @type {TextAttributes['underline']}. */
    Text.prototype.getUnderline = function () {
        return this.attributes['underline'];
    };
    /** Sets @type {TextAttributes['underline']}. */
    Text.prototype.setUnderline = function (underline) {
        this.attributes['underline'] = underline;
        return this;
    };
    /** Gets @type {TextAttributes['xml:lang']}. */
    Text.prototype.getXmlLang = function () {
        return this.attributes['xml:lang'];
    };
    /** Sets @type {TextAttributes['xml:lang']}. */
    Text.prototype.setXmlLang = function (xmlLang) {
        this.attributes['xml:lang'] = xmlLang;
        return this;
    };
    /** Gets @type {string}. */
    Text.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Text.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Text.schema = {
        name: 'text',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'letter-spacing': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            'xml:lang': { type: 'optional', value: { type: 'string' } },
        },
        contents: [{ type: 'string' }],
    };
    return Text;
}());
exports.Text = Text;
/**
 * The `<elision>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<elision>` element represents an elision between lyric syllables. The text content specifies the symbol used to
 * display the elision. Common values are a no-break space (Unicode 00A0), an underscore (Unicode 005F), or an undertie
 * (Unicode 203F). If the text content is empty, the smufl attribute is used to specify the symbol to use. If neither
 * text content nor a smufl attribute are present, the elision glyph is application-specific.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/elision/}
 */
var Elision = /** @class */ (function () {
    function Elision(opts) {
        var _a;
        this.schema = Elision.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Elision.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Elision.schema.contents);
    }
    /** Gets @type {ElisionAttributes['color']}. */
    Elision.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {ElisionAttributes['color']}. */
    Elision.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {ElisionAttributes['font-family']}. */
    Elision.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {ElisionAttributes['font-family']}. */
    Elision.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {ElisionAttributes['font-size']}. */
    Elision.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {ElisionAttributes['font-size']}. */
    Elision.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {ElisionAttributes['font-style']}. */
    Elision.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {ElisionAttributes['font-style']}. */
    Elision.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {ElisionAttributes['font-weight']}. */
    Elision.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {ElisionAttributes['font-weight']}. */
    Elision.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {ElisionAttributes['smufl']}. */
    Elision.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {ElisionAttributes['smufl']}. */
    Elision.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    Elision.schema = {
        name: 'elision',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            smufl: { type: 'optional', value: { type: 'regex', pattern: /lyrics/, zero: 'lyrics' } },
        },
        contents: [],
    };
    return Elision;
}());
exports.Elision = Elision;
/**
 * The `<extend>` element
 *
 * Parent elements: `<figure>`, `<lyric>`
 *
 * The `<extend>` element represents lyric word extension / melisma lines as well as figured bass extensions.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/extend/}
 */
var Extend = /** @class */ (function () {
    function Extend(opts) {
        var _a;
        this.schema = Extend.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Extend.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Extend.schema.contents);
    }
    /** Gets @type {ExtendAttributes['color']}. */
    Extend.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {ExtendAttributes['color']}. */
    Extend.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {ExtendAttributes['default-x']}. */
    Extend.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {ExtendAttributes['default-x']}. */
    Extend.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {ExtendAttributes['default-y']}. */
    Extend.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {ExtendAttributes['default-y']}. */
    Extend.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {ExtendAttributes['relative-x']}. */
    Extend.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {ExtendAttributes['relative-x']}. */
    Extend.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {ExtendAttributes['relative-y']}. */
    Extend.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {ExtendAttributes['relative-y']}. */
    Extend.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {ExtendAttributes['type']}. */
    Extend.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {ExtendAttributes['type']}. */
    Extend.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    Extend.schema = {
        name: 'extend',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
        },
        contents: [],
    };
    return Extend;
}());
exports.Extend = Extend;
/**
 * The `<laughing>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<laughing>` element represents a laughing voice.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/laughing/}
 */
var Laughing = /** @class */ (function () {
    function Laughing(opts) {
        var _a;
        this.schema = Laughing.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Laughing.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Laughing.schema.contents);
    }
    Laughing.schema = { name: 'laughing', attributes: {}, contents: [] };
    return Laughing;
}());
exports.Laughing = Laughing;
/**
 * The `<humming>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<humming>` element represents a humming voice.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/humming/}
 */
var Humming = /** @class */ (function () {
    function Humming(opts) {
        var _a;
        this.schema = Humming.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Humming.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Humming.schema.contents);
    }
    Humming.schema = { name: 'humming', attributes: {}, contents: [] };
    return Humming;
}());
exports.Humming = Humming;
/**
 * The `<end-line>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<end-line>` element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric display for
 * Karaoke and similar applications.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/end-line/}
 */
var EndLine = /** @class */ (function () {
    function EndLine(opts) {
        var _a;
        this.schema = EndLine.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, EndLine.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(EndLine.schema.contents);
    }
    EndLine.schema = { name: 'end-line', attributes: {}, contents: [] };
    return EndLine;
}());
exports.EndLine = EndLine;
/**
 * The `<end-paragraph>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<end-paragraph>` element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric
 * display for Karaoke and similar applications.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/end-paragraph/}
 */
var EndParagraph = /** @class */ (function () {
    function EndParagraph(opts) {
        var _a;
        this.schema = EndParagraph.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, EndParagraph.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(EndParagraph.schema.contents);
    }
    EndParagraph.schema = { name: 'end-paragraph', attributes: {}, contents: [] };
    return EndParagraph;
}());
exports.EndParagraph = EndParagraph;
/**
 * The `<lyric>` element
 *
 * Parent element: `<note>`
 *
 * The `<lyric>` element represents text underlays for lyrics. Two `<text>` elements that are not separated by an
 * `<elision>` element are part of the same syllable, but may have different text formatting. A second `<syllabic>`
 * element is not allowed unless preceded by an `<elision>` element.
 *
 * If not otherwise specified:
 *
 * - The justify value is center.
 * - The placement value is below.
 * - The valign value is baseline.
 * - The halign value matches the justify value.
 *
 * The print-object attribute can override a `<note>`'s print-lyric attribute in cases where only some lyrics on a note
 * are printed, as when lyrics for later verses are printed in a block of text rather than with each note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/lyric/}
 */
var Lyric = /** @class */ (function () {
    function Lyric(opts) {
        var _a;
        this.schema = Lyric.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Lyric.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Lyric.schema.contents);
    }
    /** Gets @type {LyricAttributes['color']}. */
    Lyric.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {LyricAttributes['color']}. */
    Lyric.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {LyricAttributes['default-x']}. */
    Lyric.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {LyricAttributes['default-x']}. */
    Lyric.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {LyricAttributes['default-y']}. */
    Lyric.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {LyricAttributes['default-y']}. */
    Lyric.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {LyricAttributes['id']}. */
    Lyric.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {LyricAttributes['id']}. */
    Lyric.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {LyricAttributes['justify']}. */
    Lyric.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {LyricAttributes['justify']}. */
    Lyric.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {LyricAttributes['name']}. */
    Lyric.prototype.getName = function () {
        return this.attributes['name'];
    };
    /** Sets @type {LyricAttributes['name']}. */
    Lyric.prototype.setName = function (name) {
        this.attributes['name'] = name;
        return this;
    };
    /** Gets @type {LyricAttributes['number']}. */
    Lyric.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {LyricAttributes['number']}. */
    Lyric.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {LyricAttributes['placement']}. */
    Lyric.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {LyricAttributes['placement']}. */
    Lyric.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {LyricAttributes['print-object']}. */
    Lyric.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {LyricAttributes['print-object']}. */
    Lyric.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {LyricAttributes['relative-x']}. */
    Lyric.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {LyricAttributes['relative-x']}. */
    Lyric.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {LyricAttributes['relative-y']}. */
    Lyric.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {LyricAttributes['relative-y']}. */
    Lyric.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {LyricAttributes['time-only']}. */
    Lyric.prototype.getTimeOnly = function () {
        return this.attributes['time-only'];
    };
    /** Sets @type {LyricAttributes['time-only']}. */
    Lyric.prototype.setTimeOnly = function (timeOnly) {
        this.attributes['time-only'] = timeOnly;
        return this;
    };
    /** Gets @type {Intelligible | Extend | Laughing | Humming}. */
    Lyric.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {Intelligible | Extend | Laughing | Humming}. */
    Lyric.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    /** Gets @type {EndLine | null}. */
    Lyric.prototype.getEndLine = function () {
        return this.contents[1];
    };
    /** Sets @type {EndLine | null}. */
    Lyric.prototype.setEndLine = function (endLine) {
        this.contents[1] = endLine;
        return this;
    };
    /** Gets @type {EndParagraph | null}. */
    Lyric.prototype.getEndParagraph = function () {
        return this.contents[2];
    };
    /** Sets @type {EndParagraph | null}. */
    Lyric.prototype.setEndParagraph = function (endParagraph) {
        this.contents[2] = endParagraph;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    Lyric.prototype.getFootnote = function () {
        return this.contents[3];
    };
    /** Sets @type {Footnote | null}. */
    Lyric.prototype.setFootnote = function (footnote) {
        this.contents[3] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    Lyric.prototype.getLevel = function () {
        return this.contents[4];
    };
    /** Sets @type {Level | null}. */
    Lyric.prototype.setLevel = function (level) {
        this.contents[4] = level;
        return this;
    };
    Lyric.schema = {
        name: 'lyric',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            name: { type: 'optional', value: { type: 'string' } },
            number: { type: 'optional', value: { type: 'string' } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
        },
        contents: [
            {
                type: 'label',
                label: 'value',
                value: {
                    type: 'choices',
                    choices: [
                        {
                            type: 'label',
                            label: 'intelligible',
                            value: [
                                { type: 'optional', value: Syllabic },
                                { type: 'required', value: Text },
                                {
                                    type: 'zeroOrMore',
                                    value: [
                                        {
                                            type: 'optional',
                                            value: [
                                                { type: 'required', value: Elision },
                                                { type: 'optional', value: Syllabic },
                                            ],
                                        },
                                        { type: 'required', value: Text },
                                    ],
                                },
                                { type: 'optional', value: Extend },
                            ],
                        },
                        Extend,
                        Laughing,
                        Humming,
                    ],
                },
            },
            { type: 'optional', value: EndLine },
            { type: 'optional', value: EndParagraph },
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
        ],
    };
    return Lyric;
}());
exports.Lyric = Lyric;
/**
 * The `<ipa>` element
 *
 * Parent element: `<play>`
 *
 * The `<ipa>` element represents International Phonetic Alphabet (IPA) sounds for vocal music. String content is
 * limited to IPA 2015 symbols represented in Unicode 13.0.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ipa/}
 */
var Ipa = /** @class */ (function () {
    function Ipa(opts) {
        var _a;
        this.schema = Ipa.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Ipa.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Ipa.schema.contents);
    }
    /** Gets @type {string}. */
    Ipa.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Ipa.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Ipa.schema = {
        name: 'ipa',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Ipa;
}());
exports.Ipa = Ipa;
/**
 * The `<mute>` element
 *
 * Parent element: `<play>`
 *
 * The `<mute>` element represents muting playback for different instruments, including brass, winds, and strings.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/mute/}
 */
var Mute = /** @class */ (function () {
    function Mute(opts) {
        var _a;
        this.schema = Mute.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Mute.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Mute.schema.contents);
    }
    /** Gets @type {'on' | 'off' | 'bucket' | 'cup' | 'echo' | 'harmon-no-stem' | 'harmon-stem' | 'hat' | 'palm' | 'plunger' | 'practice' | 'solotone' | 'stop-hand' | 'stop-mute' | 'straight'}. */
    Mute.prototype.getMute = function () {
        return this.contents[0];
    };
    /** Sets @type {'on' | 'off' | 'bucket' | 'cup' | 'echo' | 'harmon-no-stem' | 'harmon-stem' | 'hat' | 'palm' | 'plunger' | 'practice' | 'solotone' | 'stop-hand' | 'stop-mute' | 'straight'}. */
    Mute.prototype.setMute = function (mute) {
        this.contents[0] = mute;
        return this;
    };
    Mute.schema = {
        name: 'mute',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'mute',
                    value: {
                        type: 'choices',
                        choices: [
                            'on',
                            'off',
                            'bucket',
                            'cup',
                            'echo',
                            'harmon-no-stem',
                            'harmon-stem',
                            'hat',
                            'palm',
                            'plunger',
                            'practice',
                            'solotone',
                            'stop-hand',
                            'stop-mute',
                            'straight',
                        ],
                    },
                },
            },
        ],
    };
    return Mute;
}());
exports.Mute = Mute;
/**
 * The `<semi-pitched>` element
 *
 * Parent element: `<play>`
 *
 * The `<semi-pitched>` element represents categories of indefinite pitch for percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/semi-pitched/}
 */
var SemiPitched = /** @class */ (function () {
    function SemiPitched(opts) {
        var _a;
        this.schema = SemiPitched.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SemiPitched.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SemiPitched.schema.contents);
    }
    /** Gets @type {'high' | 'low' | 'medium' | 'medium-high' | 'medium-low' | 'very-low'}. */
    SemiPitched.prototype.getSemiPitched = function () {
        return this.contents[0];
    };
    /** Sets @type {'high' | 'low' | 'medium' | 'medium-high' | 'medium-low' | 'very-low'}. */
    SemiPitched.prototype.setSemiPitched = function (semiPitched) {
        this.contents[0] = semiPitched;
        return this;
    };
    SemiPitched.schema = {
        name: 'semi-pitched',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'semi-pitched',
                    value: { type: 'choices', choices: ['high', 'low', 'medium', 'medium-high', 'medium-low', 'very-low'] },
                },
            },
        ],
    };
    return SemiPitched;
}());
exports.SemiPitched = SemiPitched;
/**
 * The `<other-play>` element
 *
 * Parent element: `<play>`
 *
 * The `<other-play>` element represents other types of playback not otherwise specified within the `<play>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-play/}
 */
var OtherPlay = /** @class */ (function () {
    function OtherPlay(opts) {
        var _a;
        this.schema = OtherPlay.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherPlay.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherPlay.schema.contents);
    }
    /** Gets @type {OtherPlayAttributes['type']}. */
    OtherPlay.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {OtherPlayAttributes['type']}. */
    OtherPlay.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    OtherPlay.schema = {
        name: 'other-play',
        attributes: { type: { type: 'required', value: { type: 'string' } } },
        contents: [],
    };
    return OtherPlay;
}());
exports.OtherPlay = OtherPlay;
/**
 * The `<play>` element
 *
 * Parent elements: `<note>`, `<sound>`
 *
 * The `<play>` element specifies playback techniques to be used in conjunction with the `<instrument-sound>` element.
 * When used as part of a `<sound>` element, it applies to all notes going forward in score order. In multi-instrument
 * parts, the affected instrument should be specified using the id attribute. When used as part of a `<note>` element,
 * it applies to the current note only.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/play/}
 */
var Play = /** @class */ (function () {
    function Play(opts) {
        var _a;
        this.schema = Play.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Play.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Play.schema.contents);
    }
    /** Gets @type {PlayAttributes['id']}. */
    Play.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {PlayAttributes['id']}. */
    Play.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {Array<Ipa | Mute | SemiPitched | OtherPlay>}. */
    Play.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Ipa | Mute | SemiPitched | OtherPlay>}. */
    Play.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Play.schema = {
        name: 'play',
        attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Ipa, Mute, SemiPitched, OtherPlay] } },
            },
        ],
    };
    return Play;
}());
exports.Play = Play;
/**
 * The `<assess>`` element
 *
 * Parent element: `<listen>`
 *
 * By default, an assessment application should assess all notes without a `<cue>` child element, and not assess any
 * note with a `<cue>` child element. The `<assess>` element allows this default assessment to be overridden for
 * individual notes.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/assess/}
 */
var Assess = /** @class */ (function () {
    function Assess(opts) {
        var _a;
        this.schema = Assess.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Assess.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Assess.schema.contents);
    }
    /** Gets @type {AssessAttributes['type']}. */
    Assess.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {AssessAttributes['type']}. */
    Assess.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {AssessAttributes['player']}. */
    Assess.prototype.getPlayer = function () {
        return this.attributes['player'];
    };
    /** Sets @type {AssessAttributes['player']}. */
    Assess.prototype.setPlayer = function (player) {
        this.attributes['player'] = player;
        return this;
    };
    /** Gets @type {AssessAttributes['time-only']}. */
    Assess.prototype.getTimeOnly = function () {
        return this.attributes['time-only'];
    };
    /** Sets @type {AssessAttributes['time-only']}. */
    Assess.prototype.setTimeOnly = function (timeOnly) {
        this.attributes['time-only'] = timeOnly;
        return this;
    };
    Assess.schema = {
        name: 'assess',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['yes', 'no'] } },
            player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
        },
        contents: [],
    };
    return Assess;
}());
exports.Assess = Assess;
/**
 * The `<wait>` element
 *
 * Parent element: `<listen>`
 *
 * The `<wait>` element specifies a point where the accompaniment should wait for a performer event before continuing.
 * This typically happens at the start of new sections or after a held note or indeterminate music. These waiting points
 * cannot always be inferred reliably from the contents of the displayed score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/wait/}
 */
var Wait = /** @class */ (function () {
    function Wait(opts) {
        var _a;
        this.schema = Wait.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Wait.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Wait.schema.contents);
    }
    /** Gets @type {WaitAttributes['player']}. */
    Wait.prototype.getPlayer = function () {
        return this.attributes['player'];
    };
    /** Sets @type {WaitAttributes['player']}. */
    Wait.prototype.setPlayer = function (player) {
        this.attributes['player'] = player;
        return this;
    };
    /** Gets @type {WaitAttributes['time-only']}. */
    Wait.prototype.getTimeOnly = function () {
        return this.attributes['time-only'];
    };
    /** Sets @type {WaitAttributes['time-only']}. */
    Wait.prototype.setTimeOnly = function (timeOnly) {
        this.attributes['time-only'] = timeOnly;
        return this;
    };
    Wait.schema = {
        name: 'wait',
        attributes: {
            player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
        },
        contents: [],
    };
    return Wait;
}());
exports.Wait = Wait;
/**
 * The `<other-listen>` element
 *
 * Parent element: `<listen>`
 *
 * The `<other-listen>` element represents other types of listening control and interaction that are specific to a note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-listen/}
 */
var OtherListen = /** @class */ (function () {
    function OtherListen(opts) {
        var _a;
        this.schema = OtherListen.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherListen.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherListen.schema.contents);
    }
    /** Gets @type {OtherListenAttributes['type']}. */
    OtherListen.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {OtherListenAttributes['type']}. */
    OtherListen.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {OtherListenAttributes['player']}. */
    OtherListen.prototype.getPlayer = function () {
        return this.attributes['player'];
    };
    /** Sets @type {OtherListenAttributes['player']}. */
    OtherListen.prototype.setPlayer = function (player) {
        this.attributes['player'] = player;
        return this;
    };
    /** Gets @type {OtherListenAttributes['time-only']}. */
    OtherListen.prototype.getTimeOnly = function () {
        return this.attributes['time-only'];
    };
    /** Sets @type {OtherListenAttributes['time-only']}. */
    OtherListen.prototype.setTimeOnly = function (timeOnly) {
        this.attributes['time-only'] = timeOnly;
        return this;
    };
    /** Gets @type {string}. */
    OtherListen.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    OtherListen.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    OtherListen.schema = {
        name: 'other-listen',
        attributes: {
            type: { type: 'required', value: { type: 'string' } },
            player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return OtherListen;
}());
exports.OtherListen = OtherListen;
/**
 * The `<listen>` element
 *
 * Parent element: `<note>`
 *
 * The `<listen>` and `<listening>` elements, new in Version 4.0, specify different ways that a score following or
 * machine listening application can interact with a performer. The `<listen>` element handles interactions that are
 * specific to a note. If multiple child elements of the same type are present, they should have distinct player and/or
 * time-only attributes.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/listen/}
 */
var Listen = /** @class */ (function () {
    function Listen(opts) {
        var _a;
        this.schema = Listen.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Listen.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Listen.schema.contents);
    }
    /** Gets @type {Array<Assess | Wait | OtherListen>}. */
    Listen.prototype.getListens = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Assess | Wait | OtherListen>}. */
    Listen.prototype.setListens = function (listens) {
        this.contents[0] = listens;
        return this;
    };
    Listen.schema = {
        name: 'listen',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'listens',
                value: { type: 'oneOrMore', value: { type: 'choices', choices: [Assess, Wait, OtherListen] } },
            },
        ],
    };
    return Listen;
}());
exports.Listen = Listen;
/**
 * The `<note>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * Notes are the most common type of MusicXML data. The MusicXML format distinguishes between elements used for sound
 * information and elements used for notation information (e.g., `<tie>` is used for sound, `<tied>` for notation). Thus
 * grace notes do not have a `<duration>` element. Cue notes have a `<duration>` element, as do `<forward>` elements,
 * but no `<tie>` elements. Having these two types of information available can make interchange easier, as some
 * programs handle one type of information more readily than the other.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/note/}
 */
var Note = /** @class */ (function () {
    function Note(opts) {
        var _a;
        this.schema = Note.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Note.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Note.schema.contents);
    }
    /** Gets @type {NoteAttributes['attack']}. */
    Note.prototype.getAttack = function () {
        return this.attributes['attack'];
    };
    /** Sets @type {NoteAttributes['attack']}. */
    Note.prototype.setAttack = function (attack) {
        this.attributes['attack'] = attack;
        return this;
    };
    /** Gets @type {NoteAttributes['color']}. */
    Note.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {NoteAttributes['color']}. */
    Note.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {NoteAttributes['default-x']}. */
    Note.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {NoteAttributes['default-x']}. */
    Note.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {NoteAttributes['default-y']}. */
    Note.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {NoteAttributes['default-y']}. */
    Note.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {NoteAttributes['dynamics']}. */
    Note.prototype.getDynamics = function () {
        return this.attributes['dynamics'];
    };
    /** Sets @type {NoteAttributes['dynamics']}. */
    Note.prototype.setDynamics = function (dynamics) {
        this.attributes['dynamics'] = dynamics;
        return this;
    };
    /** Gets @type {NoteAttributes['end-dynamics']}. */
    Note.prototype.getEndDynamics = function () {
        return this.attributes['end-dynamics'];
    };
    /** Sets @type {NoteAttributes['end-dynamics']}. */
    Note.prototype.setEndDynamics = function (endDynamics) {
        this.attributes['end-dynamics'] = endDynamics;
        return this;
    };
    /** Gets @type {NoteAttributes['font-family']}. */
    Note.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {NoteAttributes['font-family']}. */
    Note.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {NoteAttributes['font-size']}. */
    Note.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {NoteAttributes['font-size']}. */
    Note.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {NoteAttributes['font-style']}. */
    Note.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {NoteAttributes['font-style']}. */
    Note.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {NoteAttributes['font-weight']}. */
    Note.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {NoteAttributes['font-weight']}. */
    Note.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {NoteAttributes['id']}. */
    Note.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {NoteAttributes['id']}. */
    Note.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {NoteAttributes['pizzicato']}. */
    Note.prototype.getPizzicato = function () {
        return this.attributes['pizzicato'];
    };
    /** Sets @type {NoteAttributes['pizzicato']}. */
    Note.prototype.setPizzicato = function (pizzicato) {
        this.attributes['pizzicato'] = pizzicato;
        return this;
    };
    /** Gets @type {NoteAttributes['print-dot']}. */
    Note.prototype.getPrintDot = function () {
        return this.attributes['print-dot'];
    };
    /** Sets @type {NoteAttributes['print-dot']}. */
    Note.prototype.setPrintDot = function (printDot) {
        this.attributes['print-dot'] = printDot;
        return this;
    };
    /** Gets @type {NoteAttributes['print-leger']}. */
    Note.prototype.getPrintLeger = function () {
        return this.attributes['print-leger'];
    };
    /** Sets @type {NoteAttributes['print-leger']}. */
    Note.prototype.setPrintLeger = function (printLeger) {
        this.attributes['print-leger'] = printLeger;
        return this;
    };
    /** Gets @type {NoteAttributes['print-lyric']}. */
    Note.prototype.getPrintLyric = function () {
        return this.attributes['print-lyric'];
    };
    /** Sets @type {NoteAttributes['print-lyric']}. */
    Note.prototype.setPrintLyric = function (printLyric) {
        this.attributes['print-lyric'] = printLyric;
        return this;
    };
    /** Gets @type {NoteAttributes['print-object']}. */
    Note.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {NoteAttributes['print-object']}. */
    Note.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {NoteAttributes['print-spacing']}. */
    Note.prototype.getPrintSpacing = function () {
        return this.attributes['print-spacing'];
    };
    /** Sets @type {NoteAttributes['print-spacing']}. */
    Note.prototype.setPrintSpacing = function (printSpacing) {
        this.attributes['print-spacing'] = printSpacing;
        return this;
    };
    /** Gets @type {NoteAttributes['relative-x']}. */
    Note.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {NoteAttributes['relative-x']}. */
    Note.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {NoteAttributes['relative-y']}. */
    Note.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {NoteAttributes['relative-y']}. */
    Note.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {NoteAttributes['release']}. */
    Note.prototype.getRelease = function () {
        return this.attributes['release'];
    };
    /** Sets @type {NoteAttributes['release']}. */
    Note.prototype.setRelease = function (release) {
        this.attributes['release'] = release;
        return this;
    };
    /** Gets @type {NoteAttributes['time-only']}. */
    Note.prototype.getTimeOnly = function () {
        return this.attributes['time-only'];
    };
    /** Sets @type {NoteAttributes['time-only']}. */
    Note.prototype.setTimeOnly = function (timeOnly) {
        this.attributes['time-only'] = timeOnly;
        return this;
    };
    /** Gets @type {TiedNote | CuedNote | TiedGraceNote | CuedGraceNote}. */
    Note.prototype.getVariation = function () {
        return this.contents[0];
    };
    /** Sets @type {TiedNote | CuedNote | TiedGraceNote | CuedGraceNote}. */
    Note.prototype.setVariation = function (variation) {
        this.contents[0] = variation;
        return this;
    };
    /** Gets @type {Array<Instrument>}. */
    Note.prototype.getInstruments = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<Instrument>}. */
    Note.prototype.setInstruments = function (instruments) {
        this.contents[1] = instruments;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    Note.prototype.getFootnote = function () {
        return this.contents[2];
    };
    /** Sets @type {Footnote | null}. */
    Note.prototype.setFootnote = function (footnote) {
        this.contents[2] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    Note.prototype.getLevel = function () {
        return this.contents[3];
    };
    /** Sets @type {Level | null}. */
    Note.prototype.setLevel = function (level) {
        this.contents[3] = level;
        return this;
    };
    /** Gets @type {Voice | null}. */
    Note.prototype.getVoice = function () {
        return this.contents[4];
    };
    /** Sets @type {Voice | null}. */
    Note.prototype.setVoice = function (voice) {
        this.contents[4] = voice;
        return this;
    };
    /** Gets @type {Type | null}. */
    Note.prototype.getType = function () {
        return this.contents[5];
    };
    /** Sets @type {Type | null}. */
    Note.prototype.setType = function (type) {
        this.contents[5] = type;
        return this;
    };
    /** Gets @type {Array<Dot>}. */
    Note.prototype.getDots = function () {
        return this.contents[6];
    };
    /** Sets @type {Array<Dot>}. */
    Note.prototype.setDots = function (dots) {
        this.contents[6] = dots;
        return this;
    };
    /** Gets @type {Accidental | null}. */
    Note.prototype.getAccidental = function () {
        return this.contents[7];
    };
    /** Sets @type {Accidental | null}. */
    Note.prototype.setAccidental = function (accidental) {
        this.contents[7] = accidental;
        return this;
    };
    /** Gets @type {TimeModification | null}. */
    Note.prototype.getTimeModification = function () {
        return this.contents[8];
    };
    /** Sets @type {TimeModification | null}. */
    Note.prototype.setTimeModification = function (timeModification) {
        this.contents[8] = timeModification;
        return this;
    };
    /** Gets @type {Stem | null}. */
    Note.prototype.getStem = function () {
        return this.contents[9];
    };
    /** Sets @type {Stem | null}. */
    Note.prototype.setStem = function (stem) {
        this.contents[9] = stem;
        return this;
    };
    /** Gets @type {Notehead | null}. */
    Note.prototype.getNotehead = function () {
        return this.contents[10];
    };
    /** Sets @type {Notehead | null}. */
    Note.prototype.setNotehead = function (notehead) {
        this.contents[10] = notehead;
        return this;
    };
    /** Gets @type {NoteheadText | null}. */
    Note.prototype.getNoteheadText = function () {
        return this.contents[11];
    };
    /** Sets @type {NoteheadText | null}. */
    Note.prototype.setNoteheadText = function (noteheadText) {
        this.contents[11] = noteheadText;
        return this;
    };
    /** Gets @type {Staff | null}. */
    Note.prototype.getStaff = function () {
        return this.contents[12];
    };
    /** Sets @type {Staff | null}. */
    Note.prototype.setStaff = function (staff) {
        this.contents[12] = staff;
        return this;
    };
    /** Gets @type {[] | [Beam] | [Beam, Beam] | [Beam, Beam, Beam] | [Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam]}. */
    Note.prototype.getBeams = function () {
        return this.contents[13];
    };
    /** Sets @type {[] | [Beam] | [Beam, Beam] | [Beam, Beam, Beam] | [Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam]}. */
    Note.prototype.setBeams = function (beams) {
        this.contents[13] = beams;
        return this;
    };
    /** Gets @type {Array<Notations>}. */
    Note.prototype.getNotations = function () {
        return this.contents[14];
    };
    /** Sets @type {Array<Notations>}. */
    Note.prototype.setNotations = function (notations) {
        this.contents[14] = notations;
        return this;
    };
    /** Gets @type {Array<Lyric>}. */
    Note.prototype.getLyrics = function () {
        return this.contents[15];
    };
    /** Sets @type {Array<Lyric>}. */
    Note.prototype.setLyrics = function (lyrics) {
        this.contents[15] = lyrics;
        return this;
    };
    /** Gets @type {Play | null}. */
    Note.prototype.getPlay = function () {
        return this.contents[16];
    };
    /** Sets @type {Play | null}. */
    Note.prototype.setPlay = function (play) {
        this.contents[16] = play;
        return this;
    };
    /** Gets @type {Listen | null}. */
    Note.prototype.getListen = function () {
        return this.contents[17];
    };
    /** Sets @type {Listen | null}. */
    Note.prototype.setListen = function (listen) {
        this.contents[17] = listen;
        return this;
    };
    Note.schema = {
        name: 'note',
        attributes: {
            attack: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            dynamics: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
            'end-dynamics': { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            pizzicato: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-dot': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-leger': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-lyric': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-spacing': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            release: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
        },
        contents: [
            {
                type: 'label',
                label: 'variation',
                value: {
                    type: 'choices',
                    choices: [
                        {
                            type: 'label',
                            label: 'tied-note',
                            value: [
                                { type: 'optional', value: Chord },
                                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                                { type: 'required', value: Duration },
                                { type: 'choices', choices: [[], [Tie], [Tie, Tie]] },
                            ],
                        },
                        {
                            type: 'label',
                            label: 'cued-note',
                            value: [
                                { type: 'required', value: Cue },
                                { type: 'optional', value: Chord },
                                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                                { type: 'required', value: Duration },
                            ],
                        },
                        {
                            type: 'label',
                            label: 'tied-grace-note',
                            value: [
                                { type: 'required', value: Grace },
                                { type: 'optional', value: Chord },
                                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                                { type: 'choices', choices: [[], [Tie], [Tie, Tie]] },
                            ],
                        },
                        {
                            type: 'label',
                            label: 'cued-grace-note',
                            value: [
                                { type: 'required', value: Grace },
                                { type: 'required', value: Cue },
                                { type: 'optional', value: Chord },
                                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                                { type: 'required', value: Duration },
                            ],
                        },
                    ],
                },
            },
            { type: 'label', label: 'instruments', value: { type: 'zeroOrMore', value: Instrument } },
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
            { type: 'optional', value: Voice },
            { type: 'optional', value: Type },
            { type: 'label', label: 'dots', value: { type: 'zeroOrMore', value: Dot } },
            { type: 'optional', value: Accidental },
            { type: 'optional', value: TimeModification },
            { type: 'optional', value: Stem },
            { type: 'optional', value: Notehead },
            { type: 'optional', value: NoteheadText },
            { type: 'optional', value: Staff },
            {
                type: 'label',
                label: 'beams',
                value: {
                    type: 'choices',
                    choices: [
                        [],
                        [Beam],
                        [Beam, Beam],
                        [Beam, Beam, Beam],
                        [Beam, Beam, Beam, Beam],
                        [Beam, Beam, Beam, Beam, Beam],
                        [Beam, Beam, Beam, Beam, Beam, Beam],
                        [Beam, Beam, Beam, Beam, Beam, Beam, Beam],
                        [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam],
                    ],
                },
            },
            { type: 'label', label: 'notations', value: { type: 'zeroOrMore', value: Notations } },
            { type: 'label', label: 'lyrics', value: { type: 'zeroOrMore', value: Lyric } },
            { type: 'optional', value: Play },
            { type: 'optional', value: Listen },
        ],
    };
    return Note;
}());
exports.Note = Note;
/**
 * The `<backup> element
 *
 * Parent elements: `<measure> (partwise), `<part> (timewise)
 *
 * The `<backup> and `<forward> elements are required to coordinate multiple voices in one part, including music on
 * multiple staves. The `<backup> element is generally used to move between voices and staves. Thus it does not include
 * `<voice> or `<staff> elements. Duration values should always be positive, and should not cross measure boundaries or
 * mid-measure changes in the `<divisions> value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/backup/}
 */
var Backup = /** @class */ (function () {
    function Backup(opts) {
        var _a;
        this.schema = Backup.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Backup.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Backup.schema.contents);
    }
    /** Gets @type {Duration}. */
    Backup.prototype.getDuration = function () {
        return this.contents[0];
    };
    /** Sets @type {Duration}. */
    Backup.prototype.setDuration = function (duration) {
        this.contents[0] = duration;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    Backup.prototype.getFootnote = function () {
        return this.contents[1];
    };
    /** Sets @type {Footnote | null}. */
    Backup.prototype.setFootnote = function (footnote) {
        this.contents[1] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    Backup.prototype.getLevel = function () {
        return this.contents[2];
    };
    /** Sets @type {Level | null}. */
    Backup.prototype.setLevel = function (level) {
        this.contents[2] = level;
        return this;
    };
    Backup.schema = {
        name: 'backup',
        attributes: {},
        contents: [
            { type: 'required', value: Duration },
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
        ],
    };
    return Backup;
}());
exports.Backup = Backup;
/**
 * The `<forward>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<backup>` and `<forward>` elements are required to coordinate multiple voices in one part, including music on
 * multiple staves. The `<forward>` element is generally used within voices and staves. Duration values should always be
 * positive, and should not cross measure boundaries or mid-measure changes in the `<divisions>` value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/forward/}
 */
var Forward = /** @class */ (function () {
    function Forward(opts) {
        var _a;
        this.schema = Forward.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Forward.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Forward.schema.contents);
    }
    /** Gets @type {Duration}. */
    Forward.prototype.getDuration = function () {
        return this.contents[0];
    };
    /** Sets @type {Duration}. */
    Forward.prototype.setDuration = function (duration) {
        this.contents[0] = duration;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    Forward.prototype.getFootnote = function () {
        return this.contents[1];
    };
    /** Sets @type {Footnote | null}. */
    Forward.prototype.setFootnote = function (footnote) {
        this.contents[1] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    Forward.prototype.getLevel = function () {
        return this.contents[2];
    };
    /** Sets @type {Level | null}. */
    Forward.prototype.setLevel = function (level) {
        this.contents[2] = level;
        return this;
    };
    /** Gets @type {Voice | null}. */
    Forward.prototype.getVoice = function () {
        return this.contents[3];
    };
    /** Sets @type {Voice | null}. */
    Forward.prototype.setVoice = function (voice) {
        this.contents[3] = voice;
        return this;
    };
    /** Gets @type {Staff | null}. */
    Forward.prototype.getStaff = function () {
        return this.contents[4];
    };
    /** Sets @type {Staff | null}. */
    Forward.prototype.setStaff = function (staff) {
        this.contents[4] = staff;
        return this;
    };
    Forward.schema = {
        name: 'forward',
        attributes: {},
        contents: [
            { type: 'required', value: Duration },
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
            { type: 'optional', value: Voice },
            { type: 'optional', value: Staff },
        ],
    };
    return Forward;
}());
exports.Forward = Forward;
/**
 * The `<rehearsal>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<rehearsal>` element specifies letters, numbers, and section names that are notated in the score for reference
 * during rehearsal. The enclosure is square if not specified. Left justification is used if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/rehearsal/}
 */
var Rehearsal = /** @class */ (function () {
    function Rehearsal(opts) {
        var _a;
        this.schema = Rehearsal.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Rehearsal.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Rehearsal.schema.contents);
    }
    /** Gets @type {RehearsalAttributes['color']}. */
    Rehearsal.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {RehearsalAttributes['color']}. */
    Rehearsal.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {RehearsalAttributes['default-x']}. */
    Rehearsal.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {RehearsalAttributes['default-x']}. */
    Rehearsal.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {RehearsalAttributes['default-y']}. */
    Rehearsal.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {RehearsalAttributes['default-y']}. */
    Rehearsal.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {RehearsalAttributes['dir']}. */
    Rehearsal.prototype.getDir = function () {
        return this.attributes['dir'];
    };
    /** Sets @type {RehearsalAttributes['dir']}. */
    Rehearsal.prototype.setDir = function (dir) {
        this.attributes['dir'] = dir;
        return this;
    };
    /** Gets @type {RehearsalAttributes['enclosure']}. */
    Rehearsal.prototype.getEnclosure = function () {
        return this.attributes['enclosure'];
    };
    /** Sets @type {RehearsalAttributes['enclosure']}. */
    Rehearsal.prototype.setEnclosure = function (enclosure) {
        this.attributes['enclosure'] = enclosure;
        return this;
    };
    /** Gets @type {RehearsalAttributes['font-family']}. */
    Rehearsal.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {RehearsalAttributes['font-family']}. */
    Rehearsal.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {RehearsalAttributes['font-size']}. */
    Rehearsal.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {RehearsalAttributes['font-size']}. */
    Rehearsal.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {RehearsalAttributes['font-style']}. */
    Rehearsal.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {RehearsalAttributes['font-style']}. */
    Rehearsal.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {RehearsalAttributes['font-weight']}. */
    Rehearsal.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {RehearsalAttributes['font-weight']}. */
    Rehearsal.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {RehearsalAttributes['halign']}. */
    Rehearsal.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {RehearsalAttributes['halign']}. */
    Rehearsal.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {RehearsalAttributes['id']}. */
    Rehearsal.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {RehearsalAttributes['id']}. */
    Rehearsal.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {RehearsalAttributes['letter-spacing']}. */
    Rehearsal.prototype.getLetterSpacing = function () {
        return this.attributes['letter-spacing'];
    };
    /** Sets @type {RehearsalAttributes['letter-spacing']}. */
    Rehearsal.prototype.setLetterSpacing = function (letterSpacing) {
        this.attributes['letter-spacing'] = letterSpacing;
        return this;
    };
    /** Gets @type {RehearsalAttributes['line-height']}. */
    Rehearsal.prototype.getLineHeight = function () {
        return this.attributes['line-height'];
    };
    /** Sets @type {RehearsalAttributes['line-height']}. */
    Rehearsal.prototype.setLineHeight = function (lineHeight) {
        this.attributes['line-height'] = lineHeight;
        return this;
    };
    /** Gets @type {RehearsalAttributes['line-through']}. */
    Rehearsal.prototype.getLineThrough = function () {
        return this.attributes['line-through'];
    };
    /** Sets @type {RehearsalAttributes['line-through']}. */
    Rehearsal.prototype.setLineThrough = function (lineThrough) {
        this.attributes['line-through'] = lineThrough;
        return this;
    };
    /** Gets @type {RehearsalAttributes['overline']}. */
    Rehearsal.prototype.getOverline = function () {
        return this.attributes['overline'];
    };
    /** Sets @type {RehearsalAttributes['overline']}. */
    Rehearsal.prototype.setOverline = function (overline) {
        this.attributes['overline'] = overline;
        return this;
    };
    /** Gets @type {RehearsalAttributes['relative-x']}. */
    Rehearsal.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {RehearsalAttributes['relative-x']}. */
    Rehearsal.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {RehearsalAttributes['relative-y']}. */
    Rehearsal.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {RehearsalAttributes['relative-y']}. */
    Rehearsal.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {RehearsalAttributes['rotation']}. */
    Rehearsal.prototype.getRotation = function () {
        return this.attributes['rotation'];
    };
    /** Sets @type {RehearsalAttributes['rotation']}. */
    Rehearsal.prototype.setRotation = function (rotation) {
        this.attributes['rotation'] = rotation;
        return this;
    };
    /** Gets @type {RehearsalAttributes['underline']}. */
    Rehearsal.prototype.getUnderline = function () {
        return this.attributes['underline'];
    };
    /** Sets @type {RehearsalAttributes['underline']}. */
    Rehearsal.prototype.setUnderline = function (underline) {
        this.attributes['underline'] = underline;
        return this;
    };
    /** Gets @type {RehearsalAttributes['valign']}. */
    Rehearsal.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {RehearsalAttributes['valign']}. */
    Rehearsal.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {RehearsalAttributes['xml:lang']}. */
    Rehearsal.prototype.getXmlLang = function () {
        return this.attributes['xml:lang'];
    };
    /** Sets @type {RehearsalAttributes['xml:lang']}. */
    Rehearsal.prototype.setXmlLang = function (xmlLang) {
        this.attributes['xml:lang'] = xmlLang;
        return this;
    };
    /** Gets @type {RehearsalAttributes['xml:space']}. */
    Rehearsal.prototype.getXmlSpace = function () {
        return this.attributes['xml:space'];
    };
    /** Sets @type {RehearsalAttributes['xml:space']}. */
    Rehearsal.prototype.setXmlSpace = function (xmlSpace) {
        this.attributes['xml:space'] = xmlSpace;
        return this;
    };
    /** Gets @type {string}. */
    Rehearsal.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Rehearsal.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Rehearsal.schema = {
        name: 'rehearsal',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
            enclosure: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        'none',
                        'rectangle',
                        'square',
                        'oval',
                        'circle',
                        'bracket',
                        'inverted-bracket',
                        'triangle',
                        'diamond',
                        'pentagon',
                        'hexagon',
                        'heptagon',
                        'octagon',
                        'nonagon',
                        'decagon',
                    ],
                },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'letter-spacing': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-height': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
            'xml:lang': { type: 'optional', value: { type: 'string' } },
            'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Rehearsal;
}());
exports.Rehearsal = Rehearsal;
/**
 * The `<segno>` element
 *
 * Parent elements: `<barline>`, `<direction-type>`
 *
 * The `<segno>` element is the visual indicator of a segno sign. A `<sound>` element is also needed to guide playback
 * applications reliably.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/segno/}
 */
var Segno = /** @class */ (function () {
    function Segno(opts) {
        var _a;
        this.schema = Segno.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Segno.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Segno.schema.contents);
    }
    /** Gets @type {SegnoAttributes['color']}. */
    Segno.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {SegnoAttributes['color']}. */
    Segno.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {SegnoAttributes['default-x']}. */
    Segno.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {SegnoAttributes['default-x']}. */
    Segno.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {SegnoAttributes['default-y']}. */
    Segno.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {SegnoAttributes['default-y']}. */
    Segno.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {SegnoAttributes['font-family']}. */
    Segno.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {SegnoAttributes['font-family']}. */
    Segno.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {SegnoAttributes['font-size']}. */
    Segno.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {SegnoAttributes['font-size']}. */
    Segno.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {SegnoAttributes['font-style']}. */
    Segno.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {SegnoAttributes['font-style']}. */
    Segno.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {SegnoAttributes['font-weight']}. */
    Segno.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {SegnoAttributes['font-weight']}. */
    Segno.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {SegnoAttributes['halign']}. */
    Segno.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {SegnoAttributes['halign']}. */
    Segno.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {SegnoAttributes['id']}. */
    Segno.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {SegnoAttributes['id']}. */
    Segno.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {SegnoAttributes['relative-x']}. */
    Segno.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {SegnoAttributes['relative-x']}. */
    Segno.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {SegnoAttributes['relative-y']}. */
    Segno.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {SegnoAttributes['relative-y']}. */
    Segno.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {SegnoAttributes['smufl']}. */
    Segno.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {SegnoAttributes['smufl']}. */
    Segno.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {SegnoAttributes['valign']}. */
    Segno.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {SegnoAttributes['valign']}. */
    Segno.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    Segno.schema = {
        name: 'segno',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: {
                type: 'optional',
                value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [],
    };
    return Segno;
}());
exports.Segno = Segno;
/**
 * The `<coda>` element
 *
 * Parent elements: `<barline>`, `<direction-type>`
 *
 * The `<coda>` element is the visual indicator of a coda sign. A <sound>` element is also needed to guide playback
 * applications reliably.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/coda/}
 */
var Coda = /** @class */ (function () {
    function Coda(opts) {
        var _a;
        this.schema = Coda.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Coda.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Coda.schema.contents);
    }
    /** Gets @type {CodaAttributes['color']}. */
    Coda.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {CodaAttributes['color']}. */
    Coda.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {CodaAttributes['default-x']}. */
    Coda.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {CodaAttributes['default-x']}. */
    Coda.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {CodaAttributes['default-y']}. */
    Coda.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {CodaAttributes['default-y']}. */
    Coda.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {CodaAttributes['font-family']}. */
    Coda.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {CodaAttributes['font-family']}. */
    Coda.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {CodaAttributes['font-size']}. */
    Coda.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {CodaAttributes['font-size']}. */
    Coda.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {CodaAttributes['font-style']}. */
    Coda.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {CodaAttributes['font-style']}. */
    Coda.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {CodaAttributes['font-weight']}. */
    Coda.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {CodaAttributes['font-weight']}. */
    Coda.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {CodaAttributes['halign']}. */
    Coda.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {CodaAttributes['halign']}. */
    Coda.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {CodaAttributes['id']}. */
    Coda.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {CodaAttributes['id']}. */
    Coda.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {CodaAttributes['relative-x']}. */
    Coda.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {CodaAttributes['relative-x']}. */
    Coda.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {CodaAttributes['relative-y']}. */
    Coda.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {CodaAttributes['relative-y']}. */
    Coda.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {CodaAttributes['smufl']}. */
    Coda.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {CodaAttributes['smufl']}. */
    Coda.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {CodaAttributes['valign']}. */
    Coda.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {CodaAttributes['valign']}. */
    Coda.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    Coda.schema = {
        name: 'coda',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: {
                type: 'optional',
                value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [],
    };
    return Coda;
}());
exports.Coda = Coda;
/**
 * The `<words>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<words>` element specifies a standard text direction. The enclosure attribute is none if not specified. Left
 * justification is used if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/words/}
 */
var Words = /** @class */ (function () {
    function Words(opts) {
        var _a;
        this.schema = Words.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Words.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Words.schema.contents);
    }
    /** Gets @type {WordsAttributes['color']}. */
    Words.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {WordsAttributes['color']}. */
    Words.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {WordsAttributes['default-x']}. */
    Words.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {WordsAttributes['default-x']}. */
    Words.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {WordsAttributes['default-y']}. */
    Words.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {WordsAttributes['default-y']}. */
    Words.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {WordsAttributes['dir']}. */
    Words.prototype.getDir = function () {
        return this.attributes['dir'];
    };
    /** Sets @type {WordsAttributes['dir']}. */
    Words.prototype.setDir = function (dir) {
        this.attributes['dir'] = dir;
        return this;
    };
    /** Gets @type {WordsAttributes['enclosure']}. */
    Words.prototype.getEnclosure = function () {
        return this.attributes['enclosure'];
    };
    /** Sets @type {WordsAttributes['enclosure']}. */
    Words.prototype.setEnclosure = function (enclosure) {
        this.attributes['enclosure'] = enclosure;
        return this;
    };
    /** Gets @type {WordsAttributes['font-family']}. */
    Words.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {WordsAttributes['font-family']}. */
    Words.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {WordsAttributes['font-size']}. */
    Words.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {WordsAttributes['font-size']}. */
    Words.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {WordsAttributes['font-style']}. */
    Words.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {WordsAttributes['font-style']}. */
    Words.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {WordsAttributes['font-weight']}. */
    Words.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {WordsAttributes['font-weight']}. */
    Words.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {WordsAttributes['halign']}. */
    Words.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {WordsAttributes['halign']}. */
    Words.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {WordsAttributes['id']}. */
    Words.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {WordsAttributes['id']}. */
    Words.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {WordsAttributes['justify']}. */
    Words.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {WordsAttributes['justify']}. */
    Words.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {WordsAttributes['letter-spacing']}. */
    Words.prototype.getLetterSpacing = function () {
        return this.attributes['letter-spacing'];
    };
    /** Sets @type {WordsAttributes['letter-spacing']}. */
    Words.prototype.setLetterSpacing = function (letterSpacing) {
        this.attributes['letter-spacing'] = letterSpacing;
        return this;
    };
    /** Gets @type {WordsAttributes['line-height']}. */
    Words.prototype.getLineHeight = function () {
        return this.attributes['line-height'];
    };
    /** Sets @type {WordsAttributes['line-height']}. */
    Words.prototype.setLineHeight = function (lineHeight) {
        this.attributes['line-height'] = lineHeight;
        return this;
    };
    /** Gets @type {WordsAttributes['line-through']}. */
    Words.prototype.getLineThrough = function () {
        return this.attributes['line-through'];
    };
    /** Sets @type {WordsAttributes['line-through']}. */
    Words.prototype.setLineThrough = function (lineThrough) {
        this.attributes['line-through'] = lineThrough;
        return this;
    };
    /** Gets @type {WordsAttributes['overline']}. */
    Words.prototype.getOverline = function () {
        return this.attributes['overline'];
    };
    /** Sets @type {WordsAttributes['overline']}. */
    Words.prototype.setOverline = function (overline) {
        this.attributes['overline'] = overline;
        return this;
    };
    /** Gets @type {WordsAttributes['relative-x']}. */
    Words.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {WordsAttributes['relative-x']}. */
    Words.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {WordsAttributes['relative-y']}. */
    Words.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {WordsAttributes['relative-y']}. */
    Words.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {WordsAttributes['rotation']}. */
    Words.prototype.getRotation = function () {
        return this.attributes['rotation'];
    };
    /** Sets @type {WordsAttributes['rotation']}. */
    Words.prototype.setRotation = function (rotation) {
        this.attributes['rotation'] = rotation;
        return this;
    };
    /** Gets @type {WordsAttributes['underline']}. */
    Words.prototype.getUnderline = function () {
        return this.attributes['underline'];
    };
    /** Sets @type {WordsAttributes['underline']}. */
    Words.prototype.setUnderline = function (underline) {
        this.attributes['underline'] = underline;
        return this;
    };
    /** Gets @type {WordsAttributes['valign']}. */
    Words.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {WordsAttributes['valign']}. */
    Words.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {WordsAttributes['xml:lang']}. */
    Words.prototype.getXmlLang = function () {
        return this.attributes['xml:lang'];
    };
    /** Sets @type {WordsAttributes['xml:lang']}. */
    Words.prototype.setXmlLang = function (xmlLang) {
        this.attributes['xml:lang'] = xmlLang;
        return this;
    };
    /** Gets @type {WordsAttributes['xml:space']}. */
    Words.prototype.getXmlSpace = function () {
        return this.attributes['xml:space'];
    };
    /** Sets @type {WordsAttributes['xml:space']}. */
    Words.prototype.setXmlSpace = function (xmlSpace) {
        this.attributes['xml:space'] = xmlSpace;
        return this;
    };
    /** Gets @type {string}. */
    Words.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Words.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Words.schema = {
        name: 'words',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
            enclosure: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        'none',
                        'rectangle',
                        'square',
                        'oval',
                        'circle',
                        'bracket',
                        'inverted-bracket',
                        'triangle',
                        'diamond',
                        'pentagon',
                        'hexagon',
                        'heptagon',
                        'octagon',
                        'nonagon',
                        'decagon',
                    ],
                },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'letter-spacing': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-height': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
            'xml:lang': { type: 'optional', value: { type: 'string' } },
            'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Words;
}());
exports.Words = Words;
/**
 * The `<symbol>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<symbol>` element specifies a musical symbol using a canonical SMuFL glyph name. It is used when an occasional
 * musical symbol is interspersed into text. It should not be used in place of semantic markup, such as metronome marks
 * that mix text and symbols. Left justification is used if not specified. Enclosure is none if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/direction-type/}
 */
var Symbol = /** @class */ (function () {
    function Symbol(opts) {
        var _a;
        this.schema = Symbol.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Symbol.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Symbol.schema.contents);
    }
    /** Gets @type {SymbolAttributes['color']}. */
    Symbol.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {SymbolAttributes['color']}. */
    Symbol.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {SymbolAttributes['default-x']}. */
    Symbol.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {SymbolAttributes['default-x']}. */
    Symbol.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {SymbolAttributes['default-y']}. */
    Symbol.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {SymbolAttributes['default-y']}. */
    Symbol.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {SymbolAttributes['dir']}. */
    Symbol.prototype.getDir = function () {
        return this.attributes['dir'];
    };
    /** Sets @type {SymbolAttributes['dir']}. */
    Symbol.prototype.setDir = function (dir) {
        this.attributes['dir'] = dir;
        return this;
    };
    /** Gets @type {SymbolAttributes['enclosure']}. */
    Symbol.prototype.getEnclosure = function () {
        return this.attributes['enclosure'];
    };
    /** Sets @type {SymbolAttributes['enclosure']}. */
    Symbol.prototype.setEnclosure = function (enclosure) {
        this.attributes['enclosure'] = enclosure;
        return this;
    };
    /** Gets @type {SymbolAttributes['font-family']}. */
    Symbol.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {SymbolAttributes['font-family']}. */
    Symbol.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {SymbolAttributes['font-size']}. */
    Symbol.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {SymbolAttributes['font-size']}. */
    Symbol.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {SymbolAttributes['font-style']}. */
    Symbol.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {SymbolAttributes['font-style']}. */
    Symbol.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {SymbolAttributes['font-weight']}. */
    Symbol.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {SymbolAttributes['font-weight']}. */
    Symbol.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {SymbolAttributes['halign']}. */
    Symbol.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {SymbolAttributes['halign']}. */
    Symbol.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {SymbolAttributes['id']}. */
    Symbol.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {SymbolAttributes['id']}. */
    Symbol.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {SymbolAttributes['justify']}. */
    Symbol.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {SymbolAttributes['justify']}. */
    Symbol.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {SymbolAttributes['letter-spacing']}. */
    Symbol.prototype.getLetterSpacing = function () {
        return this.attributes['letter-spacing'];
    };
    /** Sets @type {SymbolAttributes['letter-spacing']}. */
    Symbol.prototype.setLetterSpacing = function (letterSpacing) {
        this.attributes['letter-spacing'] = letterSpacing;
        return this;
    };
    /** Gets @type {SymbolAttributes['line-height']}. */
    Symbol.prototype.getLineHeight = function () {
        return this.attributes['line-height'];
    };
    /** Sets @type {SymbolAttributes['line-height']}. */
    Symbol.prototype.setLineHeight = function (lineHeight) {
        this.attributes['line-height'] = lineHeight;
        return this;
    };
    /** Gets @type {SymbolAttributes['line-through']}. */
    Symbol.prototype.getLineThrough = function () {
        return this.attributes['line-through'];
    };
    /** Sets @type {SymbolAttributes['line-through']}. */
    Symbol.prototype.setLineThrough = function (lineThrough) {
        this.attributes['line-through'] = lineThrough;
        return this;
    };
    /** Gets @type {SymbolAttributes['overline']}. */
    Symbol.prototype.getOverline = function () {
        return this.attributes['overline'];
    };
    /** Sets @type {SymbolAttributes['overline']}. */
    Symbol.prototype.setOverline = function (overline) {
        this.attributes['overline'] = overline;
        return this;
    };
    /** Gets @type {SymbolAttributes['relative-x']}. */
    Symbol.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {SymbolAttributes['relative-x']}. */
    Symbol.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {SymbolAttributes['relative-y']}. */
    Symbol.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {SymbolAttributes['relative-y']}. */
    Symbol.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {SymbolAttributes['rotation']}. */
    Symbol.prototype.getRotation = function () {
        return this.attributes['rotation'];
    };
    /** Sets @type {SymbolAttributes['rotation']}. */
    Symbol.prototype.setRotation = function (rotation) {
        this.attributes['rotation'] = rotation;
        return this;
    };
    /** Gets @type {SymbolAttributes['underline']}. */
    Symbol.prototype.getUnderline = function () {
        return this.attributes['underline'];
    };
    /** Sets @type {SymbolAttributes['underline']}. */
    Symbol.prototype.setUnderline = function (underline) {
        this.attributes['underline'] = underline;
        return this;
    };
    /** Gets @type {SymbolAttributes['valign']}. */
    Symbol.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {SymbolAttributes['valign']}. */
    Symbol.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    Symbol.schema = {
        name: 'symbol',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
            enclosure: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        'none',
                        'rectangle',
                        'square',
                        'oval',
                        'circle',
                        'bracket',
                        'inverted-bracket',
                        'triangle',
                        'diamond',
                        'pentagon',
                        'hexagon',
                        'heptagon',
                        'octagon',
                        'nonagon',
                        'decagon',
                    ],
                },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'letter-spacing': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-height': {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
            },
            'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [],
    };
    return Symbol;
}());
exports.Symbol = Symbol;
/**
 * The `<wedge>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<wedge>` element represents crescendo and diminuendo wedge symbols. The line-type attribute is solid if not
 * specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/wedge/}
 */
var Wedge = /** @class */ (function () {
    function Wedge(opts) {
        var _a;
        this.schema = Wedge.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Wedge.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Wedge.schema.contents);
    }
    /** Gets @type {WedgeAttributes['type']}. */
    Wedge.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {WedgeAttributes['type']}. */
    Wedge.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {WedgeAttributes['color']}. */
    Wedge.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {WedgeAttributes['color']}. */
    Wedge.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {WedgeAttributes['dash-length']}. */
    Wedge.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {WedgeAttributes['dash-length']}. */
    Wedge.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {WedgeAttributes['default-x']}. */
    Wedge.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {WedgeAttributes['default-x']}. */
    Wedge.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {WedgeAttributes['default-y']}. */
    Wedge.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {WedgeAttributes['default-y']}. */
    Wedge.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {WedgeAttributes['id']}. */
    Wedge.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {WedgeAttributes['id']}. */
    Wedge.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {WedgeAttributes['line-type']}. */
    Wedge.prototype.getLineType = function () {
        return this.attributes['line-type'];
    };
    /** Sets @type {WedgeAttributes['line-type']}. */
    Wedge.prototype.setLineType = function (lineType) {
        this.attributes['line-type'] = lineType;
        return this;
    };
    /** Gets @type {WedgeAttributes['niente']}. */
    Wedge.prototype.getNiente = function () {
        return this.attributes['niente'];
    };
    /** Sets @type {WedgeAttributes['niente']}. */
    Wedge.prototype.setNiente = function (niente) {
        this.attributes['niente'] = niente;
        return this;
    };
    /** Gets @type {WedgeAttributes['number']}. */
    Wedge.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {WedgeAttributes['number']}. */
    Wedge.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {WedgeAttributes['relative-x']}. */
    Wedge.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {WedgeAttributes['relative-x']}. */
    Wedge.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {WedgeAttributes['relative-y']}. */
    Wedge.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {WedgeAttributes['relative-y']}. */
    Wedge.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {WedgeAttributes['space-length']}. */
    Wedge.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {WedgeAttributes['space-length']}. */
    Wedge.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    /** Gets @type {WedgeAttributes['spread']}. */
    Wedge.prototype.getSpread = function () {
        return this.attributes['spread'];
    };
    /** Sets @type {WedgeAttributes['spread']}. */
    Wedge.prototype.setSpread = function (spread) {
        this.attributes['spread'] = spread;
        return this;
    };
    Wedge.schema = {
        name: 'wedge',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['crescendo', 'diminuendo', 'stop', 'continue'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
            niente: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            spread: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return Wedge;
}());
exports.Wedge = Wedge;
/**
 * The `<dashes>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<dashes>` element represents dashes, used for instance with cresc. and dim. marks.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/dashes/}
 */
var Dashes = /** @class */ (function () {
    function Dashes(opts) {
        var _a;
        this.schema = Dashes.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Dashes.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Dashes.schema.contents);
    }
    /** Gets @type {DashesAttributes['type']}. */
    Dashes.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {DashesAttributes['type']}. */
    Dashes.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {DashesAttributes['color']}. */
    Dashes.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DashesAttributes['color']}. */
    Dashes.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DashesAttributes['dash-length']}. */
    Dashes.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {DashesAttributes['dash-length']}. */
    Dashes.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {DashesAttributes['default-x']}. */
    Dashes.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DashesAttributes['default-x']}. */
    Dashes.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DashesAttributes['default-y']}. */
    Dashes.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DashesAttributes['default-y']}. */
    Dashes.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DashesAttributes['id']}. */
    Dashes.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {DashesAttributes['id']}. */
    Dashes.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {DashesAttributes['number']}. */
    Dashes.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {DashesAttributes['number']}. */
    Dashes.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {DashesAttributes['relative-x']}. */
    Dashes.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DashesAttributes['relative-x']}. */
    Dashes.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DashesAttributes['relative-y']}. */
    Dashes.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DashesAttributes['relative-y']}. */
    Dashes.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DashesAttributes['space-length']}. */
    Dashes.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {DashesAttributes['space-length']}. */
    Dashes.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    Dashes.schema = {
        name: 'dashes',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return Dashes;
}());
exports.Dashes = Dashes;
/**
 * The `<bracket>` element
 *
 * Parent element: `<direction-type>`
 *
 * Brackets are combined with words in a variety of modern directions. The line-type is solid if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bracket/}
 */
var Bracket = /** @class */ (function () {
    function Bracket(opts) {
        var _a;
        this.schema = Bracket.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Bracket.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Bracket.schema.contents);
    }
    /** Gets @type {BracketAttributes['line-end']}. */
    Bracket.prototype.getLineEnd = function () {
        return this.attributes['line-end'];
    };
    /** Sets @type {BracketAttributes['line-end']}. */
    Bracket.prototype.setLineEnd = function (lineEnd) {
        this.attributes['line-end'] = lineEnd;
        return this;
    };
    /** Gets @type {BracketAttributes['type']}. */
    Bracket.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {BracketAttributes['type']}. */
    Bracket.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {BracketAttributes['color']}. */
    Bracket.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {BracketAttributes['color']}. */
    Bracket.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {BracketAttributes['dash-length']}. */
    Bracket.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {BracketAttributes['dash-length']}. */
    Bracket.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {BracketAttributes['default-x']}. */
    Bracket.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {BracketAttributes['default-x']}. */
    Bracket.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {BracketAttributes['default-y']}. */
    Bracket.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {BracketAttributes['default-y']}. */
    Bracket.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {BracketAttributes['end-length']}. */
    Bracket.prototype.getEndLength = function () {
        return this.attributes['end-length'];
    };
    /** Sets @type {BracketAttributes['end-length']}. */
    Bracket.prototype.setEndLength = function (endLength) {
        this.attributes['end-length'] = endLength;
        return this;
    };
    /** Gets @type {BracketAttributes['id']}. */
    Bracket.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {BracketAttributes['id']}. */
    Bracket.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {BracketAttributes['line-type']}. */
    Bracket.prototype.getLineType = function () {
        return this.attributes['line-type'];
    };
    /** Sets @type {BracketAttributes['line-type']}. */
    Bracket.prototype.setLineType = function (lineType) {
        this.attributes['line-type'] = lineType;
        return this;
    };
    /** Gets @type {BracketAttributes['number']}. */
    Bracket.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {BracketAttributes['number']}. */
    Bracket.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {BracketAttributes['relative-x']}. */
    Bracket.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {BracketAttributes['relative-x']}. */
    Bracket.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {BracketAttributes['relative-y']}. */
    Bracket.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {BracketAttributes['relative-y']}. */
    Bracket.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {BracketAttributes['space-length']}. */
    Bracket.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {BracketAttributes['space-length']}. */
    Bracket.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    Bracket.schema = {
        name: 'bracket',
        attributes: {
            'line-end': { type: 'required', value: { type: 'choices', choices: ['none', 'up', 'down', 'both', 'arrow'] } },
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'end-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return Bracket;
}());
exports.Bracket = Bracket;
/**
 * The `<pedal>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<pedal>` element represents piano pedal marks, including damper and sostenuto pedal marks. The soft pedal is not
 * included here because there is no special symbol or graphic used for it beyond what can be specified with `<words>`
 * and `<bracket>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pedal/}
 */
var Pedal = /** @class */ (function () {
    function Pedal(opts) {
        var _a;
        this.schema = Pedal.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Pedal.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Pedal.schema.contents);
    }
    /** Gets @type {PedalAttributes['type']}. */
    Pedal.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {PedalAttributes['type']}. */
    Pedal.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {PedalAttributes['abbreviated']}. */
    Pedal.prototype.getAbbreviated = function () {
        return this.attributes['abbreviated'];
    };
    /** Sets @type {PedalAttributes['abbreviated']}. */
    Pedal.prototype.setAbbreviated = function (abbreviated) {
        this.attributes['abbreviated'] = abbreviated;
        return this;
    };
    /** Gets @type {PedalAttributes['color']}. */
    Pedal.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {PedalAttributes['color']}. */
    Pedal.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {PedalAttributes['default-x']}. */
    Pedal.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {PedalAttributes['default-x']}. */
    Pedal.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {PedalAttributes['default-y']}. */
    Pedal.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {PedalAttributes['default-y']}. */
    Pedal.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {PedalAttributes['font-family']}. */
    Pedal.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PedalAttributes['font-family']}. */
    Pedal.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PedalAttributes['font-size']}. */
    Pedal.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PedalAttributes['font-size']}. */
    Pedal.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PedalAttributes['font-style']}. */
    Pedal.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PedalAttributes['font-style']}. */
    Pedal.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PedalAttributes['font-weight']}. */
    Pedal.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PedalAttributes['font-weight']}. */
    Pedal.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {PedalAttributes['id']}. */
    Pedal.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {PedalAttributes['id']}. */
    Pedal.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {PedalAttributes['line']}. */
    Pedal.prototype.getLine = function () {
        return this.attributes['line'];
    };
    /** Sets @type {PedalAttributes['line']}. */
    Pedal.prototype.setLine = function (line) {
        this.attributes['line'] = line;
        return this;
    };
    /** Gets @type {PedalAttributes['number']}. */
    Pedal.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {PedalAttributes['number']}. */
    Pedal.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {PedalAttributes['relative-x']}. */
    Pedal.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {PedalAttributes['relative-x']}. */
    Pedal.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {PedalAttributes['relative-y']}. */
    Pedal.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {PedalAttributes['relative-y']}. */
    Pedal.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {PedalAttributes['sign']}. */
    Pedal.prototype.getSign = function () {
        return this.attributes['sign'];
    };
    /** Sets @type {PedalAttributes['sign']}. */
    Pedal.prototype.setSign = function (sign) {
        this.attributes['sign'] = sign;
        return this;
    };
    Pedal.schema = {
        name: 'pedal',
        attributes: {
            type: {
                type: 'required',
                value: {
                    type: 'choices',
                    choices: ['start', 'stop', 'sostenuto', 'change', 'continue', 'discountiue', 'resume'],
                },
            },
            abbreviated: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            line: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            sign: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
        },
        contents: [],
    };
    return Pedal;
}());
exports.Pedal = Pedal;
/**
 * The `<beat-unit>` element
 *
 * Parent elements: `<beat-unit-tied>`, `<metronome>`
 *
 * The `<beat-unit>` element indicates the graphical note type to use in a metronome mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beat-unit/}
 */
var BeatUnit = /** @class */ (function () {
    function BeatUnit(opts) {
        var _a;
        this.schema = BeatUnit.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BeatUnit.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BeatUnit.schema.contents);
    }
    /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    BeatUnit.prototype.getNoteTypeValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    BeatUnit.prototype.setNoteTypeValue = function (noteTypeValue) {
        this.contents[0] = noteTypeValue;
        return this;
    };
    BeatUnit.schema = {
        name: 'beat-unit',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'note-type-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'whole',
                            '1024th',
                            '512th',
                            '256th',
                            '128th',
                            '64th',
                            '32nd',
                            '16th',
                            'eighth',
                            'half',
                            'quarter',
                            'whole',
                            'breve',
                            'long',
                            'maxima',
                        ],
                    },
                },
            },
        ],
    };
    return BeatUnit;
}());
exports.BeatUnit = BeatUnit;
/**
 * The `<beat-unit-dot>` element
 *
 * Parent elements: `<beat-unit-tied>`, `<metronome>`
 *
 * The `<beat-unit-dot>` element is used to specify any augmentation dots for a metronome mark note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beat-unit-dot/}
 */
var BeatUnitDot = /** @class */ (function () {
    function BeatUnitDot(opts) {
        var _a;
        this.schema = BeatUnitDot.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BeatUnitDot.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BeatUnitDot.schema.contents);
    }
    BeatUnitDot.schema = { name: 'beat-unit-dot', attributes: {}, contents: [] };
    return BeatUnitDot;
}());
exports.BeatUnitDot = BeatUnitDot;
/**
 * The `<beat-unit-tied>` element
 *
 * Parent element: `<metronome>`
 *
 * The `<beat-unit-tied>` element indicates a `<beat-unit>` within a metronome mark that is tied to the preceding
 * `<beat-unit>`. This allows two or more tied notes to be associated with a per-minute value in a metronome mark,
 * whereas the `<metronome-tied>` element is restricted to metric relationship marks.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beat-unit-tied/}
 */
var BeatUnitTied = /** @class */ (function () {
    function BeatUnitTied(opts) {
        var _a;
        this.schema = BeatUnitTied.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BeatUnitTied.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BeatUnitTied.schema.contents);
    }
    /** Gets @type {BeatUnit}. */
    BeatUnitTied.prototype.getBeatUnit = function () {
        return this.contents[0];
    };
    /** Sets @type {BeatUnit}. */
    BeatUnitTied.prototype.setBeatUnit = function (beatUnit) {
        this.contents[0] = beatUnit;
        return this;
    };
    /** Gets @type {Array<BeatUnitDot>}. */
    BeatUnitTied.prototype.getBeatUnitDots = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<BeatUnitDot>}. */
    BeatUnitTied.prototype.setBeatUnitDots = function (beatUnitDots) {
        this.contents[1] = beatUnitDots;
        return this;
    };
    BeatUnitTied.schema = {
        name: 'beat-unit-tied',
        attributes: {},
        contents: [
            { type: 'required', value: BeatUnit },
            { type: 'label', label: 'beat-unit-dots', value: { type: 'zeroOrMore', value: BeatUnitDot } },
        ],
    };
    return BeatUnitTied;
}());
exports.BeatUnitTied = BeatUnitTied;
/**
 * The `<per-minute>` element
 *
 * Parent element: `<metronome>`
 *
 * The `<per-minute>` element can be a number, or a text description including numbers. If a font is specified, it
 * overrides the font specified for the overall `<metronome>` element. This allows separate specification of a music
 * font for the `<beat-unit>` and a text font for the numeric value, in cases where a single metronome font is not used.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/per-minute/}
 */
var PerMinute = /** @class */ (function () {
    function PerMinute(opts) {
        var _a;
        this.schema = PerMinute.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PerMinute.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PerMinute.schema.contents);
    }
    /** Gets @type {PerMinuteAttributes['font-family']}. */
    PerMinute.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PerMinuteAttributes['font-family']}. */
    PerMinute.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PerMinuteAttributes['font-size']}. */
    PerMinute.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PerMinuteAttributes['font-size']}. */
    PerMinute.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PerMinuteAttributes['font-style']}. */
    PerMinute.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PerMinuteAttributes['font-style']}. */
    PerMinute.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PerMinuteAttributes['font-weight']}. */
    PerMinute.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PerMinuteAttributes['font-weight']}. */
    PerMinute.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {string}. */
    PerMinute.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    PerMinute.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    PerMinute.schema = {
        name: 'per-minute',
        attributes: {
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return PerMinute;
}());
exports.PerMinute = PerMinute;
/**
 * The `<metronome-arrows>` element
 *
 * Parent element: `<metronome>`
 *
 * If the `<metronome-arrows>` element is present, it indicates that metric modulation arrows are displayed on both
 * sides of the metronome mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-arrows/}
 */
var MetronomeArrows = /** @class */ (function () {
    function MetronomeArrows(opts) {
        var _a;
        this.schema = MetronomeArrows.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MetronomeArrows.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MetronomeArrows.schema.contents);
    }
    MetronomeArrows.schema = { name: 'metronome-arrows', attributes: {}, contents: [] };
    return MetronomeArrows;
}());
exports.MetronomeArrows = MetronomeArrows;
/**
 * The `<metronome-type>` element
 *
 * Parent element: `<metronome-note>`
 *
 * The `<metronome-type>` element works like the `<type>` element in defining metric relationships.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-type/}
 */
var MetronomeType = /** @class */ (function () {
    function MetronomeType(opts) {
        var _a;
        this.schema = MetronomeType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MetronomeType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MetronomeType.schema.contents);
    }
    /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    MetronomeType.prototype.getNoteTypeValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    MetronomeType.prototype.setNoteTypeValue = function (noteTypeValue) {
        this.contents[0] = noteTypeValue;
        return this;
    };
    MetronomeType.schema = {
        name: 'metronome-type',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'note-type-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'whole',
                            '1024th',
                            '512th',
                            '256th',
                            '128th',
                            '64th',
                            '32nd',
                            '16th',
                            'eighth',
                            'half',
                            'quarter',
                            'whole',
                            'breve',
                            'long',
                            'maxima',
                        ],
                    },
                },
            },
        ],
    };
    return MetronomeType;
}());
exports.MetronomeType = MetronomeType;
/**
 * The `<metronome-dot>` element
 *
 * Parent element: `<metronome-note>`
 *
 * The metronome-dot element works like the dot element in defining metric relationships.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-dot/}
 */
var MetronomeDot = /** @class */ (function () {
    function MetronomeDot(opts) {
        var _a;
        this.schema = MetronomeDot.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MetronomeDot.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MetronomeDot.schema.contents);
    }
    MetronomeDot.schema = { name: 'metronome-dot', attributes: {}, contents: [] };
    return MetronomeDot;
}());
exports.MetronomeDot = MetronomeDot;
/**
 * The `<metronome-beam>` element
 *
 * Parent element: `<metronome-note>`
 *
 * The `<metronome-beam>` element works like the `<beam>` element in defining metric relationships, but does not include
 * all the attributes available in the `<beam>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-beam/}
 */
var MetronomeBeam = /** @class */ (function () {
    function MetronomeBeam(opts) {
        var _a;
        this.schema = MetronomeBeam.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MetronomeBeam.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MetronomeBeam.schema.contents);
    }
    /** Gets @type {MetronomeBeamAttributes['number']}. */
    MetronomeBeam.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {MetronomeBeamAttributes['number']}. */
    MetronomeBeam.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'}. */
    MetronomeBeam.prototype.getBeamValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'}. */
    MetronomeBeam.prototype.setBeamValue = function (beamValue) {
        this.contents[0] = beamValue;
        return this;
    };
    MetronomeBeam.schema = {
        name: 'metronome-beam',
        attributes: { number: { type: 'optional', value: { type: 'int', min: 1, max: 8 } } },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'beam-value',
                    value: { type: 'choices', choices: ['backward hook', 'begin', 'continue', 'end', 'forward hook'] },
                },
            },
        ],
    };
    return MetronomeBeam;
}());
exports.MetronomeBeam = MetronomeBeam;
/**
 * The `<metronome-tied>` element
 *
 * Parent element: `<metronome-note>`
 *
 * The `<metronome-tied>` element indicates the presence of a tie within a metric relationship mark. As with the
 * `<tied>` element, both the start and stop of the tie should be specified, in this case within separate
 * `<metronome-note>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-tied/}
 */
var MetronomeTied = /** @class */ (function () {
    function MetronomeTied(opts) {
        var _a;
        this.schema = MetronomeTied.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MetronomeTied.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MetronomeTied.schema.contents);
    }
    /** Gets @type {MetronomeTiedAttributes['type']}. */
    MetronomeTied.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {MetronomeTiedAttributes['type']}. */
    MetronomeTied.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    MetronomeTied.schema = {
        name: 'metronome-tied',
        attributes: { type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } } },
        contents: [],
    };
    return MetronomeTied;
}());
exports.MetronomeTied = MetronomeTied;
/**
 * The `<metronome-tuplet>` element
 *
 * Parent element: `<metronome-note>`
 *
 * The `<metronome-tuplet>` element uses the same element structure as the `<time-modification>` element, along with
 * some attributes from the `<tuplet>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-tuplet/}
 */
var MetronomeTuplet = /** @class */ (function () {
    function MetronomeTuplet(opts) {
        var _a;
        this.schema = MetronomeTuplet.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MetronomeTuplet.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MetronomeTuplet.schema.contents);
    }
    /** Gets @type {MetronomeTupletAttributes['type']}. */
    MetronomeTuplet.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {MetronomeTupletAttributes['type']}. */
    MetronomeTuplet.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {MetronomeTupletAttributes['bracket']}. */
    MetronomeTuplet.prototype.getBracket = function () {
        return this.attributes['bracket'];
    };
    /** Sets @type {MetronomeTupletAttributes['bracket']}. */
    MetronomeTuplet.prototype.setBracket = function (bracket) {
        this.attributes['bracket'] = bracket;
        return this;
    };
    /** Gets @type {MetronomeTupletAttributes['show-number']}. */
    MetronomeTuplet.prototype.getShowNumber = function () {
        return this.attributes['show-number'];
    };
    /** Sets @type {MetronomeTupletAttributes['show-number']}. */
    MetronomeTuplet.prototype.setShowNumber = function (showNumber) {
        this.attributes['show-number'] = showNumber;
        return this;
    };
    /** Gets @type {ActualNotes}. */
    MetronomeTuplet.prototype.getActualNotes = function () {
        return this.contents[0];
    };
    /** Sets @type {ActualNotes}. */
    MetronomeTuplet.prototype.setActualNotes = function (actualNotes) {
        this.contents[0] = actualNotes;
        return this;
    };
    /** Gets @type {NormalNotes}. */
    MetronomeTuplet.prototype.getNormalNotes = function () {
        return this.contents[1];
    };
    /** Sets @type {NormalNotes}. */
    MetronomeTuplet.prototype.setNormalNotes = function (normalNotes) {
        this.contents[1] = normalNotes;
        return this;
    };
    /** Gets @type {[NormalType, Array<NormalDot>] | null}. */
    MetronomeTuplet.prototype.getNormal = function () {
        return this.contents[2];
    };
    /** Sets @type {[NormalType, Array<NormalDot>] | null}. */
    MetronomeTuplet.prototype.setNormal = function (normal) {
        this.contents[2] = normal;
        return this;
    };
    MetronomeTuplet.schema = {
        name: 'metronome-tuplet',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'show-number': { type: 'optional', value: { type: 'choices', choices: ['none', 'actual', 'both'] } },
        },
        contents: [
            { type: 'required', value: ActualNotes },
            { type: 'required', value: NormalNotes },
            {
                type: 'label',
                label: 'normal',
                value: {
                    type: 'optional',
                    value: [
                        { type: 'required', value: NormalType },
                        { type: 'zeroOrMore', value: NormalDot },
                    ],
                },
            },
        ],
    };
    return MetronomeTuplet;
}());
exports.MetronomeTuplet = MetronomeTuplet;
/**
 * The `<metronome-note>` element
 *
 * Parent element: `<metronome>`
 *
 * The `<metronome-note>` element defines the appearance of a note within a metric relationship mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-note/}
 */
var MetronomeNote = /** @class */ (function () {
    function MetronomeNote(opts) {
        var _a;
        this.schema = MetronomeNote.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MetronomeNote.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MetronomeNote.schema.contents);
    }
    /** Gets @type {MetronomeType}. */
    MetronomeNote.prototype.getMetronomeType = function () {
        return this.contents[0];
    };
    /** Sets @type {MetronomeType}. */
    MetronomeNote.prototype.setMetronomeType = function (metronomeType) {
        this.contents[0] = metronomeType;
        return this;
    };
    /** Gets @type {Array<MetronomeDot>}. */
    MetronomeNote.prototype.getMetronomeDots = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<MetronomeDot>}. */
    MetronomeNote.prototype.setMetronomeDots = function (metronomeDots) {
        this.contents[1] = metronomeDots;
        return this;
    };
    /** Gets @type {Array<MetronomeBeam>}. */
    MetronomeNote.prototype.getMetronomeBeams = function () {
        return this.contents[2];
    };
    /** Sets @type {Array<MetronomeBeam>}. */
    MetronomeNote.prototype.setMetronomeBeams = function (metronomeBeams) {
        this.contents[2] = metronomeBeams;
        return this;
    };
    /** Gets @type {MetronomeTied | null}. */
    MetronomeNote.prototype.getMetronomeTied = function () {
        return this.contents[3];
    };
    /** Sets @type {MetronomeTied | null}. */
    MetronomeNote.prototype.setMetronomeTied = function (metronomeTied) {
        this.contents[3] = metronomeTied;
        return this;
    };
    /** Gets @type {MetronomeTuplet | null}. */
    MetronomeNote.prototype.getMetronomeTuplet = function () {
        return this.contents[4];
    };
    /** Sets @type {MetronomeTuplet | null}. */
    MetronomeNote.prototype.setMetronomeTuplet = function (metronomeTuplet) {
        this.contents[4] = metronomeTuplet;
        return this;
    };
    MetronomeNote.schema = {
        name: 'metronome-note',
        attributes: {},
        contents: [
            { type: 'required', value: MetronomeType },
            { type: 'label', label: 'metronome-dots', value: { type: 'zeroOrMore', value: MetronomeDot } },
            { type: 'label', label: 'metronome-beams', value: { type: 'zeroOrMore', value: MetronomeBeam } },
            { type: 'optional', value: MetronomeTied },
            { type: 'optional', value: MetronomeTuplet },
        ],
    };
    return MetronomeNote;
}());
exports.MetronomeNote = MetronomeNote;
/**
 * The `<metronome-relation>` element
 *
 * Parent element: `<metronome>`
 *
 * The `<metronome-relation>` element describes the relationship symbol that goes between the two sets of
 * `<metronome-note>` elements. The currently allowed value is equals, but this may expand in future versions. If the
 * element is empty, the equals value is used.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-relation/}
 */
var MetronomeRelation = /** @class */ (function () {
    function MetronomeRelation(opts) {
        var _a;
        this.schema = MetronomeRelation.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MetronomeRelation.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MetronomeRelation.schema.contents);
    }
    /** Gets @type {string | null}. */
    MetronomeRelation.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string | null}. */
    MetronomeRelation.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    MetronomeRelation.schema = {
        name: 'metronome-relation',
        attributes: {},
        contents: [{ type: 'optional', value: { type: 'string' } }],
    };
    return MetronomeRelation;
}());
exports.MetronomeRelation = MetronomeRelation;
/**
 * The `<metronome>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<metronome>` element represents metronome marks and other metric relationships. The `<beat-unit>` element group
 * and `<per-minute>` element specify regular metronome marks. The `<metronome-note>` and `<metronome-relation>`
 * elements allow for the specification of metric modulations and other metric relationships, such as swing tempo marks
 * where two eighths are equated to a quarter note / eighth note triplet. Tied notes can be represented in both types of
 * metronome marks by using the `<beat-unit-tied>` and `<metronome-tied>` elements. The print-object attribute is set to
 * no in cases where the `<metronome>` element represents a relationship or range that is not displayed in the music
 * notation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome/}
 */
var Metronome = /** @class */ (function () {
    function Metronome(opts) {
        var _a;
        this.schema = Metronome.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Metronome.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Metronome.schema.contents);
    }
    /** Gets @type {MetronomeAttributes['color']}. */
    Metronome.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {MetronomeAttributes['color']}. */
    Metronome.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {MetronomeAttributes['default-x']}. */
    Metronome.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {MetronomeAttributes['default-x']}. */
    Metronome.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {MetronomeAttributes['default-y']}. */
    Metronome.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {MetronomeAttributes['default-y']}. */
    Metronome.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {MetronomeAttributes['font-family']}. */
    Metronome.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {MetronomeAttributes['font-family']}. */
    Metronome.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {MetronomeAttributes['font-size']}. */
    Metronome.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {MetronomeAttributes['font-size']}. */
    Metronome.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {MetronomeAttributes['font-style']}. */
    Metronome.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {MetronomeAttributes['font-style']}. */
    Metronome.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {MetronomeAttributes['font-weight']}. */
    Metronome.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {MetronomeAttributes['font-weight']}. */
    Metronome.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {MetronomeAttributes['halign']}. */
    Metronome.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {MetronomeAttributes['halign']}. */
    Metronome.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {MetronomeAttributes['id']}. */
    Metronome.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {MetronomeAttributes['id']}. */
    Metronome.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {MetronomeAttributes['justify']}. */
    Metronome.prototype.getJustify = function () {
        return this.attributes['justify'];
    };
    /** Sets @type {MetronomeAttributes['justify']}. */
    Metronome.prototype.setJustify = function (justify) {
        this.attributes['justify'] = justify;
        return this;
    };
    /** Gets @type {MetronomeAttributes['parentheses']}. */
    Metronome.prototype.getParentheses = function () {
        return this.attributes['parentheses'];
    };
    /** Sets @type {MetronomeAttributes['parentheses']}. */
    Metronome.prototype.setParentheses = function (parentheses) {
        this.attributes['parentheses'] = parentheses;
        return this;
    };
    /** Gets @type {MetronomeAttributes['print-object']}. */
    Metronome.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {MetronomeAttributes['print-object']}. */
    Metronome.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {MetronomeAttributes['relative-x']}. */
    Metronome.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {MetronomeAttributes['relative-x']}. */
    Metronome.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {MetronomeAttributes['relative-y']}. */
    Metronome.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {MetronomeAttributes['relative-y']}. */
    Metronome.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {MetronomeAttributes['valign']}. */
    Metronome.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {MetronomeAttributes['valign']}. */
    Metronome.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {BeatSpec | MetronomeSpec}. */
    Metronome.prototype.getMetronome = function () {
        return this.contents[0];
    };
    /** Sets @type {BeatSpec | MetronomeSpec}. */
    Metronome.prototype.setMetronome = function (metronome) {
        this.contents[0] = metronome;
        return this;
    };
    Metronome.schema = {
        name: 'metronome',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [
            {
                type: 'label',
                label: 'metronome',
                value: {
                    type: 'choices',
                    choices: [
                        {
                            type: 'label',
                            label: 'beat-spec',
                            value: [
                                { type: 'required', value: BeatUnit },
                                { type: 'zeroOrMore', value: BeatUnitDot },
                                { type: 'zeroOrMore', value: BeatUnitTied },
                                {
                                    type: 'choices',
                                    choices: [
                                        PerMinute,
                                        [
                                            { type: 'required', value: BeatUnit },
                                            { type: 'zeroOrMore', value: BeatUnitDot },
                                            { type: 'zeroOrMore', value: BeatUnitTied },
                                        ],
                                    ],
                                },
                            ],
                        },
                        {
                            type: 'label',
                            label: 'metronome-spec',
                            value: [
                                { type: 'optional', value: MetronomeArrows },
                                { type: 'oneOrMore', value: MetronomeNote },
                                {
                                    type: 'optional',
                                    value: [
                                        { type: 'required', value: MetronomeRelation },
                                        { type: 'oneOrMore', value: MetronomeNote },
                                    ],
                                },
                            ],
                        },
                    ],
                },
            },
        ],
    };
    return Metronome;
}());
exports.Metronome = Metronome;
/**
 * The `<octave-shift>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<octave-shift>` element indicates where notes are shifted up or down from their performed values because of
 * printing difficulty. Thus a treble clef line noted with 8va will be indicated with an `<octave-shift>` down from the
 * pitch data indicated in the notes.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/octave-shift/}
 */
var OctaveShift = /** @class */ (function () {
    function OctaveShift(opts) {
        var _a;
        this.schema = OctaveShift.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OctaveShift.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OctaveShift.schema.contents);
    }
    /** Gets @type {OctaveShiftAttributes['type']}. */
    OctaveShift.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {OctaveShiftAttributes['type']}. */
    OctaveShift.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['color']}. */
    OctaveShift.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {OctaveShiftAttributes['color']}. */
    OctaveShift.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['dash-length']}. */
    OctaveShift.prototype.getDashLength = function () {
        return this.attributes['dash-length'];
    };
    /** Sets @type {OctaveShiftAttributes['dash-length']}. */
    OctaveShift.prototype.setDashLength = function (dashLength) {
        this.attributes['dash-length'] = dashLength;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['default-x']}. */
    OctaveShift.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {OctaveShiftAttributes['default-x']}. */
    OctaveShift.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['default-y']}. */
    OctaveShift.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {OctaveShiftAttributes['default-y']}. */
    OctaveShift.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['font-family']}. */
    OctaveShift.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {OctaveShiftAttributes['font-family']}. */
    OctaveShift.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['font-size']}. */
    OctaveShift.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {OctaveShiftAttributes['font-size']}. */
    OctaveShift.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['font-style']}. */
    OctaveShift.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {OctaveShiftAttributes['font-style']}. */
    OctaveShift.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['font-weight']}. */
    OctaveShift.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {OctaveShiftAttributes['font-weight']}. */
    OctaveShift.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['id']}. */
    OctaveShift.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {OctaveShiftAttributes['id']}. */
    OctaveShift.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['number']}. */
    OctaveShift.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {OctaveShiftAttributes['number']}. */
    OctaveShift.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['relative-x']}. */
    OctaveShift.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {OctaveShiftAttributes['relative-x']}. */
    OctaveShift.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['relative-y']}. */
    OctaveShift.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {OctaveShiftAttributes['relative-y']}. */
    OctaveShift.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['size']}. */
    OctaveShift.prototype.getSize = function () {
        return this.attributes['size'];
    };
    /** Sets @type {OctaveShiftAttributes['size']}. */
    OctaveShift.prototype.setSize = function (size) {
        this.attributes['size'] = size;
        return this;
    };
    /** Gets @type {OctaveShiftAttributes['space-length']}. */
    OctaveShift.prototype.getSpaceLength = function () {
        return this.attributes['space-length'];
    };
    /** Sets @type {OctaveShiftAttributes['space-length']}. */
    OctaveShift.prototype.setSpaceLength = function (spaceLength) {
        this.attributes['space-length'] = spaceLength;
        return this;
    };
    OctaveShift.schema = {
        name: 'octave-shift',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['up', 'down', 'stop', 'continue'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            size: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
            'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return OctaveShift;
}());
exports.OctaveShift = OctaveShift;
/**
 * The `<pedal-step>` element
 *
 * Parent element: `<pedal-tuning>`
 *
 * The `<pedal-step>` element defines the pitch step for a single harp pedal.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pedal-step/}
 */
var PedalStep = /** @class */ (function () {
    function PedalStep(opts) {
        var _a;
        this.schema = PedalStep.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PedalStep.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PedalStep.schema.contents);
    }
    /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    PedalStep.prototype.getStep = function () {
        return this.contents[0];
    };
    /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    PedalStep.prototype.setStep = function (step) {
        this.contents[0] = step;
        return this;
    };
    PedalStep.schema = {
        name: 'pedal-step',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'step',
                    value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
                },
            },
        ],
    };
    return PedalStep;
}());
exports.PedalStep = PedalStep;
/**
 * The `<pedal-alter>` element
 *
 * Parent element: `<pedal-tuning>`
 *
 * The `<pedal-alter>` element defines the chromatic alteration for a single harp pedal.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pedal-alter/}
 */
var PedalAlter = /** @class */ (function () {
    function PedalAlter(opts) {
        var _a;
        this.schema = PedalAlter.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PedalAlter.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PedalAlter.schema.contents);
    }
    /** Gets @type {number}. */
    PedalAlter.prototype.getSemitones = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    PedalAlter.prototype.setSemitones = function (semitones) {
        this.contents[0] = semitones;
        return this;
    };
    PedalAlter.schema = {
        name: 'pedal-alter',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return PedalAlter;
}());
exports.PedalAlter = PedalAlter;
/**
 * The `<pedal-tuning>` element
 *
 * Parent element: `<harp-pedals>`
 *
 * The `<pedal-tuning>` element specifies the tuning of a single harp pedal.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pedal-tuning/}
 */
var PedalTuning = /** @class */ (function () {
    function PedalTuning(opts) {
        var _a;
        this.schema = PedalTuning.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PedalTuning.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PedalTuning.schema.contents);
    }
    /** Gets @type {PedalStep}. */
    PedalTuning.prototype.getPedalStep = function () {
        return this.contents[0];
    };
    /** Sets @type {PedalStep}. */
    PedalTuning.prototype.setPedalStep = function (pedalStep) {
        this.contents[0] = pedalStep;
        return this;
    };
    /** Gets @type {PedalAlter}. */
    PedalTuning.prototype.getPedalAlter = function () {
        return this.contents[1];
    };
    /** Sets @type {PedalAlter}. */
    PedalTuning.prototype.setPedalAlter = function (pedalAlter) {
        this.contents[1] = pedalAlter;
        return this;
    };
    PedalTuning.schema = {
        name: 'pedal-tuning',
        attributes: {},
        contents: [
            { type: 'required', value: PedalStep },
            { type: 'required', value: PedalAlter },
        ],
    };
    return PedalTuning;
}());
exports.PedalTuning = PedalTuning;
/**
 * The `<harp-pedals>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<harp-pedals>` element represents harp pedal diagrams. The `<pedal-step>` and `<pedal-alter>` elements use the
 * same values as the `<step>` and `<alter>` elements. For easiest reading, the `<pedal-tuning>` elements should follow
 * standard harp pedal order, with `<pedal-step>` values of D, C, B, E, F, G, and A.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/harp-pedals/}
 */
var HarpPedals = /** @class */ (function () {
    function HarpPedals(opts) {
        var _a;
        this.schema = HarpPedals.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, HarpPedals.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(HarpPedals.schema.contents);
    }
    /** Gets @type {HarpPedalsAttributes['color']}. */
    HarpPedals.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {HarpPedalsAttributes['color']}. */
    HarpPedals.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['default-x']}. */
    HarpPedals.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {HarpPedalsAttributes['default-x']}. */
    HarpPedals.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['default-y']}. */
    HarpPedals.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {HarpPedalsAttributes['default-y']}. */
    HarpPedals.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['font-family']}. */
    HarpPedals.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {HarpPedalsAttributes['font-family']}. */
    HarpPedals.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['font-size']}. */
    HarpPedals.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {HarpPedalsAttributes['font-size']}. */
    HarpPedals.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['font-style']}. */
    HarpPedals.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {HarpPedalsAttributes['font-style']}. */
    HarpPedals.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['font-weight']}. */
    HarpPedals.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {HarpPedalsAttributes['font-weight']}. */
    HarpPedals.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['halign']}. */
    HarpPedals.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {HarpPedalsAttributes['halign']}. */
    HarpPedals.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['id']}. */
    HarpPedals.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {HarpPedalsAttributes['id']}. */
    HarpPedals.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['relative-x']}. */
    HarpPedals.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {HarpPedalsAttributes['relative-x']}. */
    HarpPedals.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['relative-y']}. */
    HarpPedals.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {HarpPedalsAttributes['relative-y']}. */
    HarpPedals.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {HarpPedalsAttributes['valign']}. */
    HarpPedals.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {HarpPedalsAttributes['valign']}. */
    HarpPedals.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {Array<PedalTuning>}. */
    HarpPedals.prototype.getPedalTunings = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<PedalTuning>}. */
    HarpPedals.prototype.setPedalTunings = function (pedalTunings) {
        this.contents[0] = pedalTunings;
        return this;
    };
    HarpPedals.schema = {
        name: 'harp-pedals',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [{ type: 'label', label: 'pedal-tunings', value: { type: 'oneOrMore', value: PedalTuning } }],
    };
    return HarpPedals;
}());
exports.HarpPedals = HarpPedals;
/**
 * The `<damp>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<damp>` element specifies a harp damping mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/damp/}
 */
var Damp = /** @class */ (function () {
    function Damp(opts) {
        var _a;
        this.schema = Damp.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Damp.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Damp.schema.contents);
    }
    /** Gets @type {DampAttributes['color']}. */
    Damp.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DampAttributes['color']}. */
    Damp.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DampAttributes['default-x']}. */
    Damp.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DampAttributes['default-x']}. */
    Damp.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DampAttributes['default-y']}. */
    Damp.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DampAttributes['default-y']}. */
    Damp.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DampAttributes['font-family']}. */
    Damp.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DampAttributes['font-family']}. */
    Damp.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DampAttributes['font-size']}. */
    Damp.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DampAttributes['font-size']}. */
    Damp.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DampAttributes['font-style']}. */
    Damp.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DampAttributes['font-style']}. */
    Damp.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DampAttributes['font-weight']}. */
    Damp.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DampAttributes['font-weight']}. */
    Damp.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DampAttributes['halign']}. */
    Damp.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {DampAttributes['halign']}. */
    Damp.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {DampAttributes['id']}. */
    Damp.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {DampAttributes['id']}. */
    Damp.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {DampAttributes['relative-x']}. */
    Damp.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DampAttributes['relative-x']}. */
    Damp.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DampAttributes['relative-y']}. */
    Damp.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DampAttributes['relative-y']}. */
    Damp.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DampAttributes['valign']}. */
    Damp.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {DampAttributes['valign']}. */
    Damp.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    Damp.schema = {
        name: 'damp',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [],
    };
    return Damp;
}());
exports.Damp = Damp;
/**
 * The `<damp-all>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<damp-all>` element specifies a harp damping mark for all strings.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/damp-all/}
 */
var DampAll = /** @class */ (function () {
    function DampAll(opts) {
        var _a;
        this.schema = DampAll.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DampAll.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DampAll.schema.contents);
    }
    /** Gets @type {DampAllAttributes['color']}. */
    DampAll.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DampAllAttributes['color']}. */
    DampAll.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DampAllAttributes['default-x']}. */
    DampAll.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DampAllAttributes['default-x']}. */
    DampAll.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DampAllAttributes['default-y']}. */
    DampAll.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DampAllAttributes['default-y']}. */
    DampAll.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DampAllAttributes['font-family']}. */
    DampAll.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DampAllAttributes['font-family']}. */
    DampAll.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DampAllAttributes['font-size']}. */
    DampAll.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DampAllAttributes['font-size']}. */
    DampAll.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DampAllAttributes['font-style']}. */
    DampAll.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DampAllAttributes['font-style']}. */
    DampAll.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DampAllAttributes['font-weight']}. */
    DampAll.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DampAllAttributes['font-weight']}. */
    DampAll.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DampAllAttributes['halign']}. */
    DampAll.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {DampAllAttributes['halign']}. */
    DampAll.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {DampAllAttributes['id']}. */
    DampAll.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {DampAllAttributes['id']}. */
    DampAll.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {DampAllAttributes['relative-x']}. */
    DampAll.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DampAllAttributes['relative-x']}. */
    DampAll.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DampAllAttributes['relative-y']}. */
    DampAll.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DampAllAttributes['relative-y']}. */
    DampAll.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DampAllAttributes['valign']}. */
    DampAll.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {DampAllAttributes['valign']}. */
    DampAll.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    DampAll.schema = {
        name: 'damp-all',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [],
    };
    return DampAll;
}());
exports.DampAll = DampAll;
/**
 * The `<eyeglasses>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<eyeglasses>` element represents the eyeglasses symbol, common in commercial music.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/eyeglasses/}
 */
var Eyeglasses = /** @class */ (function () {
    function Eyeglasses(opts) {
        var _a;
        this.schema = Eyeglasses.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Eyeglasses.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Eyeglasses.schema.contents);
    }
    /** Gets @type {EyeglassesAttributes['color']}. */
    Eyeglasses.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {EyeglassesAttributes['color']}. */
    Eyeglasses.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['default-x']}. */
    Eyeglasses.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {EyeglassesAttributes['default-x']}. */
    Eyeglasses.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['default-y']}. */
    Eyeglasses.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {EyeglassesAttributes['default-y']}. */
    Eyeglasses.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['font-family']}. */
    Eyeglasses.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {EyeglassesAttributes['font-family']}. */
    Eyeglasses.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['font-size']}. */
    Eyeglasses.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {EyeglassesAttributes['font-size']}. */
    Eyeglasses.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['font-style']}. */
    Eyeglasses.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {EyeglassesAttributes['font-style']}. */
    Eyeglasses.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['font-weight']}. */
    Eyeglasses.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {EyeglassesAttributes['font-weight']}. */
    Eyeglasses.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['halign']}. */
    Eyeglasses.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {EyeglassesAttributes['halign']}. */
    Eyeglasses.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['id']}. */
    Eyeglasses.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {EyeglassesAttributes['id']}. */
    Eyeglasses.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['relative-x']}. */
    Eyeglasses.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {EyeglassesAttributes['relative-x']}. */
    Eyeglasses.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['relative-y']}. */
    Eyeglasses.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {EyeglassesAttributes['relative-y']}. */
    Eyeglasses.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {EyeglassesAttributes['valign']}. */
    Eyeglasses.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {EyeglassesAttributes['valign']}. */
    Eyeglasses.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    Eyeglasses.schema = {
        name: 'eyeglasses',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [],
    };
    return Eyeglasses;
}());
exports.Eyeglasses = Eyeglasses;
/**
 * The `<string-mute>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<string-mute>` element represents string mute on and mute off symbols.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/string-mute/}
 */
var StringMute = /** @class */ (function () {
    function StringMute(opts) {
        var _a;
        this.schema = StringMute.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StringMute.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StringMute.schema.contents);
    }
    /** Gets @type {StringMuteAttributes['color']}. */
    StringMute.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {StringMuteAttributes['color']}. */
    StringMute.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {StringMuteAttributes['default-x']}. */
    StringMute.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {StringMuteAttributes['default-x']}. */
    StringMute.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {StringMuteAttributes['default-y']}. */
    StringMute.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {StringMuteAttributes['default-y']}. */
    StringMute.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {StringMuteAttributes['font-family']}. */
    StringMute.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {StringMuteAttributes['font-family']}. */
    StringMute.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {StringMuteAttributes['font-size']}. */
    StringMute.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {StringMuteAttributes['font-size']}. */
    StringMute.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {StringMuteAttributes['font-style']}. */
    StringMute.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {StringMuteAttributes['font-style']}. */
    StringMute.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {StringMuteAttributes['font-weight']}. */
    StringMute.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {StringMuteAttributes['font-weight']}. */
    StringMute.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {StringMuteAttributes['halign']}. */
    StringMute.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {StringMuteAttributes['halign']}. */
    StringMute.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {StringMuteAttributes['id']}. */
    StringMute.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {StringMuteAttributes['id']}. */
    StringMute.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {StringMuteAttributes['relative-x']}. */
    StringMute.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {StringMuteAttributes['relative-x']}. */
    StringMute.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {StringMuteAttributes['relative-y']}. */
    StringMute.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {StringMuteAttributes['relative-y']}. */
    StringMute.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {StringMuteAttributes['valign']}. */
    StringMute.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {StringMuteAttributes['valign']}. */
    StringMute.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    StringMute.schema = {
        name: 'string-mute',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [],
    };
    return StringMute;
}());
exports.StringMute = StringMute;
/**
 * The `<tuning-step>` element
 *
 * Parent elements: `<accord>`, `<staff-tuning>`
 *
 * The `<tuning-step>` element is represented like the `<step>` element, with a different name to reflect its different
 * function in string tuning.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuning-step/}
 */
var TuningStep = /** @class */ (function () {
    function TuningStep(opts) {
        var _a;
        this.schema = TuningStep.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TuningStep.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TuningStep.schema.contents);
    }
    /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    TuningStep.prototype.getStep = function () {
        return this.contents[0];
    };
    /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    TuningStep.prototype.setStep = function (step) {
        this.contents[0] = step;
        return this;
    };
    TuningStep.schema = {
        name: 'tuning-step',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'step',
                    value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
                },
            },
        ],
    };
    return TuningStep;
}());
exports.TuningStep = TuningStep;
/**
 * The `<tuning-alter>` element
 *
 * Parent elements: `<accord>`, `<staff-tuning>`
 *
 * The `<tuning-alter>` element is represented like the `<alter>` element, with a different name to reflect its
 * different function in string tuning.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuning-alter/}
 */
var TuningAlter = /** @class */ (function () {
    function TuningAlter(opts) {
        var _a;
        this.schema = TuningAlter.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TuningAlter.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TuningAlter.schema.contents);
    }
    /** Gets @type {number}. */
    TuningAlter.prototype.getSemitones = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    TuningAlter.prototype.setSemitones = function (semitones) {
        this.contents[0] = semitones;
        return this;
    };
    TuningAlter.schema = {
        name: 'tuning-alter',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return TuningAlter;
}());
exports.TuningAlter = TuningAlter;
/**
 * The `<tuning-octave>` element
 *
 * Parent elements: `<accord>`, `<staff-tuning>`
 *
 * The `<tuning-octave>` element is represented like the `<octave>` element, with a different name to reflect its
 * different function in string tuning.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuning-octave/}
 */
var TuningOctave = /** @class */ (function () {
    function TuningOctave(opts) {
        var _a;
        this.schema = TuningOctave.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TuningOctave.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TuningOctave.schema.contents);
    }
    /** Gets @type {number}. */
    TuningOctave.prototype.getOctave = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    TuningOctave.prototype.setOctave = function (octave) {
        this.contents[0] = octave;
        return this;
    };
    TuningOctave.schema = {
        name: 'tuning-octave',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
    };
    return TuningOctave;
}());
exports.TuningOctave = TuningOctave;
/**
 * The `<accord>` element
 *
 * Parent element: `<scordatura>`
 *
 * The `<accord>` element represents the tuning of a single string in the `<scordatura>` element. It uses the same group
 * of elements as the `<staff-tuning>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accord/}
 */
var Accord = /** @class */ (function () {
    function Accord(opts) {
        var _a;
        this.schema = Accord.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Accord.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Accord.schema.contents);
    }
    /** Gets @type {AccordAttributes['string']}. */
    Accord.prototype.getString = function () {
        return this.attributes['string'];
    };
    /** Sets @type {AccordAttributes['string']}. */
    Accord.prototype.setString = function (string) {
        this.attributes['string'] = string;
        return this;
    };
    /** Gets @type {TuningStep}. */
    Accord.prototype.getTuningStep = function () {
        return this.contents[0];
    };
    /** Sets @type {TuningStep}. */
    Accord.prototype.setTuningStep = function (tuningStep) {
        this.contents[0] = tuningStep;
        return this;
    };
    /** Gets @type {TuningAlter | null}. */
    Accord.prototype.getTuningAlter = function () {
        return this.contents[1];
    };
    /** Sets @type {TuningAlter | null}. */
    Accord.prototype.setTuningAlter = function (tuningAlter) {
        this.contents[1] = tuningAlter;
        return this;
    };
    /** Gets @type {TuningOctave}. */
    Accord.prototype.getTuningOctave = function () {
        return this.contents[2];
    };
    /** Sets @type {TuningOctave}. */
    Accord.prototype.setTuningOctave = function (tuningOctave) {
        this.contents[2] = tuningOctave;
        return this;
    };
    Accord.schema = {
        name: 'accord',
        attributes: { string: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } } },
        contents: [
            { type: 'required', value: TuningStep },
            { type: 'optional', value: TuningAlter },
            { type: 'required', value: TuningOctave },
        ],
    };
    return Accord;
}());
exports.Accord = Accord;
/**
 * The `<scordatura>` element
 *
 * Parent element: `<direction-type>`
 *
 * Scordatura string tunings are represented by a series of `<accord>` elements, similar to the `<staff-tuning>`
 * elements. Strings are numbered from high to low.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/scordatura/}
 */
var Scordatura = /** @class */ (function () {
    function Scordatura(opts) {
        var _a;
        this.schema = Scordatura.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Scordatura.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Scordatura.schema.contents);
    }
    /** Gets @type {ScordaturaAttributes['id']}. */
    Scordatura.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {ScordaturaAttributes['id']}. */
    Scordatura.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {Array<Accord>}. */
    Scordatura.prototype.getAccords = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Accord>}. */
    Scordatura.prototype.setAccords = function (accords) {
        this.contents[0] = accords;
        return this;
    };
    Scordatura.schema = {
        name: 'scordatura',
        attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [{ type: 'label', label: 'accords', value: { type: 'oneOrMore', value: Accord } }],
    };
    return Scordatura;
}());
exports.Scordatura = Scordatura;
/**
 * The `<image>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<image>` element is used to include graphical images in a score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/image/}
 */
var Image = /** @class */ (function () {
    function Image(opts) {
        var _a;
        this.schema = Image.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Image.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Image.schema.contents);
    }
    /** Gets @type {ImageAttributes['source']}. */
    Image.prototype.getSource = function () {
        return this.attributes['source'];
    };
    /** Sets @type {ImageAttributes['source']}. */
    Image.prototype.setSource = function (source) {
        this.attributes['source'] = source;
        return this;
    };
    /** Gets @type {ImageAttributes['type']}. */
    Image.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {ImageAttributes['type']}. */
    Image.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {ImageAttributes['default-x']}. */
    Image.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {ImageAttributes['default-x']}. */
    Image.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {ImageAttributes['default-y']}. */
    Image.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {ImageAttributes['default-y']}. */
    Image.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {ImageAttributes['halign']}. */
    Image.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {ImageAttributes['halign']}. */
    Image.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {ImageAttributes['id']}. */
    Image.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {ImageAttributes['id']}. */
    Image.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {ImageAttributes['relative-x']}. */
    Image.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {ImageAttributes['relative-x']}. */
    Image.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {ImageAttributes['relative-y']}. */
    Image.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {ImageAttributes['relative-y']}. */
    Image.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {ImageAttributes['valign']}. */
    Image.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {ImageAttributes['valign']}. */
    Image.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {ImageAttributes['width']}. */
    Image.prototype.getWidth = function () {
        return this.attributes['width'];
    };
    /** Sets @type {ImageAttributes['width']}. */
    Image.prototype.setWidth = function (width) {
        this.attributes['width'] = width;
        return this;
    };
    Image.schema = {
        name: 'image',
        attributes: {
            source: { type: 'required', value: { type: 'string' } },
            type: { type: 'required', value: { type: 'string' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
            width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return Image;
}());
exports.Image = Image;
/**
 * The `<principal-voice>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<principal-voice>` element represents principal and secondary voices in a score, either for analysis or for
 * square bracket symbols that appear in a score. The content of the `<principal-voice>` element is used for analysis
 * and may be any text value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/principal-voice/}
 */
var PrincipalVoice = /** @class */ (function () {
    function PrincipalVoice(opts) {
        var _a;
        this.schema = PrincipalVoice.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PrincipalVoice.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PrincipalVoice.schema.contents);
    }
    /** Gets @type {PrincipalVoiceAttributes['symbol']}. */
    PrincipalVoice.prototype.getSymbol = function () {
        return this.attributes['symbol'];
    };
    /** Sets @type {PrincipalVoiceAttributes['symbol']}. */
    PrincipalVoice.prototype.setSymbol = function (symbol) {
        this.attributes['symbol'] = symbol;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['type']}. */
    PrincipalVoice.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {PrincipalVoiceAttributes['type']}. */
    PrincipalVoice.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['color']}. */
    PrincipalVoice.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {PrincipalVoiceAttributes['color']}. */
    PrincipalVoice.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['default-x']}. */
    PrincipalVoice.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {PrincipalVoiceAttributes['default-x']}. */
    PrincipalVoice.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['default-y']}. */
    PrincipalVoice.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {PrincipalVoiceAttributes['default-y']}. */
    PrincipalVoice.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['font-family']}. */
    PrincipalVoice.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PrincipalVoiceAttributes['font-family']}. */
    PrincipalVoice.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['font-size']}. */
    PrincipalVoice.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PrincipalVoiceAttributes['font-size']}. */
    PrincipalVoice.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['font-style']}. */
    PrincipalVoice.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PrincipalVoiceAttributes['font-style']}. */
    PrincipalVoice.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['font-weight']}. */
    PrincipalVoice.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PrincipalVoiceAttributes['font-weight']}. */
    PrincipalVoice.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['halign']}. */
    PrincipalVoice.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {PrincipalVoiceAttributes['halign']}. */
    PrincipalVoice.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['id']}. */
    PrincipalVoice.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {PrincipalVoiceAttributes['id']}. */
    PrincipalVoice.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['relative-x']}. */
    PrincipalVoice.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {PrincipalVoiceAttributes['relative-x']}. */
    PrincipalVoice.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['relative-y']}. */
    PrincipalVoice.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {PrincipalVoiceAttributes['relative-y']}. */
    PrincipalVoice.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {PrincipalVoiceAttributes['valign']}. */
    PrincipalVoice.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {PrincipalVoiceAttributes['valign']}. */
    PrincipalVoice.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {string}. */
    PrincipalVoice.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    PrincipalVoice.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    PrincipalVoice.schema = {
        name: 'principal-voice',
        attributes: {
            symbol: {
                type: 'required',
                value: { type: 'choices', choices: ['none', 'Hauptstimme', 'Nebenstimme', 'plain'] },
            },
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return PrincipalVoice;
}());
exports.PrincipalVoice = PrincipalVoice;
/**
 * The `<glass>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<glass>` element represents pictograms for glass percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/glass/}
 */
var Glass = /** @class */ (function () {
    function Glass(opts) {
        var _a;
        this.schema = Glass.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Glass.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Glass.schema.contents);
    }
    /** Gets @type {GlassAttributes['smufl']}. */
    Glass.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {GlassAttributes['smufl']}. */
    Glass.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {'glass harmonica' | 'glass harp' | 'wind chimes'}. */
    Glass.prototype.getGlassValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'glass harmonica' | 'glass harp' | 'wind chimes'}. */
    Glass.prototype.setGlassValue = function (glassValue) {
        this.contents[0] = glassValue;
        return this;
    };
    Glass.schema = {
        name: 'glass',
        attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'glass-value',
                    value: { type: 'choices', choices: ['glass harmonica', 'glass harp', 'wind chimes'] },
                },
            },
        ],
    };
    return Glass;
}());
exports.Glass = Glass;
/**
 * The `<metal>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<metal>` element represents pictograms for metal percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metal/}
 */
var Metal = /** @class */ (function () {
    function Metal(opts) {
        var _a;
        this.schema = Metal.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Metal.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Metal.schema.contents);
    }
    /** Gets @type {MetalAttributes['smufl']}. */
    Metal.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {MetalAttributes['smufl']}. */
    Metal.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {'agogo' | 'almglocken' | 'bell' | 'bell plate' | 'bell tree' | 'brake drum' | 'cencerro' | 'chain rattle' | 'Chinese cymbal' | 'cowbell' | 'crash cymbals' | 'crotale' | 'cymbal tongs' | 'domed gong' | 'finger cymbals' | 'flexatone' | 'gong' | 'handbell' | 'hi-hat' | 'high-hat cymbals' | 'jaw harp' | 'jingle bells' | 'musical saw' | 'shell bells' | 'sistrum' | 'sizzle cymbal' | 'sleigh bells' | 'suspended cymbal' | 'tam tam' | 'tam tam with beater' | 'triangle' | 'Vietnamese hat'}. */
    Metal.prototype.getMetalValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'agogo' | 'almglocken' | 'bell' | 'bell plate' | 'bell tree' | 'brake drum' | 'cencerro' | 'chain rattle' | 'Chinese cymbal' | 'cowbell' | 'crash cymbals' | 'crotale' | 'cymbal tongs' | 'domed gong' | 'finger cymbals' | 'flexatone' | 'gong' | 'handbell' | 'hi-hat' | 'high-hat cymbals' | 'jaw harp' | 'jingle bells' | 'musical saw' | 'shell bells' | 'sistrum' | 'sizzle cymbal' | 'sleigh bells' | 'suspended cymbal' | 'tam tam' | 'tam tam with beater' | 'triangle' | 'Vietnamese hat'}. */
    Metal.prototype.setMetalValue = function (metalValue) {
        this.contents[0] = metalValue;
        return this;
    };
    Metal.schema = {
        name: 'metal',
        attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'metal-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'agogo',
                            'almglocken',
                            'bell',
                            'bell plate',
                            'bell tree',
                            'brake drum',
                            'cencerro',
                            'chain rattle',
                            'Chinese cymbal',
                            'cowbell',
                            'crash cymbals',
                            'crotale',
                            'cymbal tongs',
                            'domed gong',
                            'finger cymbals',
                            'flexatone',
                            'gong',
                            'handbell',
                            'hi-hat',
                            'high-hat cymbals',
                            'jaw harp',
                            'jingle bells',
                            'musical saw',
                            'shell bells',
                            'sistrum',
                            'sizzle cymbal',
                            'sleigh bells',
                            'suspended cymbal',
                            'tam tam',
                            'tam tam with beater',
                            'triangle',
                            'Vietnamese hat',
                        ],
                    },
                },
            },
        ],
    };
    return Metal;
}());
exports.Metal = Metal;
/**
 * The `<wood>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<wood>` element represents pictograms for wood percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/wood/}
 */
var Wood = /** @class */ (function () {
    function Wood(opts) {
        var _a;
        this.schema = Wood.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Wood.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Wood.schema.contents);
    }
    /** Gets @type {WoodAttributes['smufl']}. */
    Wood.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {WoodAttributes['smufl']}. */
    Wood.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {'bamboo scraper' | 'board clapper' | 'cabasa' | 'castanets' | 'castanets with handle' | 'claves' | 'footbal rattle' | 'guiro' | 'log drum' | 'maraca' | 'maracas' | 'quijada' | 'rainstick' | 'ratchet' | 'reco-reco' | 'sandpaper blocks' | 'slit drum' | 'temple block' | 'vibraslap' | 'whip' | 'wood block'}. */
    Wood.prototype.getWoodValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'bamboo scraper' | 'board clapper' | 'cabasa' | 'castanets' | 'castanets with handle' | 'claves' | 'footbal rattle' | 'guiro' | 'log drum' | 'maraca' | 'maracas' | 'quijada' | 'rainstick' | 'ratchet' | 'reco-reco' | 'sandpaper blocks' | 'slit drum' | 'temple block' | 'vibraslap' | 'whip' | 'wood block'}. */
    Wood.prototype.setWoodValue = function (woodValue) {
        this.contents[0] = woodValue;
        return this;
    };
    Wood.schema = {
        name: 'wood',
        attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'wood-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'bamboo scraper',
                            'board clapper',
                            'cabasa',
                            'castanets',
                            'castanets with handle',
                            'claves',
                            'footbal rattle',
                            'guiro',
                            'log drum',
                            'maraca',
                            'maracas',
                            'quijada',
                            'rainstick',
                            'ratchet',
                            'reco-reco',
                            'sandpaper blocks',
                            'slit drum',
                            'temple block',
                            'vibraslap',
                            'whip',
                            'wood block',
                        ],
                    },
                },
            },
        ],
    };
    return Wood;
}());
exports.Wood = Wood;
/**
 * The `<pitched>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<pitched>` element represents pictograms for pitched percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pitched/}
 */
var Pitched = /** @class */ (function () {
    function Pitched(opts) {
        var _a;
        this.schema = Pitched.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Pitched.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Pitched.schema.contents);
    }
    /** Gets @type {PitchedAttributes['smufl']}. */
    Pitched.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {PitchedAttributes['smufl']}. */
    Pitched.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    Pitched.schema = {
        name: 'pitched',
        attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
        contents: [],
    };
    return Pitched;
}());
exports.Pitched = Pitched;
/**
 * The `<membrane>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<membrane>` element represents pictograms for membrane percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/membrane/}
 */
var Membrane = /** @class */ (function () {
    function Membrane(opts) {
        var _a;
        this.schema = Membrane.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Membrane.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Membrane.schema.contents);
    }
    /** Gets @type {MembraneAttributes['smufl']}. */
    Membrane.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {MembraneAttributes['smufl']}. */
    Membrane.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {'bass drum' | 'bass drum on side' | 'bongos' | 'Chinese tomtom' | 'conga drum' | 'cuica' | 'goblet drum' | 'Indo-American tomtom' | 'Japanese tomtom' | 'military drum' | 'snare drum' | 'snare drum snares off' | 'tabla' | 'tambourine' | 'tenor drum' | 'timbales' | 'tomtom'}. */
    Membrane.prototype.getMembraneValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'bass drum' | 'bass drum on side' | 'bongos' | 'Chinese tomtom' | 'conga drum' | 'cuica' | 'goblet drum' | 'Indo-American tomtom' | 'Japanese tomtom' | 'military drum' | 'snare drum' | 'snare drum snares off' | 'tabla' | 'tambourine' | 'tenor drum' | 'timbales' | 'tomtom'}. */
    Membrane.prototype.setMembraneValue = function (membraneValue) {
        this.contents[0] = membraneValue;
        return this;
    };
    Membrane.schema = {
        name: 'membrane',
        attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'membrane-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'bass drum',
                            'bass drum on side',
                            'bongos',
                            'Chinese tomtom',
                            'conga drum',
                            'cuica',
                            'goblet drum',
                            'Indo-American tomtom',
                            'Japanese tomtom',
                            'military drum',
                            'snare drum',
                            'snare drum snares off',
                            'tabla',
                            'tambourine',
                            'tenor drum',
                            'timbales',
                            'tomtom',
                        ],
                    },
                },
            },
        ],
    };
    return Membrane;
}());
exports.Membrane = Membrane;
/**
 * The `<effect>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<effect>` element represents pictograms for sound effect percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/effect/}
 */
var Effect = /** @class */ (function () {
    function Effect(opts) {
        var _a;
        this.schema = Effect.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Effect.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Effect.schema.contents);
    }
    /** Gets @type {EffectAttributes['smufl']}. */
    Effect.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {EffectAttributes['smufl']}. */
    Effect.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {'anvil' | 'auto horn' | 'bird whistle' | 'cannon' | 'duck call' | 'gun shot' | 'klaxon horn' | 'lions roar' | 'lotus flute' | 'megaphone' | 'police whistle' | 'siren' | 'slide whistle' | 'thunder sheet' | 'wind machine' | 'wind whistle'}. */
    Effect.prototype.getEffectValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'anvil' | 'auto horn' | 'bird whistle' | 'cannon' | 'duck call' | 'gun shot' | 'klaxon horn' | 'lions roar' | 'lotus flute' | 'megaphone' | 'police whistle' | 'siren' | 'slide whistle' | 'thunder sheet' | 'wind machine' | 'wind whistle'}. */
    Effect.prototype.setEffectValue = function (effectValue) {
        this.contents[0] = effectValue;
        return this;
    };
    Effect.schema = {
        name: 'effect',
        attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'effect-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'anvil',
                            'auto horn',
                            'bird whistle',
                            'cannon',
                            'duck call',
                            'gun shot',
                            'klaxon horn',
                            'lions roar',
                            'lotus flute',
                            'megaphone',
                            'police whistle',
                            'siren',
                            'slide whistle',
                            'thunder sheet',
                            'wind machine',
                            'wind whistle',
                        ],
                    },
                },
            },
        ],
    };
    return Effect;
}());
exports.Effect = Effect;
/**
 * The `<timpani>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<timpani>` element represents the timpani pictogram.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/timpani/}
 */
var Timpani = /** @class */ (function () {
    function Timpani(opts) {
        var _a;
        this.schema = Timpani.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Timpani.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Timpani.schema.contents);
    }
    /** Gets @type {TimpaniAttributes['smufl']}. */
    Timpani.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {TimpaniAttributes['smufl']}. */
    Timpani.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    Timpani.schema = {
        name: 'timpani',
        attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
        contents: [],
    };
    return Timpani;
}());
exports.Timpani = Timpani;
/**
 * The `<beater>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<beater>` element represents pictograms for beaters, mallets, and sticks that do not have different materials
 * represented in the pictogram.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beater/}
 */
var Beater = /** @class */ (function () {
    function Beater(opts) {
        var _a;
        this.schema = Beater.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Beater.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Beater.schema.contents);
    }
    /** Gets @type {BeaterAttributes['tip']}. */
    Beater.prototype.getTip = function () {
        return this.attributes['tip'];
    };
    /** Sets @type {BeaterAttributes['tip']}. */
    Beater.prototype.setTip = function (tip) {
        this.attributes['tip'] = tip;
        return this;
    };
    /** Gets @type {'bow' | 'chime hammer' | 'coin' | 'drum stick' | 'finger' | 'fingernail' | 'fist' | 'guiro scraper' | 'hammer' | 'hand' | 'jazz stick' | 'knitting needle' | 'metal hammer' | 'slide brush on gong' | 'snare stick' | 'spoon mallet' | 'superball' | 'triangle beater' | 'triangle beater plain' | 'wire brush'}. */
    Beater.prototype.getBeaterValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'bow' | 'chime hammer' | 'coin' | 'drum stick' | 'finger' | 'fingernail' | 'fist' | 'guiro scraper' | 'hammer' | 'hand' | 'jazz stick' | 'knitting needle' | 'metal hammer' | 'slide brush on gong' | 'snare stick' | 'spoon mallet' | 'superball' | 'triangle beater' | 'triangle beater plain' | 'wire brush'}. */
    Beater.prototype.setBeaterValue = function (beaterValue) {
        this.contents[0] = beaterValue;
        return this;
    };
    Beater.schema = {
        name: 'beater',
        attributes: {
            tip: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: ['down', 'left', 'northeast', 'northwest', 'right', 'southeast', 'southwest', 'up'],
                },
            },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'beater-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'bow',
                            'chime hammer',
                            'coin',
                            'drum stick',
                            'finger',
                            'fingernail',
                            'fist',
                            'guiro scraper',
                            'hammer',
                            'hand',
                            'jazz stick',
                            'knitting needle',
                            'metal hammer',
                            'slide brush on gong',
                            'snare stick',
                            'spoon mallet',
                            'superball',
                            'triangle beater',
                            'triangle beater plain',
                            'wire brush',
                        ],
                    },
                },
            },
        ],
    };
    return Beater;
}());
exports.Beater = Beater;
/**
 * The `<stick-type>` element
 *
 * Parent element: `<stick>`
 *
 * The `<stick-type>` element represents the shape of pictograms where the material in the stick, mallet, or beater is
 * represented in the pictogram.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stick-type/}
 */
var StickType = /** @class */ (function () {
    function StickType(opts) {
        var _a;
        this.schema = StickType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StickType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StickType.schema.contents);
    }
    /** Gets @type {'bass drum' | 'double bass drum' | 'glockenspiel' | 'gum' | 'hammer' | 'superball' | 'timpani' | 'wound' | 'xylophone' | 'yarn'}. */
    StickType.prototype.getStickType = function () {
        return this.contents[0];
    };
    /** Sets @type {'bass drum' | 'double bass drum' | 'glockenspiel' | 'gum' | 'hammer' | 'superball' | 'timpani' | 'wound' | 'xylophone' | 'yarn'}. */
    StickType.prototype.setStickType = function (stickType) {
        this.contents[0] = stickType;
        return this;
    };
    StickType.schema = {
        name: 'stick-type',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'stick-type',
                    value: {
                        type: 'choices',
                        choices: [
                            'bass drum',
                            'double bass drum',
                            'glockenspiel',
                            'gum',
                            'hammer',
                            'superball',
                            'timpani',
                            'wound',
                            'xylophone',
                            'yarn',
                        ],
                    },
                },
            },
        ],
    };
    return StickType;
}());
exports.StickType = StickType;
/**
 * The `<stick-material>` element
 *
 * Parent element: `<stick>`
 *
 * The `<stick-material>` element represents the material being displayed in a stick pictogram.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stick-material/}
 */
var StickMaterial = /** @class */ (function () {
    function StickMaterial(opts) {
        var _a;
        this.schema = StickMaterial.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StickMaterial.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StickMaterial.schema.contents);
    }
    /** Gets @type {'x' | 'hard' | 'medium' | 'shaded' | 'soft'}. */
    StickMaterial.prototype.getStickMaterial = function () {
        return this.contents[0];
    };
    /** Sets @type {'x' | 'hard' | 'medium' | 'shaded' | 'soft'}. */
    StickMaterial.prototype.setStickMaterial = function (stickMaterial) {
        this.contents[0] = stickMaterial;
        return this;
    };
    StickMaterial.schema = {
        name: 'stick-material',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'stick-material',
                    value: { type: 'choices', choices: ['x', 'hard', 'medium', 'shaded', 'soft'] },
                },
            },
        ],
    };
    return StickMaterial;
}());
exports.StickMaterial = StickMaterial;
/**
 * The `<stick>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<stick>` element represents pictograms where the material of the stick, mallet, or beater is included.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stick/}
 */
var Stick = /** @class */ (function () {
    function Stick(opts) {
        var _a;
        this.schema = Stick.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Stick.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Stick.schema.contents);
    }
    /** Gets @type {StickAttributes['dashed-circle']}. */
    Stick.prototype.getDashedCircle = function () {
        return this.attributes['dashed-circle'];
    };
    /** Sets @type {StickAttributes['dashed-circle']}. */
    Stick.prototype.setDashedCircle = function (dashedCircle) {
        this.attributes['dashed-circle'] = dashedCircle;
        return this;
    };
    /** Gets @type {StickAttributes['parentheses']}. */
    Stick.prototype.getParentheses = function () {
        return this.attributes['parentheses'];
    };
    /** Sets @type {StickAttributes['parentheses']}. */
    Stick.prototype.setParentheses = function (parentheses) {
        this.attributes['parentheses'] = parentheses;
        return this;
    };
    /** Gets @type {StickAttributes['tip']}. */
    Stick.prototype.getTip = function () {
        return this.attributes['tip'];
    };
    /** Sets @type {StickAttributes['tip']}. */
    Stick.prototype.setTip = function (tip) {
        this.attributes['tip'] = tip;
        return this;
    };
    /** Gets @type {StickType}. */
    Stick.prototype.getStickType = function () {
        return this.contents[0];
    };
    /** Sets @type {StickType}. */
    Stick.prototype.setStickType = function (stickType) {
        this.contents[0] = stickType;
        return this;
    };
    /** Gets @type {StickMaterial}. */
    Stick.prototype.getStickMaterial = function () {
        return this.contents[1];
    };
    /** Sets @type {StickMaterial}. */
    Stick.prototype.setStickMaterial = function (stickMaterial) {
        this.contents[1] = stickMaterial;
        return this;
    };
    Stick.schema = {
        name: 'stick',
        attributes: {
            'dashed-circle': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            tip: {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: ['down', 'left', 'northeast', 'northwest', 'right', 'southeast', 'southwest', 'up'],
                },
            },
        },
        contents: [
            { type: 'required', value: StickType },
            { type: 'required', value: StickMaterial },
        ],
    };
    return Stick;
}());
exports.Stick = Stick;
/**
 * The `<stick-location>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<stick-location>` element represents pictograms for the location of sticks, beaters, or mallets on cymbals,
 * gongs, drums, and other instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stick-location/}
 */
var StickLocation = /** @class */ (function () {
    function StickLocation(opts) {
        var _a;
        this.schema = StickLocation.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StickLocation.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StickLocation.schema.contents);
    }
    /** Gets @type {'center' | 'cymbal bell' | 'cymbal edge' | 'rim'}. */
    StickLocation.prototype.getStickLocation = function () {
        return this.contents[0];
    };
    /** Sets @type {'center' | 'cymbal bell' | 'cymbal edge' | 'rim'}. */
    StickLocation.prototype.setStickLocation = function (stickLocation) {
        this.contents[0] = stickLocation;
        return this;
    };
    StickLocation.schema = {
        name: 'stick-location',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'stick-location',
                    value: { type: 'choices', choices: ['center', 'cymbal bell', 'cymbal edge', 'rim'] },
                },
            },
        ],
    };
    return StickLocation;
}());
exports.StickLocation = StickLocation;
/**
 * The `<other-percussion>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<other-percussion>` element represents percussion pictograms not defined elsewhere.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-percussion/}
 */
var OtherPercussion = /** @class */ (function () {
    function OtherPercussion(opts) {
        var _a;
        this.schema = OtherPercussion.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherPercussion.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherPercussion.schema.contents);
    }
    /** Gets @type {OtherPercussionAttributes['smufl']}. */
    OtherPercussion.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {OtherPercussionAttributes['smufl']}. */
    OtherPercussion.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {string}. */
    OtherPercussion.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    OtherPercussion.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    OtherPercussion.schema = {
        name: 'other-percussion',
        attributes: { smufl: { type: 'optional', value: { type: 'string' } } },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return OtherPercussion;
}());
exports.OtherPercussion = OtherPercussion;
/**
 * The `<percussion>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<percussion>` element is used to define percussion pictogram symbols. The organization of these symbols follows
 * the definitions in Kurt Stone's "Music Notation in the Twentieth Century" on pages 206-212 and 223. More pictograms
 * have been added to the ones listed in Stone, based on how usage has evolved since the book was published in 1980.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/percussion/}
 */
var Percussion = /** @class */ (function () {
    function Percussion(opts) {
        var _a;
        this.schema = Percussion.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Percussion.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Percussion.schema.contents);
    }
    /** Gets @type {PercussionAttributes['color']}. */
    Percussion.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {PercussionAttributes['color']}. */
    Percussion.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {PercussionAttributes['default-x']}. */
    Percussion.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {PercussionAttributes['default-x']}. */
    Percussion.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {PercussionAttributes['default-y']}. */
    Percussion.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {PercussionAttributes['default-y']}. */
    Percussion.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {PercussionAttributes['font-family']}. */
    Percussion.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PercussionAttributes['font-family']}. */
    Percussion.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PercussionAttributes['font-size']}. */
    Percussion.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PercussionAttributes['font-size']}. */
    Percussion.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PercussionAttributes['font-style']}. */
    Percussion.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PercussionAttributes['font-style']}. */
    Percussion.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PercussionAttributes['font-weight']}. */
    Percussion.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PercussionAttributes['font-weight']}. */
    Percussion.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {PercussionAttributes['halign']}. */
    Percussion.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {PercussionAttributes['halign']}. */
    Percussion.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {PercussionAttributes['id']}. */
    Percussion.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {PercussionAttributes['id']}. */
    Percussion.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {PercussionAttributes['relative-x']}. */
    Percussion.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {PercussionAttributes['relative-x']}. */
    Percussion.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {PercussionAttributes['relative-y']}. */
    Percussion.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {PercussionAttributes['relative-y']}. */
    Percussion.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {PercussionAttributes['valign']}. */
    Percussion.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {PercussionAttributes['valign']}. */
    Percussion.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {Glass | Metal | Wood | Pitched | Membrane | Effect | Timpani | Beater | Stick | StickLocation | OtherPercussion}. */
    Percussion.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {Glass | Metal | Wood | Pitched | Membrane | Effect | Timpani | Beater | Stick | StickLocation | OtherPercussion}. */
    Percussion.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Percussion.schema = {
        name: 'percussion',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [
            {
                type: 'label',
                label: 'value',
                value: {
                    type: 'choices',
                    choices: [
                        Glass,
                        Metal,
                        Wood,
                        Pitched,
                        Membrane,
                        Effect,
                        Timpani,
                        Beater,
                        Stick,
                        StickLocation,
                        OtherPercussion,
                    ],
                },
            },
        ],
    };
    return Percussion;
}());
exports.Percussion = Percussion;
/**
 * The `<accordion-high>` element
 *
 * Parent element: `<accordion-registration>`
 *
 * The `<accordion-high>` element indicates the presence of a dot in the high (4') section of the registration symbol.
 * This element is omitted if no dot is present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accordion-high/}
 */
var AccordionHigh = /** @class */ (function () {
    function AccordionHigh(opts) {
        var _a;
        this.schema = AccordionHigh.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, AccordionHigh.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(AccordionHigh.schema.contents);
    }
    AccordionHigh.schema = { name: 'accordion-high', attributes: {}, contents: [] };
    return AccordionHigh;
}());
exports.AccordionHigh = AccordionHigh;
/**
 * The `<accordion-middle>` element
 *
 * Parent element: `<accordion-registration>`
 *
 * The `<accordion-middle>` element indicates the presence of 1 to 3 dots in the middle (8') section of the registration
 * symbol. This element is omitted if no dots are present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accordion-middle/}
 */
var AccordionMiddle = /** @class */ (function () {
    function AccordionMiddle(opts) {
        var _a;
        this.schema = AccordionMiddle.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, AccordionMiddle.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(AccordionMiddle.schema.contents);
    }
    /** Gets @type {number}. */
    AccordionMiddle.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    AccordionMiddle.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    AccordionMiddle.schema = {
        name: 'accordion-middle',
        attributes: {},
        contents: [{ type: 'label', label: 'value', value: { type: 'int', min: 1, max: 3 } }],
    };
    return AccordionMiddle;
}());
exports.AccordionMiddle = AccordionMiddle;
/**
 * The `<accordion-low>` element
 *
 * Parent element: `<accordion-registration>`
 *
 * The `<accordion-low>` element indicates the presence of a dot in the low (16') section of the registration symbol.
 * This element is omitted if no dot is present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accordion-low/}
 */
var AccordionLow = /** @class */ (function () {
    function AccordionLow(opts) {
        var _a;
        this.schema = AccordionLow.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, AccordionLow.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(AccordionLow.schema.contents);
    }
    AccordionLow.schema = { name: 'accordion-low', attributes: {}, contents: [] };
    return AccordionLow;
}());
exports.AccordionLow = AccordionLow;
/**
 * The `<accordion-registration>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<accordion-registration>` element is used for accordion registration symbols. These are circular symbols divided
 * horizontally into high, middle, and low sections that correspond to 4', 8', and 16' pipes. Each `<accordion-high>`,
 * `<accordion-middle>`, and `<accordion-low>` element represents the presence of one or more dots in the registration
 * diagram. An `<accordion-registration>` element needs to have at least one of the child elements present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accordion-registration/}
 */
var AccordionRegistration = /** @class */ (function () {
    function AccordionRegistration(opts) {
        var _a;
        this.schema = AccordionRegistration.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, AccordionRegistration.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(AccordionRegistration.schema.contents);
    }
    /** Gets @type {AccordionRegistrationAttributes['color']}. */
    AccordionRegistration.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {AccordionRegistrationAttributes['color']}. */
    AccordionRegistration.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['default-x']}. */
    AccordionRegistration.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {AccordionRegistrationAttributes['default-x']}. */
    AccordionRegistration.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['default-y']}. */
    AccordionRegistration.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {AccordionRegistrationAttributes['default-y']}. */
    AccordionRegistration.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['font-family']}. */
    AccordionRegistration.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {AccordionRegistrationAttributes['font-family']}. */
    AccordionRegistration.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['font-size']}. */
    AccordionRegistration.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {AccordionRegistrationAttributes['font-size']}. */
    AccordionRegistration.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['font-style']}. */
    AccordionRegistration.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {AccordionRegistrationAttributes['font-style']}. */
    AccordionRegistration.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['font-weight']}. */
    AccordionRegistration.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {AccordionRegistrationAttributes['font-weight']}. */
    AccordionRegistration.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['halign']}. */
    AccordionRegistration.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {AccordionRegistrationAttributes['halign']}. */
    AccordionRegistration.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['id']}. */
    AccordionRegistration.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {AccordionRegistrationAttributes['id']}. */
    AccordionRegistration.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['relative-x']}. */
    AccordionRegistration.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {AccordionRegistrationAttributes['relative-x']}. */
    AccordionRegistration.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['relative-y']}. */
    AccordionRegistration.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {AccordionRegistrationAttributes['relative-y']}. */
    AccordionRegistration.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {AccordionRegistrationAttributes['valign']}. */
    AccordionRegistration.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {AccordionRegistrationAttributes['valign']}. */
    AccordionRegistration.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {AccordionHigh | null}. */
    AccordionRegistration.prototype.getAccordionHigh = function () {
        return this.contents[0];
    };
    /** Sets @type {AccordionHigh | null}. */
    AccordionRegistration.prototype.setAccordionHigh = function (accordionHigh) {
        this.contents[0] = accordionHigh;
        return this;
    };
    /** Gets @type {AccordionMiddle | null}. */
    AccordionRegistration.prototype.getAccordionMiddle = function () {
        return this.contents[1];
    };
    /** Sets @type {AccordionMiddle | null}. */
    AccordionRegistration.prototype.setAccordionMiddle = function (accordionMiddle) {
        this.contents[1] = accordionMiddle;
        return this;
    };
    /** Gets @type {AccordionLow | null}. */
    AccordionRegistration.prototype.getAccordionLow = function () {
        return this.contents[2];
    };
    /** Sets @type {AccordionLow | null}. */
    AccordionRegistration.prototype.setAccordionLow = function (accordionLow) {
        this.contents[2] = accordionLow;
        return this;
    };
    AccordionRegistration.schema = {
        name: 'accordion-registration',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [
            { type: 'optional', value: AccordionHigh },
            { type: 'optional', value: AccordionMiddle },
            { type: 'optional', value: AccordionLow },
        ],
    };
    return AccordionRegistration;
}());
exports.AccordionRegistration = AccordionRegistration;
/**
 * The `<staff-divide>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<staff-divide>` element represents the staff division arrow symbols found in the Standard Music Font Layout
 * (SMuFL) Staff brackets and dividers range at code points U+E00B, U+E00C, and U+E00D.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-divide/}
 */
var StaffDivide = /** @class */ (function () {
    function StaffDivide(opts) {
        var _a;
        this.schema = StaffDivide.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StaffDivide.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StaffDivide.schema.contents);
    }
    /** Gets @type {StaffDivideAttributes['type']}. */
    StaffDivide.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {StaffDivideAttributes['type']}. */
    StaffDivide.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['color']}. */
    StaffDivide.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {StaffDivideAttributes['color']}. */
    StaffDivide.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['default-x']}. */
    StaffDivide.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {StaffDivideAttributes['default-x']}. */
    StaffDivide.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['default-y']}. */
    StaffDivide.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {StaffDivideAttributes['default-y']}. */
    StaffDivide.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['font-family']}. */
    StaffDivide.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {StaffDivideAttributes['font-family']}. */
    StaffDivide.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['font-size']}. */
    StaffDivide.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {StaffDivideAttributes['font-size']}. */
    StaffDivide.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['font-style']}. */
    StaffDivide.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {StaffDivideAttributes['font-style']}. */
    StaffDivide.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['font-weight']}. */
    StaffDivide.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {StaffDivideAttributes['font-weight']}. */
    StaffDivide.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['halign']}. */
    StaffDivide.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {StaffDivideAttributes['halign']}. */
    StaffDivide.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['id']}. */
    StaffDivide.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {StaffDivideAttributes['id']}. */
    StaffDivide.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['relative-x']}. */
    StaffDivide.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {StaffDivideAttributes['relative-x']}. */
    StaffDivide.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['relative-y']}. */
    StaffDivide.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {StaffDivideAttributes['relative-y']}. */
    StaffDivide.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {StaffDivideAttributes['valign']}. */
    StaffDivide.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {StaffDivideAttributes['valign']}. */
    StaffDivide.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    StaffDivide.schema = {
        name: 'staff-divide',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['down', 'up', 'up-down'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [],
    };
    return StaffDivide;
}());
exports.StaffDivide = StaffDivide;
/**
 * The `<other-direction>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<other-direction>` element is used to define any `<direction>` symbols not yet in the MusicXML format. The smufl
 * attribute can be used to specify a particular direction symbol, allowing application interoperability without
 * requiring every SMuFL glyph to have a MusicXML element equivalent. Using the <other-direction> element without the
 * smufl attribute allows for extended representation, though without application interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-direction/}
 */
var OtherDirection = /** @class */ (function () {
    function OtherDirection(opts) {
        var _a;
        this.schema = OtherDirection.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherDirection.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherDirection.schema.contents);
    }
    /** Gets @type {OtherDirectionAttributes['color']}. */
    OtherDirection.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {OtherDirectionAttributes['color']}. */
    OtherDirection.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['default-x']}. */
    OtherDirection.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {OtherDirectionAttributes['default-x']}. */
    OtherDirection.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['default-y']}. */
    OtherDirection.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {OtherDirectionAttributes['default-y']}. */
    OtherDirection.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['font-family']}. */
    OtherDirection.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {OtherDirectionAttributes['font-family']}. */
    OtherDirection.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['font-size']}. */
    OtherDirection.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {OtherDirectionAttributes['font-size']}. */
    OtherDirection.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['font-style']}. */
    OtherDirection.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {OtherDirectionAttributes['font-style']}. */
    OtherDirection.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['font-weight']}. */
    OtherDirection.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {OtherDirectionAttributes['font-weight']}. */
    OtherDirection.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['halign']}. */
    OtherDirection.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {OtherDirectionAttributes['halign']}. */
    OtherDirection.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['id']}. */
    OtherDirection.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {OtherDirectionAttributes['id']}. */
    OtherDirection.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['print-object']}. */
    OtherDirection.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {OtherDirectionAttributes['print-object']}. */
    OtherDirection.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['relative-x']}. */
    OtherDirection.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {OtherDirectionAttributes['relative-x']}. */
    OtherDirection.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['relative-y']}. */
    OtherDirection.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {OtherDirectionAttributes['relative-y']}. */
    OtherDirection.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['smufl']}. */
    OtherDirection.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {OtherDirectionAttributes['smufl']}. */
    OtherDirection.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {OtherDirectionAttributes['valign']}. */
    OtherDirection.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {OtherDirectionAttributes['valign']}. */
    OtherDirection.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {string}. */
    OtherDirection.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    OtherDirection.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    OtherDirection.schema = {
        name: 'other-direction',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            smufl: { type: 'optional', value: { type: 'string' } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [{ type: 'string' }],
    };
    return OtherDirection;
}());
exports.OtherDirection = OtherDirection;
/**
 * The `<direction-type>` element
 *
 * Parent element: `<direction>`
 *
 * Textual direction types may have more than 1 component due to multiple fonts. The `<dynamics>` element may also be
 * used in the `<notations>` element. Child element attributes related to print suggestions apply to the individual
 * `<direction-type>`, not to the overall `<direction>`.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/direction-type/}
 */
var DirectionType = /** @class */ (function () {
    function DirectionType(opts) {
        var _a;
        this.schema = DirectionType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DirectionType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DirectionType.schema.contents);
    }
    /** Gets @type {DirectionTypeAttributes['id']}. */
    DirectionType.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {DirectionTypeAttributes['id']}. */
    DirectionType.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {Rehearsals | Segnos | Codas | Tokens | Wedge | DynamicsList | Dashes | Bracket | Pedal | Metronome | OctaveShift | HarpPedals | Damp | DampAll | Eyeglasses | StringMute | Scordatura | Image | PrincipalVoice | Percussions | AccordionRegistration | StaffDivide | OtherDirection}. */
    DirectionType.prototype.getDirectionType = function () {
        return this.contents[0];
    };
    /** Sets @type {Rehearsals | Segnos | Codas | Tokens | Wedge | DynamicsList | Dashes | Bracket | Pedal | Metronome | OctaveShift | HarpPedals | Damp | DampAll | Eyeglasses | StringMute | Scordatura | Image | PrincipalVoice | Percussions | AccordionRegistration | StaffDivide | OtherDirection}. */
    DirectionType.prototype.setDirectionType = function (directionType) {
        this.contents[0] = directionType;
        return this;
    };
    DirectionType.schema = {
        name: 'direction-type',
        attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [
            {
                type: 'label',
                label: 'direction-type',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'label', label: 'rehearsals', value: { type: 'oneOrMore', value: Rehearsal } },
                        { type: 'label', label: 'segnos', value: { type: 'oneOrMore', value: Segno } },
                        { type: 'label', label: 'codas', value: { type: 'oneOrMore', value: Coda } },
                        {
                            type: 'label',
                            label: 'tokens',
                            value: { type: 'oneOrMore', value: { type: 'choices', choices: [Words, Symbol] } },
                        },
                        Wedge,
                        { type: 'label', label: 'dynamics-list', value: { type: 'oneOrMore', value: Dynamics } },
                        Dashes,
                        Bracket,
                        Pedal,
                        Metronome,
                        OctaveShift,
                        HarpPedals,
                        Damp,
                        DampAll,
                        Eyeglasses,
                        StringMute,
                        Scordatura,
                        Image,
                        PrincipalVoice,
                        { type: 'label', label: 'percussions', value: { type: 'oneOrMore', value: Percussion } },
                        AccordionRegistration,
                        StaffDivide,
                        OtherDirection,
                    ],
                },
            },
        ],
    };
    return DirectionType;
}());
exports.DirectionType = DirectionType;
/**
 * The `<offset>` element
 *
 * Parent elements: `<direction>`, `<harmony>`, `<listening>`, `<sound>`
 *
 * An `<offset>` is represented in terms of divisions, and indicates where the direction will appear relative to the
 * current musical location. The current musical location is always within the current measure, even at the end of a
 * measure. If an element within a `<direction>` includes a default-x attribute, the `<offset>` value will be ignored
 * when determining the appearance of that element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/offset/}
 */
var Offset = /** @class */ (function () {
    function Offset(opts) {
        var _a;
        this.schema = Offset.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Offset.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Offset.schema.contents);
    }
    /** Gets @type {OffsetAttributes['sound']}. */
    Offset.prototype.getSound = function () {
        return this.attributes['sound'];
    };
    /** Sets @type {OffsetAttributes['sound']}. */
    Offset.prototype.setSound = function (sound) {
        this.attributes['sound'] = sound;
        return this;
    };
    /** Gets @type {number}. */
    Offset.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Offset.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Offset.schema = {
        name: 'offset',
        attributes: { sound: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return Offset;
}());
exports.Offset = Offset;
/**
 * The `<instrument-change>` element
 *
 * Parent element: `<sound>`
 *
 * The `<instrument-change>` element type represents a change to the virtual instrument sound for a given
 * `<score-instrument>`. All `<instrument-change>` child elements can also be initially specified within the
 * `<score-instrument>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument-change/}
 */
var InstrumentChange = /** @class */ (function () {
    function InstrumentChange(opts) {
        var _a;
        this.schema = InstrumentChange.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, InstrumentChange.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(InstrumentChange.schema.contents);
    }
    /** Gets @type {InstrumentChangeAttributes['id']}. */
    InstrumentChange.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {InstrumentChangeAttributes['id']}. */
    InstrumentChange.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {InstrumentSound | null}. */
    InstrumentChange.prototype.getInstrumentSound = function () {
        return this.contents[0];
    };
    /** Sets @type {InstrumentSound | null}. */
    InstrumentChange.prototype.setInstrumentSound = function (instrumentSound) {
        this.contents[0] = instrumentSound;
        return this;
    };
    /** Gets @type {Array<Solo | Ensemble>}. */
    InstrumentChange.prototype.getInstrumentTypes = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<Solo | Ensemble>}. */
    InstrumentChange.prototype.setInstrumentTypes = function (instrumentTypes) {
        this.contents[1] = instrumentTypes;
        return this;
    };
    /** Gets @type {VirtualInstrument | null}. */
    InstrumentChange.prototype.getVirtualInstrument = function () {
        return this.contents[2];
    };
    /** Sets @type {VirtualInstrument | null}. */
    InstrumentChange.prototype.setVirtualInstrument = function (virtualInstrument) {
        this.contents[2] = virtualInstrument;
        return this;
    };
    InstrumentChange.schema = {
        name: 'instrument-change',
        attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
        contents: [
            { type: 'optional', value: InstrumentSound },
            {
                type: 'label',
                label: 'instrument-types',
                value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Solo, Ensemble] } },
            },
            { type: 'optional', value: VirtualInstrument },
        ],
    };
    return InstrumentChange;
}());
exports.InstrumentChange = InstrumentChange;
/**
 * The `<straight>` element
 *
 * Parent element: `<swing>`
 *
 * The `<straight>` element specifies that no swing is present, so consecutive notes have equal durations.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/straight/}
 */
var Straight = /** @class */ (function () {
    function Straight(opts) {
        var _a;
        this.schema = Straight.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Straight.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Straight.schema.contents);
    }
    Straight.schema = { name: 'straight', attributes: {}, contents: [] };
    return Straight;
}());
exports.Straight = Straight;
/**
 * The `<first>` element
 *
 * Parent element: `<swing>`
 *
 * The `<first>` element is the part of the swing ratio that refers to the first of two consecutive notes.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/first/}
 */
var First = /** @class */ (function () {
    function First(opts) {
        var _a;
        this.schema = First.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, First.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(First.schema.contents);
    }
    /** Gets @type {number}. */
    First.prototype.getSwingRatio = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    First.prototype.setSwingRatio = function (swingRatio) {
        this.contents[0] = swingRatio;
        return this;
    };
    First.schema = {
        name: 'first',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'swing-ratio',
                value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
            },
        ],
    };
    return First;
}());
exports.First = First;
/**
 * The `<second>` element
 *
 * Parent element: `<swing>`
 *
 * The `<second>` element is the part of the swing ratio that refers to the second of two consecutive notes.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/second/}
 */
var Second = /** @class */ (function () {
    function Second(opts) {
        var _a;
        this.schema = Second.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Second.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Second.schema.contents);
    }
    /** Gets @type {number}. */
    Second.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Second.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Second.schema = {
        name: 'second',
        attributes: {},
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
        ],
    };
    return Second;
}());
exports.Second = Second;
/**
 * The `<swing-type>` element
 *
 * Parent element: `<swing>`
 *
 * The `<swing-type>` element specifies the note type, either eighth or 16th, to which the `<first>` to `<second>` ratio
 * is applied. The value is eighth if this element is not present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/swing-type/}
 */
var SwingType = /** @class */ (function () {
    function SwingType(opts) {
        var _a;
        this.schema = SwingType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SwingType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SwingType.schema.contents);
    }
    /** Gets @type {'eighth' | '16th'}. */
    SwingType.prototype.getEighth = function () {
        return this.contents[0];
    };
    /** Sets @type {'eighth' | '16th'}. */
    SwingType.prototype.setEighth = function (eighth) {
        this.contents[0] = eighth;
        return this;
    };
    SwingType.schema = {
        name: 'swing-type',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'eighth', value: { type: 'choices', choices: ['eighth', '16th'] } },
            },
        ],
    };
    return SwingType;
}());
exports.SwingType = SwingType;
/**
 * The `<swing-style>` element
 *
 * Parent element: `<swing>`
 *
 * The `<swing-style>` element is a string describing the style of swing used.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/swing-style/}
 */
var SwingStyle = /** @class */ (function () {
    function SwingStyle(opts) {
        var _a;
        this.schema = SwingStyle.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SwingStyle.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SwingStyle.schema.contents);
    }
    /** Gets @type {string}. */
    SwingStyle.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    SwingStyle.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    SwingStyle.schema = {
        name: 'swing-style',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return SwingStyle;
}());
exports.SwingStyle = SwingStyle;
/**
 * The `<swing>` element
 *
 * Parent element: `<sound>`
 *
 * The `<swing>` element specifies whether or not to use swing playback, where consecutive on-beat / off-beat eighth or
 * 16th notes are played with unequal nominal durations.
 *
 * The `<first>` and `<second>` elements are positive integers that specify the ratio between durations of consecutive
 * notes. For example, a `<first>` element with a value of 2 and a `<second>` element with a value of 1 applied to
 * eighth notes specifies a quarter note / eighth note tuplet playback, where the first note is twice as long as the
 * second note. Ratios should be specified with the smallest integers possible. For example, a ratio of 6 to 4 should be
 * specified as 3 to 2 instead.
 *
 * The `<swing>` element has no effect for playback of grace notes, notes where a `<type>` element is not present, and
 * notes where the specified `<duration>` is different than the nominal value associated with the specified `<type>`. If
 * a swung note has attack and release attributes, those values modify the swung playback.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/swing/}
 */
var Swing = /** @class */ (function () {
    function Swing(opts) {
        var _a;
        this.schema = Swing.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Swing.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Swing.schema.contents);
    }
    /** Gets @type {Straight | AlternateSwing}. */
    Swing.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {Straight | AlternateSwing}. */
    Swing.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    /** Gets @type {SwingStyle | null}. */
    Swing.prototype.getSwingStyle = function () {
        return this.contents[1];
    };
    /** Sets @type {SwingStyle | null}. */
    Swing.prototype.setSwingStyle = function (swingStyle) {
        this.contents[1] = swingStyle;
        return this;
    };
    Swing.schema = {
        name: 'swing',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'value',
                value: {
                    type: 'choices',
                    choices: [
                        Straight,
                        {
                            type: 'label',
                            label: 'alternate-swing',
                            value: [
                                { type: 'required', value: First },
                                { type: 'required', value: Second },
                                { type: 'optional', value: SwingType },
                            ],
                        },
                    ],
                },
            },
            { type: 'optional', value: SwingStyle },
        ],
    };
    return Swing;
}());
exports.Swing = Swing;
/**
 * The `<sound>` element
 *
 * Parent elements: `<direction>`, `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<sound>` element contains general playback parameters. They can stand alone within a part/measure, or be a
 * component element within a direction.
 *
 * Instrument changes, MIDI devices, MIDI instruments, and playback techniques are changed using the
 * `<instrument-change>`, `<midi-device>`, `<midi-instrument>`, and `<play>` elements. When there are multiple instances
 * of these elements, they should be grouped together by instrument using the id attribute values.
 *
 * The `<offset>` element is used to indicate that the sound takes place offset from the current score position. If the
 * `<sound>` element is a child of a `<direction>` element, the sound `<offset>` element overrides the direction
 * `<offset>` element if both elements are present. Note that the offset reflects the intended musical position for the
 * change in sound. It should not be used to compensate for latency issues in particular hardware configurations.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sound/}
 */
var Sound = /** @class */ (function () {
    function Sound(opts) {
        var _a;
        this.schema = Sound.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Sound.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Sound.schema.contents);
    }
    /** Gets @type {SoundAttributes['coda']}. */
    Sound.prototype.getCoda = function () {
        return this.attributes['coda'];
    };
    /** Sets @type {SoundAttributes['coda']}. */
    Sound.prototype.setCoda = function (coda) {
        this.attributes['coda'] = coda;
        return this;
    };
    /** Gets @type {SoundAttributes['dacapo']}. */
    Sound.prototype.getDacapo = function () {
        return this.attributes['dacapo'];
    };
    /** Sets @type {SoundAttributes['dacapo']}. */
    Sound.prototype.setDacapo = function (dacapo) {
        this.attributes['dacapo'] = dacapo;
        return this;
    };
    /** Gets @type {SoundAttributes['dalsegno']}. */
    Sound.prototype.getDalsegno = function () {
        return this.attributes['dalsegno'];
    };
    /** Sets @type {SoundAttributes['dalsegno']}. */
    Sound.prototype.setDalsegno = function (dalsegno) {
        this.attributes['dalsegno'] = dalsegno;
        return this;
    };
    /** Gets @type {SoundAttributes['damper-pedal']}. */
    Sound.prototype.getDamperPedal = function () {
        return this.attributes['damper-pedal'];
    };
    /** Sets @type {SoundAttributes['damper-pedal']}. */
    Sound.prototype.setDamperPedal = function (damperPedal) {
        this.attributes['damper-pedal'] = damperPedal;
        return this;
    };
    /** Gets @type {SoundAttributes['divisions']}. */
    Sound.prototype.getDivisions = function () {
        return this.attributes['divisions'];
    };
    /** Sets @type {SoundAttributes['divisions']}. */
    Sound.prototype.setDivisions = function (divisions) {
        this.attributes['divisions'] = divisions;
        return this;
    };
    /** Gets @type {SoundAttributes['dynamics']}. */
    Sound.prototype.getDynamics = function () {
        return this.attributes['dynamics'];
    };
    /** Sets @type {SoundAttributes['dynamics']}. */
    Sound.prototype.setDynamics = function (dynamics) {
        this.attributes['dynamics'] = dynamics;
        return this;
    };
    /** Gets @type {SoundAttributes['elevation']}. */
    Sound.prototype.getElevation = function () {
        return this.attributes['elevation'];
    };
    /** Sets @type {SoundAttributes['elevation']}. */
    Sound.prototype.setElevation = function (elevation) {
        this.attributes['elevation'] = elevation;
        return this;
    };
    /** Gets @type {SoundAttributes['fine']}. */
    Sound.prototype.getFine = function () {
        return this.attributes['fine'];
    };
    /** Sets @type {SoundAttributes['fine']}. */
    Sound.prototype.setFine = function (fine) {
        this.attributes['fine'] = fine;
        return this;
    };
    /** Gets @type {SoundAttributes['forward-repeat']}. */
    Sound.prototype.getForwardRepeat = function () {
        return this.attributes['forward-repeat'];
    };
    /** Sets @type {SoundAttributes['forward-repeat']}. */
    Sound.prototype.setForwardRepeat = function (forwardRepeat) {
        this.attributes['forward-repeat'] = forwardRepeat;
        return this;
    };
    /** Gets @type {SoundAttributes['id']}. */
    Sound.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {SoundAttributes['id']}. */
    Sound.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {SoundAttributes['pan']}. */
    Sound.prototype.getPan = function () {
        return this.attributes['pan'];
    };
    /** Sets @type {SoundAttributes['pan']}. */
    Sound.prototype.setPan = function (pan) {
        this.attributes['pan'] = pan;
        return this;
    };
    /** Gets @type {SoundAttributes['pizzicato']}. */
    Sound.prototype.getPizzicato = function () {
        return this.attributes['pizzicato'];
    };
    /** Sets @type {SoundAttributes['pizzicato']}. */
    Sound.prototype.setPizzicato = function (pizzicato) {
        this.attributes['pizzicato'] = pizzicato;
        return this;
    };
    /** Gets @type {SoundAttributes['segno']}. */
    Sound.prototype.getSegno = function () {
        return this.attributes['segno'];
    };
    /** Sets @type {SoundAttributes['segno']}. */
    Sound.prototype.setSegno = function (segno) {
        this.attributes['segno'] = segno;
        return this;
    };
    /** Gets @type {SoundAttributes['soft-pedal']}. */
    Sound.prototype.getSoftPedal = function () {
        return this.attributes['soft-pedal'];
    };
    /** Sets @type {SoundAttributes['soft-pedal']}. */
    Sound.prototype.setSoftPedal = function (softPedal) {
        this.attributes['soft-pedal'] = softPedal;
        return this;
    };
    /** Gets @type {SoundAttributes['sostenuto-pedal']}. */
    Sound.prototype.getSostenutoPedal = function () {
        return this.attributes['sostenuto-pedal'];
    };
    /** Sets @type {SoundAttributes['sostenuto-pedal']}. */
    Sound.prototype.setSostenutoPedal = function (sostenutoPedal) {
        this.attributes['sostenuto-pedal'] = sostenutoPedal;
        return this;
    };
    /** Gets @type {SoundAttributes['tempo']}. */
    Sound.prototype.getTempo = function () {
        return this.attributes['tempo'];
    };
    /** Sets @type {SoundAttributes['tempo']}. */
    Sound.prototype.setTempo = function (tempo) {
        this.attributes['tempo'] = tempo;
        return this;
    };
    /** Gets @type {SoundAttributes['time-only']}. */
    Sound.prototype.getTimeOnly = function () {
        return this.attributes['time-only'];
    };
    /** Sets @type {SoundAttributes['time-only']}. */
    Sound.prototype.setTimeOnly = function (timeOnly) {
        this.attributes['time-only'] = timeOnly;
        return this;
    };
    /** Gets @type {SoundAttributes['tocoda']}. */
    Sound.prototype.getTocoda = function () {
        return this.attributes['tocoda'];
    };
    /** Sets @type {SoundAttributes['tocoda']}. */
    Sound.prototype.setTocoda = function (tocoda) {
        this.attributes['tocoda'] = tocoda;
        return this;
    };
    /** Gets @type {Array<[InstrumentChange | null, MidiDevice | null, MidiInstrument | null, Play | null]>}. */
    Sound.prototype.getPlaybacks = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<[InstrumentChange | null, MidiDevice | null, MidiInstrument | null, Play | null]>}. */
    Sound.prototype.setPlaybacks = function (playbacks) {
        this.contents[0] = playbacks;
        return this;
    };
    /** Gets @type {Swing | null}. */
    Sound.prototype.getSwing = function () {
        return this.contents[1];
    };
    /** Sets @type {Swing | null}. */
    Sound.prototype.setSwing = function (swing) {
        this.contents[1] = swing;
        return this;
    };
    /** Gets @type {Offset | null}. */
    Sound.prototype.getOffset = function () {
        return this.contents[2];
    };
    /** Sets @type {Offset | null}. */
    Sound.prototype.setOffset = function (offset) {
        this.contents[2] = offset;
        return this;
    };
    Sound.schema = {
        name: 'sound',
        attributes: {
            coda: { type: 'optional', value: { type: 'string' } },
            dacapo: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            dalsegno: { type: 'optional', value: { type: 'string' } },
            'damper-pedal': { type: 'optional', value: { type: 'choices', choices: ['no', 'yes', 0, 1] } },
            divisions: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            dynamics: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
            elevation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            fine: { type: 'optional', value: { type: 'string' } },
            'forward-repeat': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            pan: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
            pizzicato: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            segno: { type: 'optional', value: { type: 'string' } },
            'soft-pedal': { type: 'optional', value: { type: 'choices', choices: ['no', 'yes', 0, 1] } },
            'sostenuto-pedal': { type: 'optional', value: { type: 'choices', choices: ['no', 'yes', 0, 1] } },
            tempo: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
            'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
            tocoda: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            {
                type: 'label',
                label: 'playbacks',
                value: {
                    type: 'zeroOrMore',
                    value: [
                        { type: 'optional', value: InstrumentChange },
                        { type: 'optional', value: MidiDevice },
                        { type: 'optional', value: MidiInstrument },
                        { type: 'optional', value: Play },
                    ],
                },
            },
            { type: 'optional', value: Swing },
            { type: 'optional', value: Offset },
        ],
    };
    return Sound;
}());
exports.Sound = Sound;
/**
 * The `<sync>` element
 *
 * Parent element: `<listening>`
 *
 * The `<sync>` element specifies the style that a score following application should use the synchronize an
 * accompaniment with a performer. If this element is not included in a score, default synchronization depends on the
 * application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sync/}
 */
var Sync = /** @class */ (function () {
    function Sync(opts) {
        var _a;
        this.schema = Sync.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Sync.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Sync.schema.contents);
    }
    /** Gets @type {SyncAttributes['type']}. */
    Sync.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {SyncAttributes['type']}. */
    Sync.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {SyncAttributes['latency']}. */
    Sync.prototype.getLatency = function () {
        return this.attributes['latency'];
    };
    /** Sets @type {SyncAttributes['latency']}. */
    Sync.prototype.setLatency = function (latency) {
        this.attributes['latency'] = latency;
        return this;
    };
    /** Gets @type {SyncAttributes['player']}. */
    Sync.prototype.getPlayer = function () {
        return this.attributes['player'];
    };
    /** Sets @type {SyncAttributes['player']}. */
    Sync.prototype.setPlayer = function (player) {
        this.attributes['player'] = player;
        return this;
    };
    /** Gets @type {SyncAttributes['time-only']}. */
    Sync.prototype.getTimeOnly = function () {
        return this.attributes['time-only'];
    };
    /** Sets @type {SyncAttributes['time-only']}. */
    Sync.prototype.setTimeOnly = function (timeOnly) {
        this.attributes['time-only'] = timeOnly;
        return this;
    };
    Sync.schema = {
        name: 'sync',
        attributes: {
            type: {
                type: 'required',
                value: { type: 'choices', choices: ['none', 'tempo', 'mostly-tempo', 'mostly-event', 'event', 'always-event'] },
            },
            latency: { type: 'optional', value: { type: 'int', min: 0, max: Infinity } },
            player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
        },
        contents: [],
    };
    return Sync;
}());
exports.Sync = Sync;
/**
 * The `<other-listening>` element
 *
 * Parent element: `<listening>`
 *
 * The `<other-listening>` element represents other types of listening control and interaction that change the state of
 * the listening application from the specified point in the performance onward.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-listening/}
 */
var OtherListening = /** @class */ (function () {
    function OtherListening(opts) {
        var _a;
        this.schema = OtherListening.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OtherListening.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OtherListening.schema.contents);
    }
    /** Gets @type {OtherListeningAttributes['type']}. */
    OtherListening.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {OtherListeningAttributes['type']}. */
    OtherListening.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {OtherListeningAttributes['player']}. */
    OtherListening.prototype.getPlayer = function () {
        return this.attributes['player'];
    };
    /** Sets @type {OtherListeningAttributes['player']}. */
    OtherListening.prototype.setPlayer = function (player) {
        this.attributes['player'] = player;
        return this;
    };
    /** Gets @type {OtherListeningAttributes['time-only']}. */
    OtherListening.prototype.getTimeOnly = function () {
        return this.attributes['time-only'];
    };
    /** Sets @type {OtherListeningAttributes['time-only']}. */
    OtherListening.prototype.setTimeOnly = function (timeOnly) {
        this.attributes['time-only'] = timeOnly;
        return this;
    };
    /** Gets @type {string}. */
    OtherListening.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    OtherListening.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    OtherListening.schema = {
        name: 'other-listening',
        attributes: {
            type: { type: 'required', value: { type: 'string' } },
            player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return OtherListening;
}());
exports.OtherListening = OtherListening;
/**
 * The `<listening>` element
 *
 * Parent elements: `<direction>`, `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<listen>` and `<listening>` elements, new in Version 4.0, specify different ways that a score following or
 * machine listening application can interact with a performer. The `<listening>` element handles interactions that
 * change the state of the listening application from the specified point in the performance onward. If multiple child
 * elements of the same type are present, they should have distinct player and/or time-only attributes.
 *
 * The `<offset>` element is used to indicate that the listening change takes place offset from the current score
 * position. If the `<listening>` element is a child of a `<direction>` element, the listening `<offset>` element
 * overrides the direction `<offset>` element if both elements are present.
 *
 * Note that the `<offset>` reflects the intended musical position for the change in state. It should not be used to
 * compensate for latency issues in particular hardware configurations.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/listening/}
 */
var Listening = /** @class */ (function () {
    function Listening(opts) {
        var _a;
        this.schema = Listening.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Listening.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Listening.schema.contents);
    }
    /** Gets @type {Array<Sync | OtherListening>}. */
    Listening.prototype.getListening = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Sync | OtherListening>}. */
    Listening.prototype.setListening = function (listening) {
        this.contents[0] = listening;
        return this;
    };
    /** Gets @type {Offset | null}. */
    Listening.prototype.getOffset = function () {
        return this.contents[1];
    };
    /** Sets @type {Offset | null}. */
    Listening.prototype.setOffset = function (offset) {
        this.contents[1] = offset;
        return this;
    };
    Listening.schema = {
        name: 'listening',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'listening',
                value: { type: 'oneOrMore', value: { type: 'choices', choices: [Sync, OtherListening] } },
            },
            { type: 'optional', value: Offset },
        ],
    };
    return Listening;
}());
exports.Listening = Listening;
/**
 * The `<direction>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * A direction is a musical indication that is not necessarily attached to a specific note. Two or more may be combined
 * to indicate words followed by the start of a dashed line, the end of a wedge followed by dynamics, etc. For
 * applications where a specific direction is indeed attached to a specific note, the `<direction>` element can be
 * associated with the first `<note>` element that follows it in score order that is not in a different voice.
 *
 * By default, a series of `<direction-type>` elements and a series of child elements of a `<direction-type>` within a
 * single `<direction>` element follow one another in sequence visually. For a series of `<direction-type>` children,
 * non-positional formatting attributes are carried over from the previous element by default.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/direction/}
 */
var Direction = /** @class */ (function () {
    function Direction(opts) {
        var _a;
        this.schema = Direction.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Direction.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Direction.schema.contents);
    }
    /** Gets @type {DirectionAttributes['directive']}. */
    Direction.prototype.getDirective = function () {
        return this.attributes['directive'];
    };
    /** Sets @type {DirectionAttributes['directive']}. */
    Direction.prototype.setDirective = function (directive) {
        this.attributes['directive'] = directive;
        return this;
    };
    /** Gets @type {DirectionAttributes['id']}. */
    Direction.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {DirectionAttributes['id']}. */
    Direction.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {DirectionAttributes['placement']}. */
    Direction.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {DirectionAttributes['placement']}. */
    Direction.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {DirectionAttributes['system']}. */
    Direction.prototype.getSystem = function () {
        return this.attributes['system'];
    };
    /** Sets @type {DirectionAttributes['system']}. */
    Direction.prototype.setSystem = function (system) {
        this.attributes['system'] = system;
        return this;
    };
    /** Gets @type {Array<DirectionType>}. */
    Direction.prototype.getDirectionTypes = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<DirectionType>}. */
    Direction.prototype.setDirectionTypes = function (directionTypes) {
        this.contents[0] = directionTypes;
        return this;
    };
    /** Gets @type {Offset | null}. */
    Direction.prototype.getOffset = function () {
        return this.contents[1];
    };
    /** Sets @type {Offset | null}. */
    Direction.prototype.setOffset = function (offset) {
        this.contents[1] = offset;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    Direction.prototype.getFootnote = function () {
        return this.contents[2];
    };
    /** Sets @type {Footnote | null}. */
    Direction.prototype.setFootnote = function (footnote) {
        this.contents[2] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    Direction.prototype.getLevel = function () {
        return this.contents[3];
    };
    /** Sets @type {Level | null}. */
    Direction.prototype.setLevel = function (level) {
        this.contents[3] = level;
        return this;
    };
    /** Gets @type {Voice | null}. */
    Direction.prototype.getVoice = function () {
        return this.contents[4];
    };
    /** Sets @type {Voice | null}. */
    Direction.prototype.setVoice = function (voice) {
        this.contents[4] = voice;
        return this;
    };
    /** Gets @type {Staff | null}. */
    Direction.prototype.getStaff = function () {
        return this.contents[5];
    };
    /** Sets @type {Staff | null}. */
    Direction.prototype.setStaff = function (staff) {
        this.contents[5] = staff;
        return this;
    };
    /** Gets @type {Sound | null}. */
    Direction.prototype.getSound = function () {
        return this.contents[6];
    };
    /** Sets @type {Sound | null}. */
    Direction.prototype.setSound = function (sound) {
        this.contents[6] = sound;
        return this;
    };
    /** Gets @type {Listening | null}. */
    Direction.prototype.getListening = function () {
        return this.contents[7];
    };
    /** Sets @type {Listening | null}. */
    Direction.prototype.setListening = function (listening) {
        this.contents[7] = listening;
        return this;
    };
    Direction.schema = {
        name: 'direction',
        attributes: {
            directive: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            system: { type: 'optional', value: { type: 'choices', choices: ['none', 'only-top', 'also-top'] } },
        },
        contents: [
            { type: 'label', label: 'direction-types', value: { type: 'oneOrMore', value: DirectionType } },
            { type: 'optional', value: Offset },
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
            { type: 'optional', value: Voice },
            { type: 'optional', value: Staff },
            { type: 'optional', value: Sound },
            { type: 'optional', value: Listening },
        ],
    };
    return Direction;
}());
exports.Direction = Direction;
/**
 * The `<divisions>` element
 *
 * Parent element: `<attributes>`
 *
 * Musical notation duration is commonly represented as fractions. The `<divisions>` element indicates how many
 * divisions per quarter note are used to indicate a note's duration. For example, if duration = 1 and divisions = 2,
 * this is an eighth note duration. Duration and divisions are used directly for generating sound output, so they must
 * be chosen to take tuplets into account.
 *
 * Using a `<divisions>` element lets us use just one number to represent a duration for each note in the score, while
 * retaining the full power of a fractional representation. If maximum compatibility with Standard MIDI 1.0 files is
 * important, do not have the divisions value exceed 16383.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/divisions/}
 */
var Divisions = /** @class */ (function () {
    function Divisions(opts) {
        var _a;
        this.schema = Divisions.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Divisions.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Divisions.schema.contents);
    }
    /** Gets @type {number}. */
    Divisions.prototype.getPositiveDivisions = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Divisions.prototype.setPositiveDivisions = function (positiveDivisions) {
        this.contents[0] = positiveDivisions;
        return this;
    };
    Divisions.schema = {
        name: 'divisions',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'positive-divisions', value: { type: 'float', min: 1, max: Infinity } },
            },
        ],
    };
    return Divisions;
}());
exports.Divisions = Divisions;
/**
 * The `<cancel>` element
 *
 * Parent element: `<key>`
 *
 * The `<cancel>` element indicates that the old key signature should be cancelled before the new one appears. This will
 * always happen when changing to C major or A minor and need not be specified then. The `<cancel>` element value
 * matches the fifths value of the cancelled key signature (e.g., a cancel of -2 will provide an explicit cancellation
 * for changing from B flat major to F major).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/cancel/}
 */
var Cancel = /** @class */ (function () {
    function Cancel(opts) {
        var _a;
        this.schema = Cancel.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Cancel.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Cancel.schema.contents);
    }
    /** Gets @type {CancelAttributes['location']}. */
    Cancel.prototype.getLocation = function () {
        return this.attributes['location'];
    };
    /** Sets @type {CancelAttributes['location']}. */
    Cancel.prototype.setLocation = function (location) {
        this.attributes['location'] = location;
        return this;
    };
    /** Gets @type {number}. */
    Cancel.prototype.getFifths = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Cancel.prototype.setFifths = function (fifths) {
        this.contents[0] = fifths;
        return this;
    };
    Cancel.schema = {
        name: 'cancel',
        attributes: {
            location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right', 'beforeBarline'] } },
        },
        contents: [
            {
                type: 'label',
                label: 'fifths',
                value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return Cancel;
}());
exports.Cancel = Cancel;
/**
 * The `<fifths>` element
 *
 * Parent element: `<key>`
 *
 * The `<fifths>` element represents the number of flats or sharps in a traditional key signature. Negative numbers are
 * used for flats and positive numbers for sharps, reflecting the key's placement within the circle of fifths (hence the
 * element name).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fifths/}
 */
var Fifths = /** @class */ (function () {
    function Fifths(opts) {
        var _a;
        this.schema = Fifths.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Fifths.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Fifths.schema.contents);
    }
    /** Gets @type {number | null}. */
    Fifths.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number | null}. */
    Fifths.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Fifths.schema = {
        name: 'fifths',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'optional', value: { type: 'int', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return Fifths;
}());
exports.Fifths = Fifths;
/**
 * The `<mode>` element
 *
 * Parent element: `<key>`
 *
 * The `<mode>` element is used to specify major/minor and other mode distinctions. Valid mode values include major,
 * minor, dorian, phrygian, lydian, mixolydian, aeolian, ionian, locrian, and none.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/mode/}
 */
var Mode = /** @class */ (function () {
    function Mode(opts) {
        var _a;
        this.schema = Mode.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Mode.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Mode.schema.contents);
    }
    /** Gets @type {'none' | 'major' | 'minor' | 'dorian' | 'phrygian' | 'lydian' | 'mixolydian' | 'aeolian' | 'ionian' | 'locrian' | string}. */
    Mode.prototype.getMode = function () {
        return this.contents[0];
    };
    /** Sets @type {'none' | 'major' | 'minor' | 'dorian' | 'phrygian' | 'lydian' | 'mixolydian' | 'aeolian' | 'ionian' | 'locrian' | string}. */
    Mode.prototype.setMode = function (mode) {
        this.contents[0] = mode;
        return this;
    };
    Mode.schema = {
        name: 'mode',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'mode',
                    value: {
                        type: 'choices',
                        choices: [
                            'none',
                            'major',
                            'minor',
                            'dorian',
                            'phrygian',
                            'lydian',
                            'mixolydian',
                            'aeolian',
                            'ionian',
                            'locrian',
                            { type: 'string' },
                        ],
                    },
                },
            },
        ],
    };
    return Mode;
}());
exports.Mode = Mode;
/**
 * The `<key>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<key>` element represents a key signature. Both traditional and non-traditional key signatures are supported.
 * Key signatures appear at the start of each system unless the print-object attribute has been set to "no".
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/key/}
 */
var KeyStep = /** @class */ (function () {
    function KeyStep(opts) {
        var _a;
        this.schema = KeyStep.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, KeyStep.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(KeyStep.schema.contents);
    }
    /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    KeyStep.prototype.getStep = function () {
        return this.contents[0];
    };
    /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    KeyStep.prototype.setStep = function (step) {
        this.contents[0] = step;
        return this;
    };
    KeyStep.schema = {
        name: 'key-step',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'step',
                    value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
                },
            },
        ],
    };
    return KeyStep;
}());
exports.KeyStep = KeyStep;
/**
 * The `<key-alter>` element
 *
 * Parent element: `<key>`
 *
 * Non-traditional key signatures are represented using a list of altered tones. The `<key-alter>` element represents
 * the alteration for a given pitch step, represented with semitones in the same manner as the `<alter>` element. The
 * different element names indicate the different meaning of altering notes in a scale versus altering a sounding pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/key-alter/}
 */
var KeyAlter = /** @class */ (function () {
    function KeyAlter(opts) {
        var _a;
        this.schema = KeyAlter.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, KeyAlter.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(KeyAlter.schema.contents);
    }
    /** Gets @type {number}. */
    KeyAlter.prototype.getSemitones = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    KeyAlter.prototype.setSemitones = function (semitones) {
        this.contents[0] = semitones;
        return this;
    };
    KeyAlter.schema = {
        name: 'key-alter',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return KeyAlter;
}());
exports.KeyAlter = KeyAlter;
/**
 * The `<key-accidental>` element
 *
 * Parent element: `<key>`
 *
 * Non-traditional key signatures are represented using a list of altered tones. The `<key-accidental>` element
 * indicates the accidental to be displayed in the key signature, represented in the same manner as the `<accidental>`
 * element. It is used for disambiguating microtonal accidentals. The different element names indicate the different
 * meaning of altering notes in a scale versus altering a sounding pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/key-accidental/}
 */
var KeyAccidental = /** @class */ (function () {
    function KeyAccidental(opts) {
        var _a;
        this.schema = KeyAccidental.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, KeyAccidental.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(KeyAccidental.schema.contents);
    }
    /** Gets @type {KeyAccidentalAttributes['smufl']}. */
    KeyAccidental.prototype.getSmufl = function () {
        return this.attributes['smufl'];
    };
    /** Sets @type {KeyAccidentalAttributes['smufl']}. */
    KeyAccidental.prototype.setSmufl = function (smufl) {
        this.attributes['smufl'] = smufl;
        return this;
    };
    /** Gets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
    KeyAccidental.prototype.getAccidentalValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
    KeyAccidental.prototype.setAccidentalValue = function (accidentalValue) {
        this.contents[0] = accidentalValue;
        return this;
    };
    KeyAccidental.schema = {
        name: 'key-accidental',
        attributes: {
            smufl: {
                type: 'optional',
                value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
            },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'accidental-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'other',
                            'sharp',
                            'natural',
                            'flat',
                            'double-sharp',
                            'sharp-sharp',
                            'flat-flat',
                            'natural-sharp',
                            'natural-flat',
                            'quarter-flat',
                            'quarter-sharp',
                            'three-quarters-flat',
                            'three-quarters-sharp',
                            'sharp-down',
                            'sharp-up',
                            'natural-down',
                            'natural-up',
                            'flat-down',
                            'flat-up',
                            'double-sharp-down',
                            'double-sharp-up',
                            'flat-flat-down',
                            'flat-flat-up',
                            'arrow-down',
                            'arrow-up',
                            'triple-sharp',
                            'triple-flat',
                            'slash-quarter-sharp',
                            'slash-sharp',
                            'slash-flat',
                            'double-slash-flat',
                            'sharp-1',
                            'sharp-2',
                            'sharp-3',
                            'sharp-5',
                            'flat-1',
                            'flat-2',
                            'flat-3',
                            'flat-4',
                            'sori',
                            'koron',
                        ],
                    },
                },
            },
        ],
    };
    return KeyAccidental;
}());
exports.KeyAccidental = KeyAccidental;
/**
 * The `<key-octave>` element
 *
 * Parent element: `<key>`
 *
 * The `<key-octave>` element specifies in which octave an element of a key signature appears. The content specifies the
 * octave value using the same values as the `<display-octave>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/key-octave/}
 */
var KeyOctave = /** @class */ (function () {
    function KeyOctave(opts) {
        var _a;
        this.schema = KeyOctave.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, KeyOctave.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(KeyOctave.schema.contents);
    }
    /** Gets @type {KeyOctaveAttributes['number']}. */
    KeyOctave.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {KeyOctaveAttributes['number']}. */
    KeyOctave.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {KeyOctaveAttributes['cancel']}. */
    KeyOctave.prototype.getCancel = function () {
        return this.attributes['cancel'];
    };
    /** Sets @type {KeyOctaveAttributes['cancel']}. */
    KeyOctave.prototype.setCancel = function (cancel) {
        this.attributes['cancel'] = cancel;
        return this;
    };
    /** Gets @type {number}. */
    KeyOctave.prototype.getOctave = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    KeyOctave.prototype.setOctave = function (octave) {
        this.contents[0] = octave;
        return this;
    };
    KeyOctave.schema = {
        name: 'key-octave',
        attributes: {
            number: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
            cancel: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
        },
        contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
    };
    return KeyOctave;
}());
exports.KeyOctave = KeyOctave;
/**
 * The `<key>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<key>` element represents a key signature. Both traditional and non-traditional key signatures are supported.
 * Key signatures appear at the start of each system unless the print-object attribute has been set to "no".
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/key/}
 */
var Key = /** @class */ (function () {
    function Key(opts) {
        var _a;
        this.schema = Key.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Key.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Key.schema.contents);
    }
    /** Gets @type {KeyAttributes['color']}. */
    Key.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {KeyAttributes['color']}. */
    Key.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {KeyAttributes['default-x']}. */
    Key.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {KeyAttributes['default-x']}. */
    Key.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {KeyAttributes['default-y']}. */
    Key.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {KeyAttributes['default-y']}. */
    Key.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {KeyAttributes['font-family']}. */
    Key.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {KeyAttributes['font-family']}. */
    Key.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {KeyAttributes['font-size']}. */
    Key.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {KeyAttributes['font-size']}. */
    Key.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {KeyAttributes['font-style']}. */
    Key.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {KeyAttributes['font-style']}. */
    Key.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {KeyAttributes['font-weight']}. */
    Key.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {KeyAttributes['font-weight']}. */
    Key.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {KeyAttributes['id']}. */
    Key.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {KeyAttributes['id']}. */
    Key.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {KeyAttributes['number']}. */
    Key.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {KeyAttributes['number']}. */
    Key.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {KeyAttributes['print-object']}. */
    Key.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {KeyAttributes['print-object']}. */
    Key.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {KeyAttributes['relative-x']}. */
    Key.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {KeyAttributes['relative-x']}. */
    Key.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {KeyAttributes['relative-y']}. */
    Key.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {KeyAttributes['relative-y']}. */
    Key.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {TranditionalKey | AlternateKey}. */
    Key.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {TranditionalKey | AlternateKey}. */
    Key.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    /** Gets @type {Array<KeyOctave>}. */
    Key.prototype.getKeyOctaves = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<KeyOctave>}. */
    Key.prototype.setKeyOctaves = function (keyOctaves) {
        this.contents[1] = keyOctaves;
        return this;
    };
    Key.schema = {
        name: 'key',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [
            {
                type: 'label',
                label: 'value',
                value: {
                    type: 'choices',
                    choices: [
                        {
                            type: 'label',
                            label: 'tranditional-key',
                            value: [
                                { type: 'optional', value: Cancel },
                                { type: 'required', value: Fifths },
                                { type: 'optional', value: Mode },
                            ],
                        },
                        {
                            type: 'label',
                            label: 'alternate-key',
                            value: {
                                type: 'zeroOrMore',
                                value: [
                                    { type: 'required', value: KeyStep },
                                    { type: 'required', value: KeyAlter },
                                    { type: 'optional', value: KeyAccidental },
                                ],
                            },
                        },
                    ],
                },
            },
            { type: 'label', label: 'key-octaves', value: { type: 'zeroOrMore', value: KeyOctave } },
        ],
    };
    return Key;
}());
exports.Key = Key;
/**
 * The `<beats>` element
 *
 * Parent elements: `<interchangeable>`, `<time>`
 *
 * The `<beats>` element indicates the number of beats, as found in the numerator of a time signature.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beats/}
 */
var Beats = /** @class */ (function () {
    function Beats(opts) {
        var _a;
        this.schema = Beats.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Beats.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Beats.schema.contents);
    }
    /** Gets @type {string}. */
    Beats.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Beats.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Beats.schema = {
        name: 'beats',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Beats;
}());
exports.Beats = Beats;
/**
 * The `<beat-type>` element
 *
 * Parent elements: `<interchangeable>`, `<time>`
 *
 * The `<beat-type>` element indicates the beat unit, as found in the denominator of a time signature.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beat-type/}
 */
var BeatType = /** @class */ (function () {
    function BeatType(opts) {
        var _a;
        this.schema = BeatType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BeatType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BeatType.schema.contents);
    }
    /** Gets @type {string}. */
    BeatType.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    BeatType.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    BeatType.schema = {
        name: 'beat-type',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return BeatType;
}());
exports.BeatType = BeatType;
/**
 * The `<time-relation>` element
 *
 * Parent element: `<interchangeable>`
 *
 * The `<time-relation>` element indicates the symbol used to represent the interchangeable aspect of dual time
 * signatures, as specified in the time-relation type.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/time-relation/}
 */
var TimeRelation = /** @class */ (function () {
    function TimeRelation(opts) {
        var _a;
        this.schema = TimeRelation.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, TimeRelation.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(TimeRelation.schema.contents);
    }
    /** Gets @type {'space' | 'bracket' | 'equals' | 'hyphen' | 'parentheses' | 'slash'}. */
    TimeRelation.prototype.getTimeRelation = function () {
        return this.contents[0];
    };
    /** Sets @type {'space' | 'bracket' | 'equals' | 'hyphen' | 'parentheses' | 'slash'}. */
    TimeRelation.prototype.setTimeRelation = function (timeRelation) {
        this.contents[0] = timeRelation;
        return this;
    };
    TimeRelation.schema = {
        name: 'time-relation',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'time-relation',
                    value: { type: 'choices', choices: ['space', 'bracket', 'equals', 'hyphen', 'parentheses', 'slash'] },
                },
            },
        ],
    };
    return TimeRelation;
}());
exports.TimeRelation = TimeRelation;
/**
 * The `<interchangeable>` element
 *
 * Parent element: `<time>`
 *
 * The `<interchangeable>` element is used to represent the second in a pair of interchangeable dual time signatures,
 * such as the 6/8 in 3/4 (6/8).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/interchangeable/}
 */
var Interchangeable = /** @class */ (function () {
    function Interchangeable(opts) {
        var _a;
        this.schema = Interchangeable.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Interchangeable.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Interchangeable.schema.contents);
    }
    /** Gets @type {InterchangeableAttributes['separator']}. */
    Interchangeable.prototype.getSeparator = function () {
        return this.attributes['separator'];
    };
    /** Sets @type {InterchangeableAttributes['separator']}. */
    Interchangeable.prototype.setSeparator = function (separator) {
        this.attributes['separator'] = separator;
        return this;
    };
    /** Gets @type {InterchangeableAttributes['symbol']}. */
    Interchangeable.prototype.getSymbol = function () {
        return this.attributes['symbol'];
    };
    /** Sets @type {InterchangeableAttributes['symbol']}. */
    Interchangeable.prototype.setSymbol = function (symbol) {
        this.attributes['symbol'] = symbol;
        return this;
    };
    /** Gets @type {TimeRelation | null}. */
    Interchangeable.prototype.getTimeRelation = function () {
        return this.contents[0];
    };
    /** Sets @type {TimeRelation | null}. */
    Interchangeable.prototype.setTimeRelation = function (timeRelation) {
        this.contents[0] = timeRelation;
        return this;
    };
    /** Gets @type {Array<[Beats, BeatType]>}. */
    Interchangeable.prototype.getBeats = function () {
        return this.contents[1];
    };
    /** Sets @type {Array<[Beats, BeatType]>}. */
    Interchangeable.prototype.setBeats = function (beats) {
        this.contents[1] = beats;
        return this;
    };
    Interchangeable.schema = {
        name: 'interchangeable',
        attributes: {
            separator: {
                type: 'optional',
                value: { type: 'choices', choices: ['none', 'adjacent', 'diagonal', 'horizontal', 'vertical'] },
            },
            symbol: {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', 'common', 'cut', 'dotted-note', 'note', 'single-number'] },
            },
        },
        contents: [
            { type: 'optional', value: TimeRelation },
            {
                type: 'label',
                label: 'beats',
                value: {
                    type: 'oneOrMore',
                    value: [
                        { type: 'required', value: Beats },
                        { type: 'required', value: BeatType },
                    ],
                },
            },
        ],
    };
    return Interchangeable;
}());
exports.Interchangeable = Interchangeable;
/**
 * The `<senza-misura>` element
 *
 * Parent element: `<time>`
 *
 * A `<senza-misura>` element explicitly indicates that no time signature is present. The optional element content
 * indicates the symbol to be used, if any, such as an X. The `<time>` element's symbol attribute is not used when a
 * `<senza-misura>` element is present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/senza-misura/}
 */
var SenzaMisura = /** @class */ (function () {
    function SenzaMisura(opts) {
        var _a;
        this.schema = SenzaMisura.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SenzaMisura.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SenzaMisura.schema.contents);
    }
    /** Gets @type {string}. */
    SenzaMisura.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    SenzaMisura.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    SenzaMisura.schema = {
        name: 'senza-misura',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return SenzaMisura;
}());
exports.SenzaMisura = SenzaMisura;
/**
 * The `<time>` element
 *
 * Parent element: `<attributes>`
 *
 * Time signatures are represented by the `<beats>` element for the numerator and the `<beat-type>` element for the
 * denominator. Multiple pairs of `<beat>` and `<beat-type>` elements are used for composite time signatures with
 * multiple denominators, such as 2/4 + 3/8. A composite such as 3+2/8 requires only one `<beat>`/`<beat-type>` pair.
 *
 * The print-object attribute allows a time signature to be specified but not printed, as is the case for excerpts from
 * the middle of a score. The value is "yes" if not present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/time/}
 */
var Time = /** @class */ (function () {
    function Time(opts) {
        var _a;
        this.schema = Time.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Time.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Time.schema.contents);
    }
    /** Gets @type {TimeAttributes['color']}. */
    Time.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {TimeAttributes['color']}. */
    Time.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {TimeAttributes['default-x']}. */
    Time.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {TimeAttributes['default-x']}. */
    Time.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {TimeAttributes['default-y']}. */
    Time.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {TimeAttributes['default-y']}. */
    Time.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {TimeAttributes['font-family']}. */
    Time.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {TimeAttributes['font-family']}. */
    Time.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {TimeAttributes['font-size']}. */
    Time.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {TimeAttributes['font-size']}. */
    Time.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {TimeAttributes['font-style']}. */
    Time.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {TimeAttributes['font-style']}. */
    Time.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {TimeAttributes['font-weight']}. */
    Time.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {TimeAttributes['font-weight']}. */
    Time.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {TimeAttributes['halign']}. */
    Time.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {TimeAttributes['halign']}. */
    Time.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {TimeAttributes['id']}. */
    Time.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {TimeAttributes['id']}. */
    Time.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {TimeAttributes['number']}. */
    Time.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {TimeAttributes['number']}. */
    Time.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {TimeAttributes['print-object']}. */
    Time.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {TimeAttributes['print-object']}. */
    Time.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {TimeAttributes['relative-x']}. */
    Time.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {TimeAttributes['relative-x']}. */
    Time.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {TimeAttributes['relative-y']}. */
    Time.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {TimeAttributes['relative-y']}. */
    Time.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {TimeAttributes['separator']}. */
    Time.prototype.getSeparator = function () {
        return this.attributes['separator'];
    };
    /** Sets @type {TimeAttributes['separator']}. */
    Time.prototype.setSeparator = function (separator) {
        this.attributes['separator'] = separator;
        return this;
    };
    /** Gets @type {TimeAttributes['symbol']}. */
    Time.prototype.getSymbol = function () {
        return this.attributes['symbol'];
    };
    /** Sets @type {TimeAttributes['symbol']}. */
    Time.prototype.setSymbol = function (symbol) {
        this.attributes['symbol'] = symbol;
        return this;
    };
    /** Gets @type {TimeAttributes['valign']}. */
    Time.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {TimeAttributes['valign']}. */
    Time.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {TimeSignature | SenzaMisura}. */
    Time.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {TimeSignature | SenzaMisura}. */
    Time.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Time.schema = {
        name: 'time',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'relative-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            separator: {
                type: 'optional',
                value: { type: 'choices', choices: ['none', 'adjacent', 'diagonal', 'horizontal', 'vertical'] },
            },
            symbol: {
                type: 'optional',
                value: { type: 'choices', choices: ['normal', 'common', 'cut', 'dotted-note', 'note', 'single-number'] },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [
            {
                type: 'label',
                label: 'value',
                value: {
                    type: 'choices',
                    choices: [
                        {
                            type: 'label',
                            label: 'time-signature',
                            value: [
                                {
                                    type: 'oneOrMore',
                                    value: [
                                        { type: 'required', value: Beats },
                                        { type: 'required', value: BeatType },
                                    ],
                                },
                                { type: 'optional', value: Interchangeable },
                            ],
                        },
                        SenzaMisura,
                    ],
                },
            },
        ],
    };
    return Time;
}());
exports.Time = Time;
/**
 * The `<staves>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<staves>` element is used if there is more than one staff represented in the given part (e.g., 2 staves for
 * typical piano parts). If absent, a value of 1 is assumed. Staves are ordered from top to bottom in a part in
 * numerical order, with staff 1 above staff 2.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staves/}
 */
var Staves = /** @class */ (function () {
    function Staves(opts) {
        var _a;
        this.schema = Staves.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Staves.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Staves.schema.contents);
    }
    /** Gets @type {number}. */
    Staves.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Staves.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Staves.schema = {
        name: 'staves',
        attributes: {},
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
        ],
    };
    return Staves;
}());
exports.Staves = Staves;
/**
 * The `<part-symbol>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<part-symbol>` element indicates how a symbol for a multi-staff part is indicated in the score; brace is the
 * default value.
 *
 * The top-staff and bottom-staff attributes are used when the brace does not extend across the entire part. For
 * example, in a 3-staff organ part, the top-staff will typically be 1 for the right hand, while the bottom-staff will
 * typically be 2 for the left hand. Staff 3 for the pedals is usually outside the brace. By default, the presence of a
 * `<part-symbol>` element that does not extend across the entire part also indicates a corresponding change in the
 * common barlines within a part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-symbol/}
 */
var PartSymbol = /** @class */ (function () {
    function PartSymbol(opts) {
        var _a;
        this.schema = PartSymbol.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartSymbol.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartSymbol.schema.contents);
    }
    /** Gets @type {PartSymbolAttributes['bottom-staff']}. */
    PartSymbol.prototype.getBottomStaff = function () {
        return this.attributes['bottom-staff'];
    };
    /** Sets @type {PartSymbolAttributes['bottom-staff']}. */
    PartSymbol.prototype.setBottomStaff = function (bottomStaff) {
        this.attributes['bottom-staff'] = bottomStaff;
        return this;
    };
    /** Gets @type {PartSymbolAttributes['color']}. */
    PartSymbol.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {PartSymbolAttributes['color']}. */
    PartSymbol.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {PartSymbolAttributes['default-x']}. */
    PartSymbol.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {PartSymbolAttributes['default-x']}. */
    PartSymbol.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {PartSymbolAttributes['default-y']}. */
    PartSymbol.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {PartSymbolAttributes['default-y']}. */
    PartSymbol.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {PartSymbolAttributes['font-family']}. */
    PartSymbol.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PartSymbolAttributes['font-family']}. */
    PartSymbol.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PartSymbolAttributes['font-size']}. */
    PartSymbol.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PartSymbolAttributes['font-size']}. */
    PartSymbol.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PartSymbolAttributes['font-style']}. */
    PartSymbol.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PartSymbolAttributes['font-style']}. */
    PartSymbol.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PartSymbolAttributes['font-weight']}. */
    PartSymbol.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PartSymbolAttributes['font-weight']}. */
    PartSymbol.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {PartSymbolAttributes['relative-x']}. */
    PartSymbol.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {PartSymbolAttributes['relative-x']}. */
    PartSymbol.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {PartSymbolAttributes['relative-y']}. */
    PartSymbol.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {PartSymbolAttributes['relative-y']}. */
    PartSymbol.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {PartSymbolAttributes['top-staff']}. */
    PartSymbol.prototype.getTopStaff = function () {
        return this.attributes['top-staff'];
    };
    /** Sets @type {PartSymbolAttributes['top-staff']}. */
    PartSymbol.prototype.setTopStaff = function (topStaff) {
        this.attributes['top-staff'] = topStaff;
        return this;
    };
    /** Gets @type {'none' | 'brace' | 'bracket' | 'line' | 'square'}. */
    PartSymbol.prototype.getGroupSymbolValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'none' | 'brace' | 'bracket' | 'line' | 'square'}. */
    PartSymbol.prototype.setGroupSymbolValue = function (groupSymbolValue) {
        this.contents[0] = groupSymbolValue;
        return this;
    };
    PartSymbol.schema = {
        name: 'part-symbol',
        attributes: {
            'bottom-staff': { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'top-staff': { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'group-symbol-value',
                    value: { type: 'choices', choices: ['none', 'brace', 'bracket', 'line', 'square'] },
                },
            },
        ],
    };
    return PartSymbol;
}());
exports.PartSymbol = PartSymbol;
/**
 * The `<instruments>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<instruments>` element is only used if more than one instrument is represented in the part (e.g., oboe I and II
 * where they play together most of the time). If absent, a value of 1 is assumed.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instruments/}
 */
var Instruments = /** @class */ (function () {
    function Instruments(opts) {
        var _a;
        this.schema = Instruments.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Instruments.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Instruments.schema.contents);
    }
    /** Gets @type {number}. */
    Instruments.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Instruments.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Instruments.schema = {
        name: 'instruments',
        attributes: {},
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
        ],
    };
    return Instruments;
}());
exports.Instruments = Instruments;
/**
 * The `<sign>` element
 *
 * Parent elements: `<clef>`, `<part-clef>`
 *
 * The `<sign>` element represents the clef symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sign/}
 */
var Sign = /** @class */ (function () {
    function Sign(opts) {
        var _a;
        this.schema = Sign.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Sign.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Sign.schema.contents);
    }
    /** Gets @type {'G' | 'F' | 'C' | 'percussion' | 'TAB' | 'jianpu' | 'none'}. */
    Sign.prototype.getClefSign = function () {
        return this.contents[0];
    };
    /** Sets @type {'G' | 'F' | 'C' | 'percussion' | 'TAB' | 'jianpu' | 'none'}. */
    Sign.prototype.setClefSign = function (clefSign) {
        this.contents[0] = clefSign;
        return this;
    };
    Sign.schema = {
        name: 'sign',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'clef-sign',
                    value: { type: 'choices', choices: ['G', 'F', 'C', 'percussion', 'TAB', 'jianpu', 'none'] },
                },
            },
        ],
    };
    return Sign;
}());
exports.Sign = Sign;
/**
 * The `<line>` element
 *
 * Parent elements: `<clef>`, `<part-clef>`
 *
 * Line numbers are counted from the bottom of the staff. They are only needed with the G, F, and C signs in order to
 * position a pitch correctly on the staff. Standard values are 2 for the G sign (treble clef), 4 for the F sign (bass
 * clef), and 3 for the C sign (alto clef). Line values can be used to specify positions outside the staff, such as a
 * C clef positioned in the middle of a grand staff.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/line/}
 */
var Line = /** @class */ (function () {
    function Line(opts) {
        var _a;
        this.schema = Line.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Line.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Line.schema.contents);
    }
    /** Gets @type {number}. */
    Line.prototype.getStaffLinePosition = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Line.prototype.setStaffLinePosition = function (staffLinePosition) {
        this.contents[0] = staffLinePosition;
        return this;
    };
    Line.schema = {
        name: 'line',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'staff-line-position', value: { type: 'int', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return Line;
}());
exports.Line = Line;
/**
 * The `<clef-octave-change>` element
 *
 * Parent elements: `<clef>`, `<part-clef>`
 *
 * The `<clef-octave-change>` element is used for transposing clefs. A treble clef for tenors would have a value of -1.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/clef-octave-change/}
 */
var ClefOctaveChange = /** @class */ (function () {
    function ClefOctaveChange(opts) {
        var _a;
        this.schema = ClefOctaveChange.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ClefOctaveChange.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ClefOctaveChange.schema.contents);
    }
    /** Gets @type {number}. */
    ClefOctaveChange.prototype.getClefOctaveChange = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    ClefOctaveChange.prototype.setClefOctaveChange = function (clefOctaveChange) {
        this.contents[0] = clefOctaveChange;
        return this;
    };
    ClefOctaveChange.schema = {
        name: 'clef-octave-change',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'clef-octave-change',
                value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return ClefOctaveChange;
}());
exports.ClefOctaveChange = ClefOctaveChange;
/**
 * The `<clef>` element
 *
 * Parent element: `<attributes>`
 *
 * Clefs are represented by a combination of `<sign>`, `<line>`, and `<clef-octave-change>` elements.
 *
 * Clefs appear at the start of each system unless the print-object attribute has been set to "no" or the additional
 * attribute has been set to "yes".
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/clef/}
 */
var Clef = /** @class */ (function () {
    function Clef(opts) {
        var _a;
        this.schema = Clef.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Clef.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Clef.schema.contents);
    }
    /** Gets @type {ClefAttributes['additional']}. */
    Clef.prototype.getAdditional = function () {
        return this.attributes['additional'];
    };
    /** Sets @type {ClefAttributes['additional']}. */
    Clef.prototype.setAdditional = function (additional) {
        this.attributes['additional'] = additional;
        return this;
    };
    /** Gets @type {ClefAttributes['after-barline']}. */
    Clef.prototype.getAfterBarline = function () {
        return this.attributes['after-barline'];
    };
    /** Sets @type {ClefAttributes['after-barline']}. */
    Clef.prototype.setAfterBarline = function (afterBarline) {
        this.attributes['after-barline'] = afterBarline;
        return this;
    };
    /** Gets @type {ClefAttributes['color']}. */
    Clef.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {ClefAttributes['color']}. */
    Clef.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {ClefAttributes['default-x']}. */
    Clef.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {ClefAttributes['default-x']}. */
    Clef.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {ClefAttributes['default-y']}. */
    Clef.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {ClefAttributes['default-y']}. */
    Clef.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {ClefAttributes['font-family']}. */
    Clef.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {ClefAttributes['font-family']}. */
    Clef.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {ClefAttributes['font-size']}. */
    Clef.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {ClefAttributes['font-size']}. */
    Clef.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {ClefAttributes['font-style']}. */
    Clef.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {ClefAttributes['font-style']}. */
    Clef.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {ClefAttributes['font-weight']}. */
    Clef.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {ClefAttributes['font-weight']}. */
    Clef.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {ClefAttributes['id']}. */
    Clef.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {ClefAttributes['id']}. */
    Clef.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {ClefAttributes['number']}. */
    Clef.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {ClefAttributes['number']}. */
    Clef.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {ClefAttributes['print-object']}. */
    Clef.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {ClefAttributes['print-object']}. */
    Clef.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {ClefAttributes['relative-x']}. */
    Clef.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {ClefAttributes['relative-x']}. */
    Clef.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {ClefAttributes['relative-y']}. */
    Clef.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {ClefAttributes['relative-y']}. */
    Clef.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {ClefAttributes['size']}. */
    Clef.prototype.getSize = function () {
        return this.attributes['size'];
    };
    /** Sets @type {ClefAttributes['size']}. */
    Clef.prototype.setSize = function (size) {
        this.attributes['size'] = size;
        return this;
    };
    /** Gets @type {Sign}. */
    Clef.prototype.getSign = function () {
        return this.contents[0];
    };
    /** Sets @type {Sign}. */
    Clef.prototype.setSign = function (sign) {
        this.contents[0] = sign;
        return this;
    };
    /** Gets @type {Line | null}. */
    Clef.prototype.getLine = function () {
        return this.contents[1];
    };
    /** Sets @type {Line | null}. */
    Clef.prototype.setLine = function (line) {
        this.contents[1] = line;
        return this;
    };
    /** Gets @type {ClefOctaveChange | null}. */
    Clef.prototype.getClefOctaveChange = function () {
        return this.contents[2];
    };
    /** Sets @type {ClefOctaveChange | null}. */
    Clef.prototype.setClefOctaveChange = function (clefOctaveChange) {
        this.contents[2] = clefOctaveChange;
        return this;
    };
    Clef.schema = {
        name: 'clef',
        attributes: {
            additional: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'after-barline': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
        },
        contents: [
            { type: 'required', value: Sign },
            { type: 'optional', value: Line },
            { type: 'optional', value: ClefOctaveChange },
        ],
    };
    return Clef;
}());
exports.Clef = Clef;
/**
 * The <staff-type> element
 *
 * Parent element: <staff-details>
 *
 * The <staff-type> element specifies different uses for the staff, as listed in the staff-type data type.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-type/}
 */
var StaffType = /** @class */ (function () {
    function StaffType(opts) {
        var _a;
        this.schema = StaffType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StaffType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StaffType.schema.contents);
    }
    /** Gets @type {'regular' | 'alternate' | 'cue' | 'editorial' | 'ossia'}. */
    StaffType.prototype.getStaffType = function () {
        return this.contents[0];
    };
    /** Sets @type {'regular' | 'alternate' | 'cue' | 'editorial' | 'ossia'}. */
    StaffType.prototype.setStaffType = function (staffType) {
        this.contents[0] = staffType;
        return this;
    };
    StaffType.schema = {
        name: 'staff-type',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'staff-type',
                    value: { type: 'choices', choices: ['regular', 'alternate', 'cue', 'editorial', 'ossia'] },
                },
            },
        ],
    };
    return StaffType;
}());
exports.StaffType = StaffType;
/**
 * The `<staff-lines>` element
 *
 * Parent element: `<staff-details>`
 *
 * The `<staff-lines>` element specifies the number of lines and is usually used for a non 5-line staff. If the
 * `<staff-lines>` element is present, the appearance of each line may be individually specified with a `<line-detail>`
 * element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-lines/}
 */
var StaffLines = /** @class */ (function () {
    function StaffLines(opts) {
        var _a;
        this.schema = StaffLines.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StaffLines.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StaffLines.schema.contents);
    }
    /** Gets @type {number}. */
    StaffLines.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    StaffLines.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    StaffLines.schema = {
        name: 'staff-lines',
        attributes: {},
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
        ],
    };
    return StaffLines;
}());
exports.StaffLines = StaffLines;
/**
 * The `<line-detail>` element
 *
 * Parent element: `<staff-details>`
 *
 * If the `<staff-lines>` element is present, the appearance of each line may be individually specified with a
 * `<line-detail>` element.
 *
 * The print-object attribute allows lines to be hidden within a staff. This is used in special situations such as a
 * widely-spaced percussion staff where a note placed below the higher line is distinct from a note placed above the
 * lower line. Hidden staff lines are included when specifying clef lines and determining `<display-step>` /
 * `<display-octave>` values, but are not counted as lines for the purposes of the `<system-layout>` and
 * `<staff-layout>` elements.
 *
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/line-detail/}
 */
var LineDetail = /** @class */ (function () {
    function LineDetail(opts) {
        var _a;
        this.schema = LineDetail.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, LineDetail.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(LineDetail.schema.contents);
    }
    /** Gets @type {LineDetailAttributes['line']}. */
    LineDetail.prototype.getLine = function () {
        return this.attributes['line'];
    };
    /** Sets @type {LineDetailAttributes['line']}. */
    LineDetail.prototype.setLine = function (line) {
        this.attributes['line'] = line;
        return this;
    };
    /** Gets @type {LineDetailAttributes['color']}. */
    LineDetail.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {LineDetailAttributes['color']}. */
    LineDetail.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {LineDetailAttributes['line-type']}. */
    LineDetail.prototype.getLineType = function () {
        return this.attributes['line-type'];
    };
    /** Sets @type {LineDetailAttributes['line-type']}. */
    LineDetail.prototype.setLineType = function (lineType) {
        this.attributes['line-type'] = lineType;
        return this;
    };
    /** Gets @type {LineDetailAttributes['print-object']}. */
    LineDetail.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {LineDetailAttributes['print-object']}. */
    LineDetail.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {LineDetailAttributes['width']}. */
    LineDetail.prototype.getWidth = function () {
        return this.attributes['width'];
    };
    /** Sets @type {LineDetailAttributes['width']}. */
    LineDetail.prototype.setWidth = function (width) {
        this.attributes['width'] = width;
        return this;
    };
    LineDetail.schema = {
        name: 'line-detail',
        attributes: {
            line: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [],
    };
    return LineDetail;
}());
exports.LineDetail = LineDetail;
/**
 * The `<staff-tuning>` element
 *
 * Parent element: `<staff-details>`
 *
 * The `<staff-tuning>` element specifies the open, non-capo tuning of the lines on a tablature staff.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-details/}
 */
var StaffTuning = /** @class */ (function () {
    function StaffTuning(opts) {
        var _a;
        this.schema = StaffTuning.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StaffTuning.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StaffTuning.schema.contents);
    }
    /** Gets @type {StaffTuningAttributes['line']}. */
    StaffTuning.prototype.getLine = function () {
        return this.attributes['line'];
    };
    /** Sets @type {StaffTuningAttributes['line']}. */
    StaffTuning.prototype.setLine = function (line) {
        this.attributes['line'] = line;
        return this;
    };
    /** Gets @type {TuningStep}. */
    StaffTuning.prototype.getTuningStep = function () {
        return this.contents[0];
    };
    /** Sets @type {TuningStep}. */
    StaffTuning.prototype.setTuningStep = function (tuningStep) {
        this.contents[0] = tuningStep;
        return this;
    };
    /** Gets @type {TuningAlter | null}. */
    StaffTuning.prototype.getTuningAlter = function () {
        return this.contents[1];
    };
    /** Sets @type {TuningAlter | null}. */
    StaffTuning.prototype.setTuningAlter = function (tuningAlter) {
        this.contents[1] = tuningAlter;
        return this;
    };
    /** Gets @type {TuningOctave}. */
    StaffTuning.prototype.getTuningOctave = function () {
        return this.contents[2];
    };
    /** Sets @type {TuningOctave}. */
    StaffTuning.prototype.setTuningOctave = function (tuningOctave) {
        this.contents[2] = tuningOctave;
        return this;
    };
    StaffTuning.schema = {
        name: 'staff-tuning',
        attributes: { line: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
        contents: [
            { type: 'required', value: TuningStep },
            { type: 'optional', value: TuningAlter },
            { type: 'required', value: TuningOctave },
        ],
    };
    return StaffTuning;
}());
exports.StaffTuning = StaffTuning;
/**
 * The `<capo>` element
 *
 * Parent element: `<staff-details>`
 *
 * The `<capo>` element indicates at which fret a capo should be placed on a fretted instrument. This changes the open
 * tuning of the strings specified by the `<staff-tuning>` element by the specified number of half-steps.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/capo/}
 */
var Capo = /** @class */ (function () {
    function Capo(opts) {
        var _a;
        this.schema = Capo.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Capo.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Capo.schema.contents);
    }
    /** Gets @type {number}. */
    Capo.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Capo.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Capo.schema = {
        name: 'capo',
        attributes: {},
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
        ],
    };
    return Capo;
}());
exports.Capo = Capo;
/**
 * The `<staff-size>` element
 *
 * Parent element: `<staff-details>`
 *
 * The `<staff-size>` element indicates how large a staff space is on this staff, expressed as a percentage of the
 * work's default scaling. Values less than 100 make the staff space smaller while values over 100 make the staff space
 * larger. A `<staff-type>` of cue, ossia, or editorial implies a `<staff-size>` of less than 100, but the exact value
 * is implementation-dependent unless specified here. Staff size affects staff height only, not the relationship of the
 * staff to the left and right margins.
 *
 * In some cases, a `<staff-size>` different than 100 also scales the notation on the staff, such as with a cue staff.
 * In other cases, such as percussion staves, the lines may be more widely spaced without scaling the notation on the
 * staff. The scaling attribute allows these two cases to be distinguished.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-size/}
 */
var StaffSize = /** @class */ (function () {
    function StaffSize(opts) {
        var _a;
        this.schema = StaffSize.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StaffSize.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StaffSize.schema.contents);
    }
    /** Gets @type {StaffSizeAttributes['scaling']}. */
    StaffSize.prototype.getScaling = function () {
        return this.attributes['scaling'];
    };
    /** Sets @type {StaffSizeAttributes['scaling']}. */
    StaffSize.prototype.setScaling = function (scaling) {
        this.attributes['scaling'] = scaling;
        return this;
    };
    /** Gets @type {number}. */
    StaffSize.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    StaffSize.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    StaffSize.schema = {
        name: 'staff-size',
        attributes: { scaling: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } } },
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'float', min: 0, max: Infinity } } },
        ],
    };
    return StaffSize;
}());
exports.StaffSize = StaffSize;
/**
 * The `<staff-details>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<staff-details>` element is used to indicate different types of staves.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-details/}
 */
var StaffDetails = /** @class */ (function () {
    function StaffDetails(opts) {
        var _a;
        this.schema = StaffDetails.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, StaffDetails.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(StaffDetails.schema.contents);
    }
    /** Gets @type {StaffDetailsAttributes['number']}. */
    StaffDetails.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {StaffDetailsAttributes['number']}. */
    StaffDetails.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {StaffDetailsAttributes['print-object']}. */
    StaffDetails.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {StaffDetailsAttributes['print-object']}. */
    StaffDetails.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {StaffDetailsAttributes['print-spacing']}. */
    StaffDetails.prototype.getPrintSpacing = function () {
        return this.attributes['print-spacing'];
    };
    /** Sets @type {StaffDetailsAttributes['print-spacing']}. */
    StaffDetails.prototype.setPrintSpacing = function (printSpacing) {
        this.attributes['print-spacing'] = printSpacing;
        return this;
    };
    /** Gets @type {StaffDetailsAttributes['show-frets']}. */
    StaffDetails.prototype.getShowFrets = function () {
        return this.attributes['show-frets'];
    };
    /** Sets @type {StaffDetailsAttributes['show-frets']}. */
    StaffDetails.prototype.setShowFrets = function (showFrets) {
        this.attributes['show-frets'] = showFrets;
        return this;
    };
    /** Gets @type {StaffType | null}. */
    StaffDetails.prototype.getStaffType = function () {
        return this.contents[0];
    };
    /** Sets @type {StaffType | null}. */
    StaffDetails.prototype.setStaffType = function (staffType) {
        this.contents[0] = staffType;
        return this;
    };
    /** Gets @type {[StaffLines, Array<LineDetail>] | null}. */
    StaffDetails.prototype.getLines = function () {
        return this.contents[1];
    };
    /** Sets @type {[StaffLines, Array<LineDetail>] | null}. */
    StaffDetails.prototype.setLines = function (lines) {
        this.contents[1] = lines;
        return this;
    };
    /** Gets @type {Array<StaffTuning>}. */
    StaffDetails.prototype.getStaffTunings = function () {
        return this.contents[2];
    };
    /** Sets @type {Array<StaffTuning>}. */
    StaffDetails.prototype.setStaffTunings = function (staffTunings) {
        this.contents[2] = staffTunings;
        return this;
    };
    /** Gets @type {Capo | null}. */
    StaffDetails.prototype.getCapo = function () {
        return this.contents[3];
    };
    /** Sets @type {Capo | null}. */
    StaffDetails.prototype.setCapo = function (capo) {
        this.contents[3] = capo;
        return this;
    };
    /** Gets @type {StaffSize | null}. */
    StaffDetails.prototype.getStaffSize = function () {
        return this.contents[4];
    };
    /** Sets @type {StaffSize | null}. */
    StaffDetails.prototype.setStaffSize = function (staffSize) {
        this.contents[4] = staffSize;
        return this;
    };
    StaffDetails.schema = {
        name: 'staff-details',
        attributes: {
            number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-spacing': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'show-frets': { type: 'optional', value: { type: 'choices', choices: ['letters', 'numbers'] } },
        },
        contents: [
            { type: 'optional', value: StaffType },
            {
                type: 'label',
                label: 'lines',
                value: {
                    type: 'optional',
                    value: [
                        { type: 'required', value: StaffLines },
                        { type: 'zeroOrMore', value: LineDetail },
                    ],
                },
            },
            { type: 'label', label: 'staff-tunings', value: { type: 'zeroOrMore', value: StaffTuning } },
            { type: 'optional', value: Capo },
            { type: 'optional', value: StaffSize },
        ],
    };
    return StaffDetails;
}());
exports.StaffDetails = StaffDetails;
/**
 * The `<diatonic>` element
 *
 * Parent elements: `<part-transpose>`, `<transpose>`
 *
 * The `<diatonic>` element specifies the number of pitch steps needed to go from written to sounding pitch. This allows
 * for correct spelling of enharmonic transpositions. This value does not include <octave-change> values; the values for
 * both elements need to be added to the written pitch to get the correct sounding pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/diatonic/}
 */
var Diatonic = /** @class */ (function () {
    function Diatonic(opts) {
        var _a;
        this.schema = Diatonic.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Diatonic.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Diatonic.schema.contents);
    }
    /** Gets @type {number}. */
    Diatonic.prototype.getDiatonic = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Diatonic.prototype.setDiatonic = function (diatonic) {
        this.contents[0] = diatonic;
        return this;
    };
    Diatonic.schema = {
        name: 'diatonic',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'diatonic',
                value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return Diatonic;
}());
exports.Diatonic = Diatonic;
/**
 * The `<chromatic>` element
 *
 * Parent elements: `<part-transpose>`, `<transpose>`
 *
 * The `<chromatic>` element represents the number of semitones needed to get from written to sounding pitch. This value
 * does not include `<octave-change>` values; the values for both elements need to be added to the written pitch to get
 * the correct sounding pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/chromatic/}
 */
var Chromatic = /** @class */ (function () {
    function Chromatic(opts) {
        var _a;
        this.schema = Chromatic.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Chromatic.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Chromatic.schema.contents);
    }
    /** Gets @type {number}. */
    Chromatic.prototype.getSemitones = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Chromatic.prototype.setSemitones = function (semitones) {
        this.contents[0] = semitones;
        return this;
    };
    Chromatic.schema = {
        name: 'chromatic',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return Chromatic;
}());
exports.Chromatic = Chromatic;
/**
 * The `<octave-change>` element
 *
 * Parent elements: `<part-transpose>`, `<transpose>`
 *
 * The `<octave-change>` element indicates how many octaves to add to get from written pitch to sounding pitch. The
 * `<octave-change>` element should be included when using transposition intervals of an octave or more, and should not
 * be present for intervals of less than an octave.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/octave-change/}
 */
var OctaveChange = /** @class */ (function () {
    function OctaveChange(opts) {
        var _a;
        this.schema = OctaveChange.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, OctaveChange.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(OctaveChange.schema.contents);
    }
    /** Gets @type {number}. */
    OctaveChange.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    OctaveChange.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    OctaveChange.schema = {
        name: 'octave-change',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return OctaveChange;
}());
exports.OctaveChange = OctaveChange;
/**
 * The `<double>` element
 *
 * Parent elements: `<part-transpose>`, `<transpose>`
 *
 * If the `<double>` element is present, it indicates that the music is doubled one octave from what is currently
 * written.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/double/}
 */
var Double = /** @class */ (function () {
    function Double(opts) {
        var _a;
        this.schema = Double.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Double.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Double.schema.contents);
    }
    /** Gets @type {DoubleAttributes['above']}. */
    Double.prototype.getAbove = function () {
        return this.attributes['above'];
    };
    /** Sets @type {DoubleAttributes['above']}. */
    Double.prototype.setAbove = function (above) {
        this.attributes['above'] = above;
        return this;
    };
    Double.schema = {
        name: 'double',
        attributes: { above: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
        contents: [],
    };
    return Double;
}());
exports.Double = Double;
/**
 * The `<transpose>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<transpose>` element represents what must be added to a written pitch to get a correct sounding pitch. It is
 * used for encoding parts for transposing instruments that are in written vs. concert pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/transpose/}
 */
var Transpose = /** @class */ (function () {
    function Transpose(opts) {
        var _a;
        this.schema = Transpose.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Transpose.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Transpose.schema.contents);
    }
    /** Gets @type {TransposeAttributes['id']}. */
    Transpose.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {TransposeAttributes['id']}. */
    Transpose.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {TransposeAttributes['number']}. */
    Transpose.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {TransposeAttributes['number']}. */
    Transpose.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {Diatonic | null}. */
    Transpose.prototype.getDiatonic = function () {
        return this.contents[0];
    };
    /** Sets @type {Diatonic | null}. */
    Transpose.prototype.setDiatonic = function (diatonic) {
        this.contents[0] = diatonic;
        return this;
    };
    /** Gets @type {Chromatic}. */
    Transpose.prototype.getChromatic = function () {
        return this.contents[1];
    };
    /** Sets @type {Chromatic}. */
    Transpose.prototype.setChromatic = function (chromatic) {
        this.contents[1] = chromatic;
        return this;
    };
    /** Gets @type {OctaveChange | null}. */
    Transpose.prototype.getOctaveChange = function () {
        return this.contents[2];
    };
    /** Sets @type {OctaveChange | null}. */
    Transpose.prototype.setOctaveChange = function (octaveChange) {
        this.contents[2] = octaveChange;
        return this;
    };
    /** Gets @type {Double | null}. */
    Transpose.prototype.getDouble = function () {
        return this.contents[3];
    };
    /** Sets @type {Double | null}. */
    Transpose.prototype.setDouble = function (double) {
        this.contents[3] = double;
        return this;
    };
    Transpose.schema = {
        name: 'transpose',
        attributes: {
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
        },
        contents: [
            { type: 'optional', value: Diatonic },
            { type: 'required', value: Chromatic },
            { type: 'optional', value: OctaveChange },
            { type: 'optional', value: Double },
        ],
    };
    return Transpose;
}());
exports.Transpose = Transpose;
/**
 * The `<part-clef>` element
 *
 * Parent element: `<for-part>`
 *
 * The `<part-clef>` element is used for transpositions from concert scores that also include a change of clef, as for
 * instruments such as bass clarinet.
 *
 * The child elements of the `<part-clef>` element have the same meaning as for the `<clef>` element. However that
 * meaning applies to a transposed part created from the existing score file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-clef/}
 */
var PartClef = /** @class */ (function () {
    function PartClef(opts) {
        var _a;
        this.schema = PartClef.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartClef.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartClef.schema.contents);
    }
    /** Gets @type {Sign}. */
    PartClef.prototype.getSign = function () {
        return this.contents[0];
    };
    /** Sets @type {Sign}. */
    PartClef.prototype.setSign = function (sign) {
        this.contents[0] = sign;
        return this;
    };
    /** Gets @type {Line | null}. */
    PartClef.prototype.getLine = function () {
        return this.contents[1];
    };
    /** Sets @type {Line | null}. */
    PartClef.prototype.setLine = function (line) {
        this.contents[1] = line;
        return this;
    };
    /** Gets @type {ClefOctaveChange | null}. */
    PartClef.prototype.getClefOctaveChange = function () {
        return this.contents[2];
    };
    /** Sets @type {ClefOctaveChange | null}. */
    PartClef.prototype.setClefOctaveChange = function (clefOctaveChange) {
        this.contents[2] = clefOctaveChange;
        return this;
    };
    PartClef.schema = {
        name: 'part-clef',
        attributes: {},
        contents: [
            { type: 'required', value: Sign },
            { type: 'optional', value: Line },
            { type: 'optional', value: ClefOctaveChange },
        ],
    };
    return PartClef;
}());
exports.PartClef = PartClef;
/**
 * The `<part-transpose>` element
 *
 * Parent element: `<for-part>`
 *
 * The child elements of the `<part-transpose>` element have the same meaning as for the `<transpose>` element. However
 * that meaning applies to a transposed part created from the existing score file.
 *
 * The `<chromatic>` element in a `<part-transpose>` element will usually have a non-zero value, since octave
 * transpositions can be represented in concert scores using the `<transpose>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-transpose/}
 */
var PartTranspose = /** @class */ (function () {
    function PartTranspose(opts) {
        var _a;
        this.schema = PartTranspose.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartTranspose.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartTranspose.schema.contents);
    }
    /** Gets @type {Diatonic | null}. */
    PartTranspose.prototype.getDiatonic = function () {
        return this.contents[0];
    };
    /** Sets @type {Diatonic | null}. */
    PartTranspose.prototype.setDiatonic = function (diatonic) {
        this.contents[0] = diatonic;
        return this;
    };
    /** Gets @type {Chromatic}. */
    PartTranspose.prototype.getChromatic = function () {
        return this.contents[1];
    };
    /** Sets @type {Chromatic}. */
    PartTranspose.prototype.setChromatic = function (chromatic) {
        this.contents[1] = chromatic;
        return this;
    };
    /** Gets @type {OctaveChange | null}. */
    PartTranspose.prototype.getOctaveChange = function () {
        return this.contents[2];
    };
    /** Sets @type {OctaveChange | null}. */
    PartTranspose.prototype.setOctaveChange = function (octaveChange) {
        this.contents[2] = octaveChange;
        return this;
    };
    /** Gets @type {Double | null}. */
    PartTranspose.prototype.getDouble = function () {
        return this.contents[3];
    };
    /** Sets @type {Double | null}. */
    PartTranspose.prototype.setDouble = function (double) {
        this.contents[3] = double;
        return this;
    };
    PartTranspose.schema = {
        name: 'part-transpose',
        attributes: {},
        contents: [
            { type: 'optional', value: Diatonic },
            { type: 'required', value: Chromatic },
            { type: 'optional', value: OctaveChange },
            { type: 'optional', value: Double },
        ],
    };
    return PartTranspose;
}());
exports.PartTranspose = PartTranspose;
/**
 * The `<for-part>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<for-part>` element is used in a concert score to indicate the transposition for a transposed part created from
 * that score. It is only used in score files that contain a `<concert-score>` element in the `<defaults>` element. This
 * allows concert scores with transposed parts to be represented in a single uncompressed MusicXML file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/for-part/}
 */
var ForPart = /** @class */ (function () {
    function ForPart(opts) {
        var _a;
        this.schema = ForPart.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ForPart.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ForPart.schema.contents);
    }
    /** Gets @type {ForPartAttributes['id']}. */
    ForPart.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {ForPartAttributes['id']}. */
    ForPart.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {ForPartAttributes['number']}. */
    ForPart.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {ForPartAttributes['number']}. */
    ForPart.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {PartClef | null}. */
    ForPart.prototype.getPartClef = function () {
        return this.contents[0];
    };
    /** Sets @type {PartClef | null}. */
    ForPart.prototype.setPartClef = function (partClef) {
        this.contents[0] = partClef;
        return this;
    };
    /** Gets @type {PartTranspose}. */
    ForPart.prototype.getPartTranspose = function () {
        return this.contents[1];
    };
    /** Sets @type {PartTranspose}. */
    ForPart.prototype.setPartTranspose = function (partTranspose) {
        this.contents[1] = partTranspose;
        return this;
    };
    ForPart.schema = {
        name: 'for-part',
        attributes: {
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
        },
        contents: [
            { type: 'optional', value: PartClef },
            { type: 'required', value: PartTranspose },
        ],
    };
    return ForPart;
}());
exports.ForPart = ForPart;
/**
 * The `<directive>` element
 *
 * Parent element: `<attributes>`
 *
 * Directives are like directions, but can be grouped together with attributes for convenience. This is typically used
 * for tempo markings at the beginning of a piece of music. This element was deprecated in Version 2.0 in favor of the
 * `<direction>` element's directive attribute.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/directive/}
 */
var Directive = /** @class */ (function () {
    function Directive(opts) {
        var _a;
        this.schema = Directive.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Directive.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Directive.schema.contents);
    }
    /** Gets @type {DirectiveAttributes['color']}. */
    Directive.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DirectiveAttributes['color']}. */
    Directive.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DirectiveAttributes['default-x']}. */
    Directive.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DirectiveAttributes['default-x']}. */
    Directive.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DirectiveAttributes['default-y']}. */
    Directive.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DirectiveAttributes['default-y']}. */
    Directive.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DirectiveAttributes['font-family']}. */
    Directive.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DirectiveAttributes['font-family']}. */
    Directive.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DirectiveAttributes['font-size']}. */
    Directive.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DirectiveAttributes['font-size']}. */
    Directive.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DirectiveAttributes['font-style']}. */
    Directive.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DirectiveAttributes['font-style']}. */
    Directive.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DirectiveAttributes['font-weight']}. */
    Directive.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DirectiveAttributes['font-weight']}. */
    Directive.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DirectiveAttributes['relative-x']}. */
    Directive.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DirectiveAttributes['relative-x']}. */
    Directive.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DirectiveAttributes['relative-y']}. */
    Directive.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DirectiveAttributes['relative-y']}. */
    Directive.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DirectiveAttributes['xml:lang']}. */
    Directive.prototype.getXmlLang = function () {
        return this.attributes['xml:lang'];
    };
    /** Sets @type {DirectiveAttributes['xml:lang']}. */
    Directive.prototype.setXmlLang = function (xmlLang) {
        this.attributes['xml:lang'] = xmlLang;
        return this;
    };
    /** Gets @type {string}. */
    Directive.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Directive.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Directive.schema = {
        name: 'directive',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'xml:lang': { type: 'optional', value: { type: 'string' } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Directive;
}());
exports.Directive = Directive;
/**
 * The `<multiple-rest>` element
 *
 * Parent element: `<measure-style>`
 *
 * The `<multiple-rest>` element indicates multiple rests that span several measures. The element text indicates the number of measures in the multiple rest.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/multiple-rest/}
 */
var MultipleRest = /** @class */ (function () {
    function MultipleRest(opts) {
        var _a;
        this.schema = MultipleRest.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MultipleRest.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MultipleRest.schema.contents);
    }
    /** Gets @type {MultipleRestAttributes['use-symbols']}. */
    MultipleRest.prototype.getUseSymbols = function () {
        return this.attributes['use-symbols'];
    };
    /** Sets @type {MultipleRestAttributes['use-symbols']}. */
    MultipleRest.prototype.setUseSymbols = function (useSymbols) {
        this.attributes['use-symbols'] = useSymbols;
        return this;
    };
    /** Gets @type {number}. */
    MultipleRest.prototype.getMultipleRest = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    MultipleRest.prototype.setMultipleRest = function (multipleRest) {
        this.contents[0] = multipleRest;
        return this;
    };
    MultipleRest.schema = {
        name: 'multiple-rest',
        attributes: { 'use-symbols': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
        contents: [
            {
                type: 'label',
                label: 'multiple-rest',
                value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
            },
        ],
    };
    return MultipleRest;
}());
exports.MultipleRest = MultipleRest;
/**
 * The `<measure-repeat>` element
 *
 * Parent element: `<measure-style>`
 *
 * The `<measure-repeat>` element is used for both single and multiple measure repeats. The text of the element
 * indicates the number of measures to be repeated in a single pattern. The text of the element is ignored when the type
 * is stop.
 *
 * The stop type indicates the first measure where the repeats are no longer displayed. Both the start and the stop of
 * the measures being repeated should be specified unless the repeats are displayed through the end of the part.
 *
 * The `<measure-repeat>` element specifies a notation style for repetitions. The actual music being repeated needs to
 * be repeated within each measure of the MusicXML file. This element specifies the notation that indicates the repeat.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-repeat/}
 */
var MeasureRepeat = /** @class */ (function () {
    function MeasureRepeat(opts) {
        var _a;
        this.schema = MeasureRepeat.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MeasureRepeat.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MeasureRepeat.schema.contents);
    }
    /** Gets @type {MeasureRepeatAttributes['type']}. */
    MeasureRepeat.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {MeasureRepeatAttributes['type']}. */
    MeasureRepeat.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {MeasureRepeatAttributes['slashes']}. */
    MeasureRepeat.prototype.getSlashes = function () {
        return this.attributes['slashes'];
    };
    /** Sets @type {MeasureRepeatAttributes['slashes']}. */
    MeasureRepeat.prototype.setSlashes = function (slashes) {
        this.attributes['slashes'] = slashes;
        return this;
    };
    /** Gets @type {'' | number}. */
    MeasureRepeat.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'' | number}. */
    MeasureRepeat.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    MeasureRepeat.schema = {
        name: 'measure-repeat',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            slashes: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
        },
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'required', value: { type: 'choices', choices: ['', { type: 'int', min: 1, max: Infinity }] } },
            },
        ],
    };
    return MeasureRepeat;
}());
exports.MeasureRepeat = MeasureRepeat;
/**
 * The `<slash-type>` element
 *
 * Parent elements: `<beat-repeat>`, `<slash>`
 *
 * The `<slash-type>` element indicates the graphical note type to use for the display of repetition marks.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/slash-type/}
 */
var SlashType = /** @class */ (function () {
    function SlashType(opts) {
        var _a;
        this.schema = SlashType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SlashType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SlashType.schema.contents);
    }
    /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    SlashType.prototype.getNoteTypeValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
    SlashType.prototype.setNoteTypeValue = function (noteTypeValue) {
        this.contents[0] = noteTypeValue;
        return this;
    };
    SlashType.schema = {
        name: 'slash-type',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'note-type-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'whole',
                            '1024th',
                            '512th',
                            '256th',
                            '128th',
                            '64th',
                            '32nd',
                            '16th',
                            'eighth',
                            'half',
                            'quarter',
                            'whole',
                            'breve',
                            'long',
                            'maxima',
                        ],
                    },
                },
            },
        ],
    };
    return SlashType;
}());
exports.SlashType = SlashType;
/**
 * The `<slash-dot>` element
 *
 * Parent elements: `<beat-repeat>`, `<slash>`
 *
 * The `<slash-dot>` element is used to specify any augmentation dots in the note type used to display repetition marks.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/slash-dot/}
 */
var SlashDot = /** @class */ (function () {
    function SlashDot(opts) {
        var _a;
        this.schema = SlashDot.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, SlashDot.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(SlashDot.schema.contents);
    }
    SlashDot.schema = { name: 'slash-dot', attributes: {}, contents: [] };
    return SlashDot;
}());
exports.SlashDot = SlashDot;
/**
 * The `<except-voice>` element
 *
 * Parent elements: `<beat-repeat>`, `<slash>`
 *
 * The `<except-voice>` element is used to specify a combination of slash notation and regular notation. Any `<note>`
 * elements that are in voices specified by the `<except-voice>` elements are displayed in normal notation, in addition
 * to the slash notation that is always displayed.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/except-voice/}
 */
var ExceptVoice = /** @class */ (function () {
    function ExceptVoice(opts) {
        var _a;
        this.schema = ExceptVoice.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ExceptVoice.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ExceptVoice.schema.contents);
    }
    /** Gets @type {string}. */
    ExceptVoice.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    ExceptVoice.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    ExceptVoice.schema = {
        name: 'except-voice',
        attributes: {},
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return ExceptVoice;
}());
exports.ExceptVoice = ExceptVoice;
/**
 * The `<beat-repeat>` element
 *
 * Parent element: `<measure-style>`
 *
 * The `<beat-repeat>` element is used to indicate that a single beat (but possibly many notes) is repeated.
 *
 * The stop type indicates the first beat where the repeats are no longer displayed. Both the start and stop of the
 * beats being repeated should be specified unless the repeats are displayed through the end of the part.
 *
 * The `<beat-repeat>` element specifies a notation style for repetitions. The actual music being repeated needs to be
 * repeated within the MusicXML file. This element specifies the notation that indicates the repeat.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beat-repeat/}
 */
var BeatRepeat = /** @class */ (function () {
    function BeatRepeat(opts) {
        var _a;
        this.schema = BeatRepeat.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BeatRepeat.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BeatRepeat.schema.contents);
    }
    /** Gets @type {BeatRepeatAttributes['type']}. */
    BeatRepeat.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {BeatRepeatAttributes['type']}. */
    BeatRepeat.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {BeatRepeatAttributes['slashes']}. */
    BeatRepeat.prototype.getSlashes = function () {
        return this.attributes['slashes'];
    };
    /** Sets @type {BeatRepeatAttributes['slashes']}. */
    BeatRepeat.prototype.setSlashes = function (slashes) {
        this.attributes['slashes'] = slashes;
        return this;
    };
    /** Gets @type {BeatRepeatAttributes['use-dots']}. */
    BeatRepeat.prototype.getUseDots = function () {
        return this.attributes['use-dots'];
    };
    /** Sets @type {BeatRepeatAttributes['use-dots']}. */
    BeatRepeat.prototype.setUseDots = function (useDots) {
        this.attributes['use-dots'] = useDots;
        return this;
    };
    /** Gets @type {[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null}. */
    BeatRepeat.prototype.getBeatRepeat = function () {
        return this.contents[0];
    };
    /** Sets @type {[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null}. */
    BeatRepeat.prototype.setBeatRepeat = function (beatRepeat) {
        this.contents[0] = beatRepeat;
        return this;
    };
    BeatRepeat.schema = {
        name: 'beat-repeat',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            slashes: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
            'use-dots': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
        },
        contents: [
            {
                type: 'label',
                label: 'beat-repeat',
                value: {
                    type: 'optional',
                    value: [
                        {
                            type: 'optional',
                            value: [
                                { type: 'required', value: SlashType },
                                { type: 'zeroOrMore', value: SlashDot },
                            ],
                        },
                        { type: 'zeroOrMore', value: ExceptVoice },
                    ],
                },
            },
        ],
    };
    return BeatRepeat;
}());
exports.BeatRepeat = BeatRepeat;
/**
 * The `<slash>` element
 *
 * Parent element: `<measure-style>`
 *
 * The `<slash>` element indicates that slash notation is to be used.
 *
 * The stop type indicates the first beat where slash notation no longer displayed. Both the start and stop of the slash
 * notation should be specified unless the slashes are displayed through the end of the part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/slash/}
 */
var Slash = /** @class */ (function () {
    function Slash(opts) {
        var _a;
        this.schema = Slash.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Slash.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Slash.schema.contents);
    }
    /** Gets @type {SlashAttributes['type']}. */
    Slash.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {SlashAttributes['type']}. */
    Slash.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {SlashAttributes['use-dots']}. */
    Slash.prototype.getUseDots = function () {
        return this.attributes['use-dots'];
    };
    /** Sets @type {SlashAttributes['use-dots']}. */
    Slash.prototype.setUseDots = function (useDots) {
        this.attributes['use-dots'] = useDots;
        return this;
    };
    /** Gets @type {SlashAttributes['use-stems']}. */
    Slash.prototype.getUseStems = function () {
        return this.attributes['use-stems'];
    };
    /** Sets @type {SlashAttributes['use-stems']}. */
    Slash.prototype.setUseStems = function (useStems) {
        this.attributes['use-stems'] = useStems;
        return this;
    };
    /** Gets @type {[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null}. */
    Slash.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null}. */
    Slash.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    Slash.schema = {
        name: 'slash',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            'use-dots': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'use-stems': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
        },
        contents: [
            {
                type: 'label',
                label: 'value',
                value: {
                    type: 'optional',
                    value: [
                        {
                            type: 'optional',
                            value: [
                                { type: 'required', value: SlashType },
                                { type: 'zeroOrMore', value: SlashDot },
                            ],
                        },
                        { type: 'zeroOrMore', value: ExceptVoice },
                    ],
                },
            },
        ],
    };
    return Slash;
}());
exports.Slash = Slash;
/**
 * The `<measure-style>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<measure-style>` element indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.
 *
 * The `<multiple-rest>` and `<measure-repeat>` elements indicate the number of measures covered in the element content. The `<beat-repeat>` and `<slash>` elements can cover partial measures. All but the multiple-rest element use a type attribute to indicate starting and stopping the use of the style.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-style/}
 */
var MeasureStyle = /** @class */ (function () {
    function MeasureStyle(opts) {
        var _a;
        this.schema = MeasureStyle.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MeasureStyle.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MeasureStyle.schema.contents);
    }
    /** Gets @type {MeasureStyleAttributes['color']}. */
    MeasureStyle.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {MeasureStyleAttributes['color']}. */
    MeasureStyle.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {MeasureStyleAttributes['font-family']}. */
    MeasureStyle.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {MeasureStyleAttributes['font-family']}. */
    MeasureStyle.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {MeasureStyleAttributes['font-size']}. */
    MeasureStyle.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {MeasureStyleAttributes['font-size']}. */
    MeasureStyle.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {MeasureStyleAttributes['font-style']}. */
    MeasureStyle.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {MeasureStyleAttributes['font-style']}. */
    MeasureStyle.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {MeasureStyleAttributes['font-weight']}. */
    MeasureStyle.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {MeasureStyleAttributes['font-weight']}. */
    MeasureStyle.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {MeasureStyleAttributes['id']}. */
    MeasureStyle.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {MeasureStyleAttributes['id']}. */
    MeasureStyle.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {MeasureStyleAttributes['number']}. */
    MeasureStyle.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {MeasureStyleAttributes['number']}. */
    MeasureStyle.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {MultipleRest | MeasureRepeat | BeatRepeat | Slash}. */
    MeasureStyle.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {MultipleRest | MeasureRepeat | BeatRepeat | Slash}. */
    MeasureStyle.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    MeasureStyle.schema = {
        name: 'measure-style',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
        },
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'choices', choices: [MultipleRest, MeasureRepeat, BeatRepeat, Slash] },
            },
        ],
    };
    return MeasureStyle;
}());
exports.MeasureStyle = MeasureStyle;
/**
 * The `<attributes>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<attributes>` element contains musical information that typically changes on measure boundaries. This includes
 * key and time signatures, clefs, transpositions, and staving. When attributes are changed mid-measure, it affects the
 * music in score order, not in MusicXML document order.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/attributes/}
 */
var Attributes = /** @class */ (function () {
    function Attributes(opts) {
        var _a;
        this.schema = Attributes.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Attributes.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Attributes.schema.contents);
    }
    /** Gets @type {Footnote | null}. */
    Attributes.prototype.getFootnote = function () {
        return this.contents[0];
    };
    /** Sets @type {Footnote | null}. */
    Attributes.prototype.setFootnote = function (footnote) {
        this.contents[0] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    Attributes.prototype.getLevel = function () {
        return this.contents[1];
    };
    /** Sets @type {Level | null}. */
    Attributes.prototype.setLevel = function (level) {
        this.contents[1] = level;
        return this;
    };
    /** Gets @type {Divisions | null}. */
    Attributes.prototype.getDivisions = function () {
        return this.contents[2];
    };
    /** Sets @type {Divisions | null}. */
    Attributes.prototype.setDivisions = function (divisions) {
        this.contents[2] = divisions;
        return this;
    };
    /** Gets @type {Array<Key>}. */
    Attributes.prototype.getKeys = function () {
        return this.contents[3];
    };
    /** Sets @type {Array<Key>}. */
    Attributes.prototype.setKeys = function (keys) {
        this.contents[3] = keys;
        return this;
    };
    /** Gets @type {Array<Time>}. */
    Attributes.prototype.getTimes = function () {
        return this.contents[4];
    };
    /** Sets @type {Array<Time>}. */
    Attributes.prototype.setTimes = function (times) {
        this.contents[4] = times;
        return this;
    };
    /** Gets @type {Staves | null}. */
    Attributes.prototype.getStaves = function () {
        return this.contents[5];
    };
    /** Sets @type {Staves | null}. */
    Attributes.prototype.setStaves = function (staves) {
        this.contents[5] = staves;
        return this;
    };
    /** Gets @type {PartSymbol | null}. */
    Attributes.prototype.getPartSymbol = function () {
        return this.contents[6];
    };
    /** Sets @type {PartSymbol | null}. */
    Attributes.prototype.setPartSymbol = function (partSymbol) {
        this.contents[6] = partSymbol;
        return this;
    };
    /** Gets @type {Instruments | null}. */
    Attributes.prototype.getInstruments = function () {
        return this.contents[7];
    };
    /** Sets @type {Instruments | null}. */
    Attributes.prototype.setInstruments = function (instruments) {
        this.contents[7] = instruments;
        return this;
    };
    /** Gets @type {Array<Clef>}. */
    Attributes.prototype.getClefs = function () {
        return this.contents[8];
    };
    /** Sets @type {Array<Clef>}. */
    Attributes.prototype.setClefs = function (clefs) {
        this.contents[8] = clefs;
        return this;
    };
    /** Gets @type {Array<StaffDetails>}. */
    Attributes.prototype.getStaffDetails = function () {
        return this.contents[9];
    };
    /** Sets @type {Array<StaffDetails>}. */
    Attributes.prototype.setStaffDetails = function (staffDetails) {
        this.contents[9] = staffDetails;
        return this;
    };
    /** Gets @type {Transposes | ForParts}. */
    Attributes.prototype.getTranspositions = function () {
        return this.contents[10];
    };
    /** Sets @type {Transposes | ForParts}. */
    Attributes.prototype.setTranspositions = function (transpositions) {
        this.contents[10] = transpositions;
        return this;
    };
    /** Gets @type {Array<Directive>}. */
    Attributes.prototype.getDirectives = function () {
        return this.contents[11];
    };
    /** Sets @type {Array<Directive>}. */
    Attributes.prototype.setDirectives = function (directives) {
        this.contents[11] = directives;
        return this;
    };
    /** Gets @type {Array<MeasureStyle>}. */
    Attributes.prototype.getMeasureStyles = function () {
        return this.contents[12];
    };
    /** Sets @type {Array<MeasureStyle>}. */
    Attributes.prototype.setMeasureStyles = function (measureStyles) {
        this.contents[12] = measureStyles;
        return this;
    };
    Attributes.schema = {
        name: 'attributes',
        attributes: {},
        contents: [
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
            { type: 'optional', value: Divisions },
            { type: 'label', label: 'keys', value: { type: 'zeroOrMore', value: Key } },
            { type: 'label', label: 'times', value: { type: 'zeroOrMore', value: Time } },
            { type: 'optional', value: Staves },
            { type: 'optional', value: PartSymbol },
            { type: 'optional', value: Instruments },
            { type: 'label', label: 'clefs', value: { type: 'zeroOrMore', value: Clef } },
            { type: 'label', label: 'staff-details', value: { type: 'zeroOrMore', value: StaffDetails } },
            {
                type: 'label',
                label: 'transpositions',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'label', label: 'transposes', value: { type: 'zeroOrMore', value: Transpose } },
                        { type: 'label', label: 'for-parts', value: { type: 'zeroOrMore', value: ForPart } },
                    ],
                },
            },
            { type: 'label', label: 'directives', value: { type: 'zeroOrMore', value: Directive } },
            { type: 'label', label: 'measure-styles', value: { type: 'zeroOrMore', value: MeasureStyle } },
        ],
    };
    return Attributes;
}());
exports.Attributes = Attributes;
/**
 * The `<root-step>` element
 *
 * Parent element: `<root>`
 *
 * The `<root-step>` element represents the pitch step of the root of the current chord within the harmony element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/root-step/}
 */
var RootStep = /** @class */ (function () {
    function RootStep(opts) {
        var _a;
        this.schema = RootStep.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, RootStep.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(RootStep.schema.contents);
    }
    /** Gets @type {RootStepAttributes['color']}. */
    RootStep.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {RootStepAttributes['color']}. */
    RootStep.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {RootStepAttributes['default-x']}. */
    RootStep.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {RootStepAttributes['default-x']}. */
    RootStep.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {RootStepAttributes['default-y']}. */
    RootStep.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {RootStepAttributes['default-y']}. */
    RootStep.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {RootStepAttributes['font-family']}. */
    RootStep.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {RootStepAttributes['font-family']}. */
    RootStep.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {RootStepAttributes['font-size']}. */
    RootStep.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {RootStepAttributes['font-size']}. */
    RootStep.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {RootStepAttributes['font-style']}. */
    RootStep.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {RootStepAttributes['font-style']}. */
    RootStep.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {RootStepAttributes['font-weight']}. */
    RootStep.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {RootStepAttributes['font-weight']}. */
    RootStep.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {RootStepAttributes['relative-x']}. */
    RootStep.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {RootStepAttributes['relative-x']}. */
    RootStep.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {RootStepAttributes['relative-y']}. */
    RootStep.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {RootStepAttributes['relative-y']}. */
    RootStep.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {RootStepAttributes['text']}. */
    RootStep.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {RootStepAttributes['text']}. */
    RootStep.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    RootStep.prototype.getStep = function () {
        return this.contents[0];
    };
    /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    RootStep.prototype.setStep = function (step) {
        this.contents[0] = step;
        return this;
    };
    RootStep.schema = {
        name: 'root-step',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            text: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            { type: 'label', label: 'step', value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] } },
        ],
    };
    return RootStep;
}());
exports.RootStep = RootStep;
/**
 * The `<root-alter>` element
 *
 * Parent element: `<root>`
 *
 * The `<root-alter>` element represents the chromatic alteration of the root of the current chord within the
 * `<harmony>` element. In some chord styles, the text for the `<root-step>` element may include `<root-alter>`
 * information. In that case, the print-object attribute of the `<root-alter>` element can be set to no.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/root-alter/}
 */
var RootAlter = /** @class */ (function () {
    function RootAlter(opts) {
        var _a;
        this.schema = RootAlter.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, RootAlter.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(RootAlter.schema.contents);
    }
    /** Gets @type {RootAlterAttributes['color']}. */
    RootAlter.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {RootAlterAttributes['color']}. */
    RootAlter.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {RootAlterAttributes['default-x']}. */
    RootAlter.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {RootAlterAttributes['default-x']}. */
    RootAlter.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {RootAlterAttributes['default-y']}. */
    RootAlter.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {RootAlterAttributes['default-y']}. */
    RootAlter.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {RootAlterAttributes['font-family']}. */
    RootAlter.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {RootAlterAttributes['font-family']}. */
    RootAlter.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {RootAlterAttributes['font-size']}. */
    RootAlter.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {RootAlterAttributes['font-size']}. */
    RootAlter.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {RootAlterAttributes['font-style']}. */
    RootAlter.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {RootAlterAttributes['font-style']}. */
    RootAlter.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {RootAlterAttributes['font-weight']}. */
    RootAlter.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {RootAlterAttributes['font-weight']}. */
    RootAlter.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {RootAlterAttributes['location']}. */
    RootAlter.prototype.getLocation = function () {
        return this.attributes['location'];
    };
    /** Sets @type {RootAlterAttributes['location']}. */
    RootAlter.prototype.setLocation = function (location) {
        this.attributes['location'] = location;
        return this;
    };
    /** Gets @type {RootAlterAttributes['print-object']}. */
    RootAlter.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {RootAlterAttributes['print-object']}. */
    RootAlter.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {RootAlterAttributes['relative-x']}. */
    RootAlter.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {RootAlterAttributes['relative-x']}. */
    RootAlter.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {RootAlterAttributes['relative-y']}. */
    RootAlter.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {RootAlterAttributes['relative-y']}. */
    RootAlter.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {number}. */
    RootAlter.prototype.getSemitones = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    RootAlter.prototype.setSemitones = function (semitones) {
        this.contents[0] = semitones;
        return this;
    };
    RootAlter.schema = {
        name: 'root-alter',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return RootAlter;
}());
exports.RootAlter = RootAlter;
/**
 * The `<root>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<root>` element indicates a pitch like C, D, E vs. a scale degree like 1, 2, 3. It is used with chord symbols in
 * popular music. The `<root>` element has a `<root-step>` and optional `<root-alter>` element similar to the `<step>`
 * and `<alter>` elements, but renamed to distinguish the different musical meanings.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/root/}
 */
var Root = /** @class */ (function () {
    function Root(opts) {
        var _a;
        this.schema = Root.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Root.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Root.schema.contents);
    }
    /** Gets @type {RootStep}. */
    Root.prototype.getRootStep = function () {
        return this.contents[0];
    };
    /** Sets @type {RootStep}. */
    Root.prototype.setRootStep = function (rootStep) {
        this.contents[0] = rootStep;
        return this;
    };
    /** Gets @type {RootAlter | null}. */
    Root.prototype.getRootAlter = function () {
        return this.contents[1];
    };
    /** Sets @type {RootAlter | null}. */
    Root.prototype.setRootAlter = function (rootAlter) {
        this.contents[1] = rootAlter;
        return this;
    };
    Root.schema = {
        name: 'root',
        attributes: {},
        contents: [
            { type: 'required', value: RootStep },
            { type: 'optional', value: RootAlter },
        ],
    };
    return Root;
}());
exports.Root = Root;
/**
 * The `<numeral-root>` element
 *
 * Parent element: `<numeral>`
 *
 * The `<numeral-root>` element represents the Roman numeral or Nashville number as a positive integer from 1 to 7.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral-root/}
 */
var NumeralRoot = /** @class */ (function () {
    function NumeralRoot(opts) {
        var _a;
        this.schema = NumeralRoot.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NumeralRoot.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NumeralRoot.schema.contents);
    }
    /** Gets @type {NumeralRootAttributes['color']}. */
    NumeralRoot.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {NumeralRootAttributes['color']}. */
    NumeralRoot.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {NumeralRootAttributes['default-x']}. */
    NumeralRoot.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {NumeralRootAttributes['default-x']}. */
    NumeralRoot.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {NumeralRootAttributes['default-y']}. */
    NumeralRoot.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {NumeralRootAttributes['default-y']}. */
    NumeralRoot.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {NumeralRootAttributes['font-family']}. */
    NumeralRoot.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {NumeralRootAttributes['font-family']}. */
    NumeralRoot.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {NumeralRootAttributes['font-size']}. */
    NumeralRoot.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {NumeralRootAttributes['font-size']}. */
    NumeralRoot.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {NumeralRootAttributes['font-style']}. */
    NumeralRoot.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {NumeralRootAttributes['font-style']}. */
    NumeralRoot.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {NumeralRootAttributes['font-weight']}. */
    NumeralRoot.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {NumeralRootAttributes['font-weight']}. */
    NumeralRoot.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {NumeralRootAttributes['relative-x']}. */
    NumeralRoot.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {NumeralRootAttributes['relative-x']}. */
    NumeralRoot.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {NumeralRootAttributes['relative-y']}. */
    NumeralRoot.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {NumeralRootAttributes['relative-y']}. */
    NumeralRoot.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {NumeralRootAttributes['text']}. */
    NumeralRoot.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {NumeralRootAttributes['text']}. */
    NumeralRoot.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {number}. */
    NumeralRoot.prototype.getNumeralValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    NumeralRoot.prototype.setNumeralValue = function (numeralValue) {
        this.contents[0] = numeralValue;
        return this;
    };
    NumeralRoot.schema = {
        name: 'numeral-root',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            text: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            { type: 'required', value: { type: 'label', label: 'numeral-value', value: { type: 'int', min: 1, max: 7 } } },
        ],
    };
    return NumeralRoot;
}());
exports.NumeralRoot = NumeralRoot;
/**
 * The `<numeral-alter>` element
 *
 * Parent element: `<numeral>`
 *
 * The `<numeral-alter>` element represents an alteration to the `<numeral-root>`, similar to the `<alter>` element for a `<pitch>`.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral-alter/}
 */
var NumeralAlter = /** @class */ (function () {
    function NumeralAlter(opts) {
        var _a;
        this.schema = NumeralAlter.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NumeralAlter.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NumeralAlter.schema.contents);
    }
    /** Gets @type {NumeralAlterAttributes['color']}. */
    NumeralAlter.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {NumeralAlterAttributes['color']}. */
    NumeralAlter.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['default-x']}. */
    NumeralAlter.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {NumeralAlterAttributes['default-x']}. */
    NumeralAlter.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['default-y']}. */
    NumeralAlter.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {NumeralAlterAttributes['default-y']}. */
    NumeralAlter.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['font-family']}. */
    NumeralAlter.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {NumeralAlterAttributes['font-family']}. */
    NumeralAlter.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['font-size']}. */
    NumeralAlter.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {NumeralAlterAttributes['font-size']}. */
    NumeralAlter.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['font-style']}. */
    NumeralAlter.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {NumeralAlterAttributes['font-style']}. */
    NumeralAlter.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['font-weight']}. */
    NumeralAlter.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {NumeralAlterAttributes['font-weight']}. */
    NumeralAlter.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['location']}. */
    NumeralAlter.prototype.getLocation = function () {
        return this.attributes['location'];
    };
    /** Sets @type {NumeralAlterAttributes['location']}. */
    NumeralAlter.prototype.setLocation = function (location) {
        this.attributes['location'] = location;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['print-object']}. */
    NumeralAlter.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {NumeralAlterAttributes['print-object']}. */
    NumeralAlter.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['relative-x']}. */
    NumeralAlter.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {NumeralAlterAttributes['relative-x']}. */
    NumeralAlter.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['relative-y']}. */
    NumeralAlter.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {NumeralAlterAttributes['relative-y']}. */
    NumeralAlter.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {NumeralAlterAttributes['text']}. */
    NumeralAlter.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {NumeralAlterAttributes['text']}. */
    NumeralAlter.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {number}. */
    NumeralAlter.prototype.getSemitones = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    NumeralAlter.prototype.setSemitones = function (semitones) {
        this.contents[0] = semitones;
        return this;
    };
    NumeralAlter.schema = {
        name: 'numeral-alter',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            text: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return NumeralAlter;
}());
exports.NumeralAlter = NumeralAlter;
/**
 * The `<numeral-fifths>` element
 *
 * Parent element: `<numeral-key>`
 *
 * The `<numeral-fifths>` element specifies the key in the same way as the `<fifths>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral-fifths/}
 */
var NumeralFifths = /** @class */ (function () {
    function NumeralFifths(opts) {
        var _a;
        this.schema = NumeralFifths.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NumeralFifths.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NumeralFifths.schema.contents);
    }
    /** Gets @type {number}. */
    NumeralFifths.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    NumeralFifths.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    NumeralFifths.schema = {
        name: 'numeral-fifths',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return NumeralFifths;
}());
exports.NumeralFifths = NumeralFifths;
/**
 * The `<numeral-mode>` element
 *
 * Parent element: `<numeral-key>`
 *
 * The `<numeral-mode>` specifies the scale that is used to interpret the `<numeral-root>` element values.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral-mode/}
 */
var NumeralMode = /** @class */ (function () {
    function NumeralMode(opts) {
        var _a;
        this.schema = NumeralMode.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NumeralMode.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NumeralMode.schema.contents);
    }
    /** Gets @type {'major' | 'harmonic minor' | 'melodic minor' | 'minor' | 'natural minor'}. */
    NumeralMode.prototype.getNumeralMode = function () {
        return this.contents[0];
    };
    /** Sets @type {'major' | 'harmonic minor' | 'melodic minor' | 'minor' | 'natural minor'}. */
    NumeralMode.prototype.setNumeralMode = function (numeralMode) {
        this.contents[0] = numeralMode;
        return this;
    };
    NumeralMode.schema = {
        name: 'numeral-mode',
        attributes: {},
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'numeral-mode',
                    value: { type: 'choices', choices: ['major', 'harmonic minor', 'melodic minor', 'minor', 'natural minor'] },
                },
            },
        ],
    };
    return NumeralMode;
}());
exports.NumeralMode = NumeralMode;
/**
 * The `<numeral-key>` element
 *
 * Parent element: `<numeral>`
 *
 * The `<numeral-key>` element is used when the key for the numeral is different than the key specified by the key
 * signature.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral-key/}
 */
var NumeralKey = /** @class */ (function () {
    function NumeralKey(opts) {
        var _a;
        this.schema = NumeralKey.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, NumeralKey.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(NumeralKey.schema.contents);
    }
    /** Gets @type {NumeralKeyAttributes['print-object']}. */
    NumeralKey.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {NumeralKeyAttributes['print-object']}. */
    NumeralKey.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {NumeralFifths}. */
    NumeralKey.prototype.getNumeralFifths = function () {
        return this.contents[0];
    };
    /** Sets @type {NumeralFifths}. */
    NumeralKey.prototype.setNumeralFifths = function (numeralFifths) {
        this.contents[0] = numeralFifths;
        return this;
    };
    /** Gets @type {NumeralMode}. */
    NumeralKey.prototype.getNumeralMode = function () {
        return this.contents[1];
    };
    /** Sets @type {NumeralMode}. */
    NumeralKey.prototype.setNumeralMode = function (numeralMode) {
        this.contents[1] = numeralMode;
        return this;
    };
    NumeralKey.schema = {
        name: 'numeral-key',
        attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
        contents: [
            { type: 'required', value: NumeralFifths },
            { type: 'required', value: NumeralMode },
        ],
    };
    return NumeralKey;
}());
exports.NumeralKey = NumeralKey;
/**
 * The `<numeral>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<numeral>` element represents the Roman numeral or Nashville number part of a harmony. It requires that the key
 * be specified in the encoding, either with a `<key>` or `<numeral-key>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral/}
 */
var Numeral = /** @class */ (function () {
    function Numeral(opts) {
        var _a;
        this.schema = Numeral.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Numeral.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Numeral.schema.contents);
    }
    /** Gets @type {NumeralRoot}. */
    Numeral.prototype.getNumeralRoot = function () {
        return this.contents[0];
    };
    /** Sets @type {NumeralRoot}. */
    Numeral.prototype.setNumeralRoot = function (numeralRoot) {
        this.contents[0] = numeralRoot;
        return this;
    };
    /** Gets @type {NumeralAlter | null}. */
    Numeral.prototype.getNumeralAlter = function () {
        return this.contents[1];
    };
    /** Sets @type {NumeralAlter | null}. */
    Numeral.prototype.setNumeralAlter = function (numeralAlter) {
        this.contents[1] = numeralAlter;
        return this;
    };
    /** Gets @type {NumeralKey | null}. */
    Numeral.prototype.getNumeralKey = function () {
        return this.contents[2];
    };
    /** Sets @type {NumeralKey | null}. */
    Numeral.prototype.setNumeralKey = function (numeralKey) {
        this.contents[2] = numeralKey;
        return this;
    };
    Numeral.schema = {
        name: 'numeral',
        attributes: {},
        contents: [
            { type: 'required', value: NumeralRoot },
            { type: 'optional', value: NumeralAlter },
            { type: 'optional', value: NumeralKey },
        ],
    };
    return Numeral;
}());
exports.Numeral = Numeral;
/**
 * The `<function>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<function>` element represents classical functional harmony with an indication like I, II, III rather than C, D,
 * E. It represents the Roman numeral part of a functional harmony rather than the complete function itself. It has been
 * deprecated as of MusicXML 4.0 in favor of the <numeral> element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/function/}
 */
var Function = /** @class */ (function () {
    function Function(opts) {
        var _a;
        this.schema = Function.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Function.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Function.schema.contents);
    }
    /** Gets @type {FunctionAttributes['color']}. */
    Function.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FunctionAttributes['color']}. */
    Function.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FunctionAttributes['default-x']}. */
    Function.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {FunctionAttributes['default-x']}. */
    Function.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {FunctionAttributes['default-y']}. */
    Function.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {FunctionAttributes['default-y']}. */
    Function.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {FunctionAttributes['font-family']}. */
    Function.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FunctionAttributes['font-family']}. */
    Function.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FunctionAttributes['font-size']}. */
    Function.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FunctionAttributes['font-size']}. */
    Function.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FunctionAttributes['font-style']}. */
    Function.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FunctionAttributes['font-style']}. */
    Function.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FunctionAttributes['font-weight']}. */
    Function.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FunctionAttributes['font-weight']}. */
    Function.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {FunctionAttributes['relative-x']}. */
    Function.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {FunctionAttributes['relative-x']}. */
    Function.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {FunctionAttributes['relative-y']}. */
    Function.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {FunctionAttributes['relative-y']}. */
    Function.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    Function.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Function.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Function.schema = {
        name: 'function',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Function;
}());
exports.Function = Function;
/**
 * The `<kind>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<kind>` element indicates the type of chord. The `<degree>` elements can then add, subtract, or alter from these
 * starting points
 *
 * The attributes are used to indicate the formatting of the symbol. Since the `<kind>` element is the constant in all
 * the harmony-chord element groups that can make up a polychord, many formatting attributes are here. The alignment
 * attributes are for the entire harmony-chord group of which this kind element is a part.
 *
 * For the major-minor `<kind>`, only the minor symbol is used when use-symbols is yes. The major symbol is set using
 * the symbol attribute in the `<degree-value>` element. The corresponding `<degree-alter>` value will usually be 0 in
 * this case.
 *
 * The text attribute may use strings such as "13sus" that refer to both the kind and one or more `<degree>` elements.
 * In this case, the corresponding `<degree>` elements should have the print-object attribute set to no to keep
 * redundant alterations from being displayed.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/kind/}
 */
var Kind = /** @class */ (function () {
    function Kind(opts) {
        var _a;
        this.schema = Kind.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Kind.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Kind.schema.contents);
    }
    /** Gets @type {KindAttributes['bracket-degrees']}. */
    Kind.prototype.getBracketDegrees = function () {
        return this.attributes['bracket-degrees'];
    };
    /** Sets @type {KindAttributes['bracket-degrees']}. */
    Kind.prototype.setBracketDegrees = function (bracketDegrees) {
        this.attributes['bracket-degrees'] = bracketDegrees;
        return this;
    };
    /** Gets @type {KindAttributes['color']}. */
    Kind.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {KindAttributes['color']}. */
    Kind.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {KindAttributes['default-x']}. */
    Kind.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {KindAttributes['default-x']}. */
    Kind.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {KindAttributes['default-y']}. */
    Kind.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {KindAttributes['default-y']}. */
    Kind.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {KindAttributes['font-family']}. */
    Kind.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {KindAttributes['font-family']}. */
    Kind.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {KindAttributes['font-size']}. */
    Kind.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {KindAttributes['font-size']}. */
    Kind.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {KindAttributes['font-style']}. */
    Kind.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {KindAttributes['font-style']}. */
    Kind.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {KindAttributes['font-weight']}. */
    Kind.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {KindAttributes['font-weight']}. */
    Kind.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {KindAttributes['halign']}. */
    Kind.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {KindAttributes['halign']}. */
    Kind.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {KindAttributes['parentheses-degrees']}. */
    Kind.prototype.getParenthesesDegrees = function () {
        return this.attributes['parentheses-degrees'];
    };
    /** Sets @type {KindAttributes['parentheses-degrees']}. */
    Kind.prototype.setParenthesesDegrees = function (parenthesesDegrees) {
        this.attributes['parentheses-degrees'] = parenthesesDegrees;
        return this;
    };
    /** Gets @type {KindAttributes['relative-x']}. */
    Kind.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {KindAttributes['relative-x']}. */
    Kind.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {KindAttributes['relative-y']}. */
    Kind.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {KindAttributes['relative-y']}. */
    Kind.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {KindAttributes['stack-degrees']}. */
    Kind.prototype.getStackDegrees = function () {
        return this.attributes['stack-degrees'];
    };
    /** Sets @type {KindAttributes['stack-degrees']}. */
    Kind.prototype.setStackDegrees = function (stackDegrees) {
        this.attributes['stack-degrees'] = stackDegrees;
        return this;
    };
    /** Gets @type {KindAttributes['text']}. */
    Kind.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {KindAttributes['text']}. */
    Kind.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {KindAttributes['use-symbols']}. */
    Kind.prototype.getUseSymbols = function () {
        return this.attributes['use-symbols'];
    };
    /** Sets @type {KindAttributes['use-symbols']}. */
    Kind.prototype.setUseSymbols = function (useSymbols) {
        this.attributes['use-symbols'] = useSymbols;
        return this;
    };
    /** Gets @type {KindAttributes['valign']}. */
    Kind.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {KindAttributes['valign']}. */
    Kind.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {'none' | 'augmented' | 'augmented-seventh' | 'diminished' | 'diminished-seventh' | 'dominant' | 'dominant-11th' | 'dominant-13th' | 'dominant-ninth' | 'French' | 'German' | 'half-diminished' | 'Italian' | 'major' | 'major-11th' | 'major-13th' | 'major-minor' | 'major-ninth' | 'major-seventh' | 'major-sixth' | 'minor' | 'minor-11th' | 'minor-13th' | 'minor-ninth' | 'minor-seventh' | 'minor-sixth' | 'Neapolitan' | 'other' | 'pedal' | 'power' | 'suspended-fourth' | 'suspended-second' | 'Tristan'}. */
    Kind.prototype.getKindValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'none' | 'augmented' | 'augmented-seventh' | 'diminished' | 'diminished-seventh' | 'dominant' | 'dominant-11th' | 'dominant-13th' | 'dominant-ninth' | 'French' | 'German' | 'half-diminished' | 'Italian' | 'major' | 'major-11th' | 'major-13th' | 'major-minor' | 'major-ninth' | 'major-seventh' | 'major-sixth' | 'minor' | 'minor-11th' | 'minor-13th' | 'minor-ninth' | 'minor-seventh' | 'minor-sixth' | 'Neapolitan' | 'other' | 'pedal' | 'power' | 'suspended-fourth' | 'suspended-second' | 'Tristan'}. */
    Kind.prototype.setKindValue = function (kindValue) {
        this.contents[0] = kindValue;
        return this;
    };
    Kind.schema = {
        name: 'kind',
        attributes: {
            'bracket-degrees': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'parentheses-degrees': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'stack-degrees': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            text: { type: 'optional', value: { type: 'string' } },
            'use-symbols': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'kind-value',
                    value: {
                        type: 'choices',
                        choices: [
                            'none',
                            'augmented',
                            'augmented-seventh',
                            'diminished',
                            'diminished-seventh',
                            'dominant',
                            'dominant-11th',
                            'dominant-13th',
                            'dominant-ninth',
                            'French',
                            'German',
                            'half-diminished',
                            'Italian',
                            'major',
                            'major-11th',
                            'major-13th',
                            'major-minor',
                            'major-ninth',
                            'major-seventh',
                            'major-sixth',
                            'minor',
                            'minor-11th',
                            'minor-13th',
                            'minor-ninth',
                            'minor-seventh',
                            'minor-sixth',
                            'Neapolitan',
                            'other',
                            'pedal',
                            'power',
                            'suspended-fourth',
                            'suspended-second',
                            'Tristan',
                        ],
                    },
                },
            },
        ],
    };
    return Kind;
}());
exports.Kind = Kind;
/**
 * The `<inversion>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<inversion>` element represents harmony inversions. The value is a number indicating which inversion is used: 0
 * for root position, 1 for first inversion, etc.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/inversion/}
 */
var Inversion = /** @class */ (function () {
    function Inversion(opts) {
        var _a;
        this.schema = Inversion.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Inversion.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Inversion.schema.contents);
    }
    /** Gets @type {InversionAttributes['color']}. */
    Inversion.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {InversionAttributes['color']}. */
    Inversion.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {InversionAttributes['default-x']}. */
    Inversion.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {InversionAttributes['default-x']}. */
    Inversion.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {InversionAttributes['default-y']}. */
    Inversion.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {InversionAttributes['default-y']}. */
    Inversion.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {InversionAttributes['font-family']}. */
    Inversion.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {InversionAttributes['font-family']}. */
    Inversion.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {InversionAttributes['font-size']}. */
    Inversion.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {InversionAttributes['font-size']}. */
    Inversion.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {InversionAttributes['font-style']}. */
    Inversion.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {InversionAttributes['font-style']}. */
    Inversion.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {InversionAttributes['font-weight']}. */
    Inversion.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {InversionAttributes['font-weight']}. */
    Inversion.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {InversionAttributes['relative-x']}. */
    Inversion.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {InversionAttributes['relative-x']}. */
    Inversion.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {InversionAttributes['relative-y']}. */
    Inversion.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {InversionAttributes['relative-y']}. */
    Inversion.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {InversionAttributes['text']}. */
    Inversion.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {InversionAttributes['text']}. */
    Inversion.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {number}. */
    Inversion.prototype.getInversion = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    Inversion.prototype.setInversion = function (inversion) {
        this.contents[0] = inversion;
        return this;
    };
    Inversion.schema = {
        name: 'inversion',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            text: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            { type: 'label', label: 'inversion', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
        ],
    };
    return Inversion;
}());
exports.Inversion = Inversion;
/**
 * The `<bass-separator>` element
 *
 * Parent element: `<bass>`
 *
 * The `<bass-separator>` element indicates that text, rather than a line or slash, separates the bass from what
 * precedes it.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bass-separator/}
 */
var BassSeparator = /** @class */ (function () {
    function BassSeparator(opts) {
        var _a;
        this.schema = BassSeparator.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BassSeparator.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BassSeparator.schema.contents);
    }
    /** Gets @type {BassSeparatorAttributes['color']}. */
    BassSeparator.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {BassSeparatorAttributes['color']}. */
    BassSeparator.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {BassSeparatorAttributes['default-x']}. */
    BassSeparator.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {BassSeparatorAttributes['default-x']}. */
    BassSeparator.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {BassSeparatorAttributes['default-y']}. */
    BassSeparator.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {BassSeparatorAttributes['default-y']}. */
    BassSeparator.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {BassSeparatorAttributes['font-family']}. */
    BassSeparator.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {BassSeparatorAttributes['font-family']}. */
    BassSeparator.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {BassSeparatorAttributes['font-size']}. */
    BassSeparator.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {BassSeparatorAttributes['font-size']}. */
    BassSeparator.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {BassSeparatorAttributes['font-style']}. */
    BassSeparator.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {BassSeparatorAttributes['font-style']}. */
    BassSeparator.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {BassSeparatorAttributes['font-weight']}. */
    BassSeparator.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {BassSeparatorAttributes['font-weight']}. */
    BassSeparator.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {BassSeparatorAttributes['relative-x']}. */
    BassSeparator.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {BassSeparatorAttributes['relative-x']}. */
    BassSeparator.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {BassSeparatorAttributes['relative-y']}. */
    BassSeparator.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {BassSeparatorAttributes['relative-y']}. */
    BassSeparator.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    BassSeparator.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    BassSeparator.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    BassSeparator.schema = {
        name: 'bass-separator',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return BassSeparator;
}());
exports.BassSeparator = BassSeparator;
/**
 * The `<bass-step>` element
 *
 * Parent element: `<bass>`
 *
 * The `<bass-step>` element represents the pitch step of the bass of the current chord within the harmony element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bass-step/}
 */
var BassStep = /** @class */ (function () {
    function BassStep(opts) {
        var _a;
        this.schema = BassStep.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BassStep.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BassStep.schema.contents);
    }
    /** Gets @type {BassStepAttributes['color']}. */
    BassStep.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {BassStepAttributes['color']}. */
    BassStep.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {BassStepAttributes['default-x']}. */
    BassStep.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {BassStepAttributes['default-x']}. */
    BassStep.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {BassStepAttributes['default-y']}. */
    BassStep.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {BassStepAttributes['default-y']}. */
    BassStep.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {BassStepAttributes['font-family']}. */
    BassStep.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {BassStepAttributes['font-family']}. */
    BassStep.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {BassStepAttributes['font-size']}. */
    BassStep.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {BassStepAttributes['font-size']}. */
    BassStep.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {BassStepAttributes['font-style']}. */
    BassStep.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {BassStepAttributes['font-style']}. */
    BassStep.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {BassStepAttributes['font-weight']}. */
    BassStep.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {BassStepAttributes['font-weight']}. */
    BassStep.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {BassStepAttributes['relative-x']}. */
    BassStep.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {BassStepAttributes['relative-x']}. */
    BassStep.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {BassStepAttributes['relative-y']}. */
    BassStep.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {BassStepAttributes['relative-y']}. */
    BassStep.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {BassStepAttributes['text']}. */
    BassStep.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {BassStepAttributes['text']}. */
    BassStep.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    BassStep.prototype.getStep = function () {
        return this.contents[0];
    };
    /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
    BassStep.prototype.setStep = function (step) {
        this.contents[0] = step;
        return this;
    };
    BassStep.schema = {
        name: 'bass-step',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            text: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'step',
                    value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
                },
            },
        ],
    };
    return BassStep;
}());
exports.BassStep = BassStep;
/**
 * The `<bass-alter>` element
 *
 * Parent element: `<bass>`
 *
 * The `<bass-alter>` element represents the chromatic alteration of the `<bass>` of the current chord within the
 * `<harmony>` element. In some chord styles, the text for the `<bass-step>` element may include `<bass-alter>`
 * information. In that case, the print-object attribute of the `<bass-alter>` element can be set to no.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bass-alter/}
 */
var BassAlter = /** @class */ (function () {
    function BassAlter(opts) {
        var _a;
        this.schema = BassAlter.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BassAlter.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BassAlter.schema.contents);
    }
    /** Gets @type {BassAlterAttributes['color']}. */
    BassAlter.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {BassAlterAttributes['color']}. */
    BassAlter.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {BassAlterAttributes['default-x']}. */
    BassAlter.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {BassAlterAttributes['default-x']}. */
    BassAlter.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {BassAlterAttributes['default-y']}. */
    BassAlter.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {BassAlterAttributes['default-y']}. */
    BassAlter.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {BassAlterAttributes['font-family']}. */
    BassAlter.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {BassAlterAttributes['font-family']}. */
    BassAlter.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {BassAlterAttributes['font-size']}. */
    BassAlter.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {BassAlterAttributes['font-size']}. */
    BassAlter.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {BassAlterAttributes['font-style']}. */
    BassAlter.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {BassAlterAttributes['font-style']}. */
    BassAlter.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {BassAlterAttributes['font-weight']}. */
    BassAlter.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {BassAlterAttributes['font-weight']}. */
    BassAlter.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {BassAlterAttributes['location']}. */
    BassAlter.prototype.getLocation = function () {
        return this.attributes['location'];
    };
    /** Sets @type {BassAlterAttributes['location']}. */
    BassAlter.prototype.setLocation = function (location) {
        this.attributes['location'] = location;
        return this;
    };
    /** Gets @type {BassAlterAttributes['print-object']}. */
    BassAlter.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {BassAlterAttributes['print-object']}. */
    BassAlter.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {BassAlterAttributes['relative-x']}. */
    BassAlter.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {BassAlterAttributes['relative-x']}. */
    BassAlter.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {BassAlterAttributes['relative-y']}. */
    BassAlter.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {BassAlterAttributes['relative-y']}. */
    BassAlter.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {number}. */
    BassAlter.prototype.getSemitones = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    BassAlter.prototype.setSemitones = function (semitones) {
        this.contents[0] = semitones;
        return this;
    };
    BassAlter.schema = {
        name: 'bass-alter',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [
            {
                type: 'required',
                value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return BassAlter;
}());
exports.BassAlter = BassAlter;
/**
 * The `<bass>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<bass>` element is used to indicate a bass note in popular music chord symbols, e.g. G/C. It is generally not
 * used in functional harmony, as inversion is generally not used in pop chord symbols. As with `<root>`, it is divided
 * into step and alter elements, similar to pitches.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bass/}
 */
var Bass = /** @class */ (function () {
    function Bass(opts) {
        var _a;
        this.schema = Bass.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Bass.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Bass.schema.contents);
    }
    /** Gets @type {BassAttributes['arrangement']}. */
    Bass.prototype.getArrangement = function () {
        return this.attributes['arrangement'];
    };
    /** Sets @type {BassAttributes['arrangement']}. */
    Bass.prototype.setArrangement = function (arrangement) {
        this.attributes['arrangement'] = arrangement;
        return this;
    };
    /** Gets @type {BassSeparator | null}. */
    Bass.prototype.getBassSeparator = function () {
        return this.contents[0];
    };
    /** Sets @type {BassSeparator | null}. */
    Bass.prototype.setBassSeparator = function (bassSeparator) {
        this.contents[0] = bassSeparator;
        return this;
    };
    /** Gets @type {BassStep}. */
    Bass.prototype.getBassStep = function () {
        return this.contents[1];
    };
    /** Sets @type {BassStep}. */
    Bass.prototype.setBassStep = function (bassStep) {
        this.contents[1] = bassStep;
        return this;
    };
    /** Gets @type {BassAlter | null}. */
    Bass.prototype.getBassAlter = function () {
        return this.contents[2];
    };
    /** Sets @type {BassAlter | null}. */
    Bass.prototype.setBassAlter = function (bassAlter) {
        this.contents[2] = bassAlter;
        return this;
    };
    Bass.schema = {
        name: 'bass',
        attributes: {
            arrangement: { type: 'optional', value: { type: 'choices', choices: ['horizontal', 'vertical', 'diagonal'] } },
        },
        contents: [
            { type: 'optional', value: BassSeparator },
            { type: 'required', value: BassStep },
            { type: 'optional', value: BassAlter },
        ],
    };
    return Bass;
}());
exports.Bass = Bass;
/**
 * The `<degree-value>` element
 *
 * Parent element: `<degree>`
 *
 * The content of the `<degree-value>` element is a number indicating the degree of the chord (1 for the root, 3 for
 * third, etc).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/degree-value/}
 */
var DegreeValue = /** @class */ (function () {
    function DegreeValue(opts) {
        var _a;
        this.schema = DegreeValue.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DegreeValue.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DegreeValue.schema.contents);
    }
    /** Gets @type {DegreeValueAttributes['color']}. */
    DegreeValue.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DegreeValueAttributes['color']}. */
    DegreeValue.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DegreeValueAttributes['default-x']}. */
    DegreeValue.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DegreeValueAttributes['default-x']}. */
    DegreeValue.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DegreeValueAttributes['default-y']}. */
    DegreeValue.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DegreeValueAttributes['default-y']}. */
    DegreeValue.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DegreeValueAttributes['font-family']}. */
    DegreeValue.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DegreeValueAttributes['font-family']}. */
    DegreeValue.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DegreeValueAttributes['font-size']}. */
    DegreeValue.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DegreeValueAttributes['font-size']}. */
    DegreeValue.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DegreeValueAttributes['font-style']}. */
    DegreeValue.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DegreeValueAttributes['font-style']}. */
    DegreeValue.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DegreeValueAttributes['font-weight']}. */
    DegreeValue.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DegreeValueAttributes['font-weight']}. */
    DegreeValue.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DegreeValueAttributes['relative-x']}. */
    DegreeValue.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DegreeValueAttributes['relative-x']}. */
    DegreeValue.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DegreeValueAttributes['relative-y']}. */
    DegreeValue.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DegreeValueAttributes['relative-y']}. */
    DegreeValue.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DegreeValueAttributes['symbol']}. */
    DegreeValue.prototype.getSymbol = function () {
        return this.attributes['symbol'];
    };
    /** Sets @type {DegreeValueAttributes['symbol']}. */
    DegreeValue.prototype.setSymbol = function (symbol) {
        this.attributes['symbol'] = symbol;
        return this;
    };
    /** Gets @type {DegreeValueAttributes['text']}. */
    DegreeValue.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {DegreeValueAttributes['text']}. */
    DegreeValue.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {number}. */
    DegreeValue.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    DegreeValue.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    DegreeValue.schema = {
        name: 'degree-value',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            symbol: {
                type: 'optional',
                value: { type: 'choices', choices: ['major', 'minor', 'augmented', 'diminished', 'half-diminished'] },
            },
            text: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
        ],
    };
    return DegreeValue;
}());
exports.DegreeValue = DegreeValue;
/**
 * The `<degree-alter>` element
 *
 * Parent element: `<degree>`
 *
 * The `<degree-alter>` element represents the chromatic alteration for the current degree. If the `<degree-type>` value
 * is alter or subtract, the `<degree-alter>` value is relative to the degree already in the chord based on its kind
 * element. If the `<degree-type>` value is add, the `<degree-alter>` is relative to a dominant chord (major and perfect
 * intervals except for a minor seventh).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/degree-alter/}
 */
var DegreeAlter = /** @class */ (function () {
    function DegreeAlter(opts) {
        var _a;
        this.schema = DegreeAlter.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DegreeAlter.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DegreeAlter.schema.contents);
    }
    /** Gets @type {DegreeAlterAttributes['color']}. */
    DegreeAlter.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DegreeAlterAttributes['color']}. */
    DegreeAlter.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DegreeAlterAttributes['default-x']}. */
    DegreeAlter.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DegreeAlterAttributes['default-x']}. */
    DegreeAlter.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DegreeAlterAttributes['default-y']}. */
    DegreeAlter.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DegreeAlterAttributes['default-y']}. */
    DegreeAlter.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DegreeAlterAttributes['font-family']}. */
    DegreeAlter.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DegreeAlterAttributes['font-family']}. */
    DegreeAlter.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DegreeAlterAttributes['font-size']}. */
    DegreeAlter.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DegreeAlterAttributes['font-size']}. */
    DegreeAlter.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DegreeAlterAttributes['font-style']}. */
    DegreeAlter.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DegreeAlterAttributes['font-style']}. */
    DegreeAlter.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DegreeAlterAttributes['font-weight']}. */
    DegreeAlter.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DegreeAlterAttributes['font-weight']}. */
    DegreeAlter.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DegreeAlterAttributes['plus-minus']}. */
    DegreeAlter.prototype.getPlusMinus = function () {
        return this.attributes['plus-minus'];
    };
    /** Sets @type {DegreeAlterAttributes['plus-minus']}. */
    DegreeAlter.prototype.setPlusMinus = function (plusMinus) {
        this.attributes['plus-minus'] = plusMinus;
        return this;
    };
    /** Gets @type {DegreeAlterAttributes['relative-x']}. */
    DegreeAlter.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DegreeAlterAttributes['relative-x']}. */
    DegreeAlter.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DegreeAlterAttributes['relative-y']}. */
    DegreeAlter.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DegreeAlterAttributes['relative-y']}. */
    DegreeAlter.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {number}. */
    DegreeAlter.prototype.getSemitones = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    DegreeAlter.prototype.setSemitones = function (semitones) {
        this.contents[0] = semitones;
        return this;
    };
    DegreeAlter.schema = {
        name: 'degree-alter',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'plus-minus': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } }],
    };
    return DegreeAlter;
}());
exports.DegreeAlter = DegreeAlter;
/**
 * The `<degree-type>` element
 *
 * Parent element: `<degree>`
 *
 * The `<degree-type>` element indicates if this degree is an addition, alteration, or subtraction relative to the
 * `<kind>` of the current chord. The value of the `<degree-type>` element affects the interpretation of the value of
 * the `<degree-alter>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/degree-type/}
 */
var DegreeType = /** @class */ (function () {
    function DegreeType(opts) {
        var _a;
        this.schema = DegreeType.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, DegreeType.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(DegreeType.schema.contents);
    }
    /** Gets @type {DegreeTypeAttributes['color']}. */
    DegreeType.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {DegreeTypeAttributes['color']}. */
    DegreeType.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {DegreeTypeAttributes['default-x']}. */
    DegreeType.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {DegreeTypeAttributes['default-x']}. */
    DegreeType.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {DegreeTypeAttributes['default-y']}. */
    DegreeType.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {DegreeTypeAttributes['default-y']}. */
    DegreeType.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {DegreeTypeAttributes['font-family']}. */
    DegreeType.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {DegreeTypeAttributes['font-family']}. */
    DegreeType.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {DegreeTypeAttributes['font-size']}. */
    DegreeType.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {DegreeTypeAttributes['font-size']}. */
    DegreeType.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {DegreeTypeAttributes['font-style']}. */
    DegreeType.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {DegreeTypeAttributes['font-style']}. */
    DegreeType.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {DegreeTypeAttributes['font-weight']}. */
    DegreeType.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {DegreeTypeAttributes['font-weight']}. */
    DegreeType.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {DegreeTypeAttributes['relative-x']}. */
    DegreeType.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {DegreeTypeAttributes['relative-x']}. */
    DegreeType.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {DegreeTypeAttributes['relative-y']}. */
    DegreeType.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {DegreeTypeAttributes['relative-y']}. */
    DegreeType.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {DegreeTypeAttributes['text']}. */
    DegreeType.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {DegreeTypeAttributes['text']}. */
    DegreeType.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {'add' | 'alter' | 'subtract'}. */
    DegreeType.prototype.getDegreeTypeValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'add' | 'alter' | 'subtract'}. */
    DegreeType.prototype.setDegreeTypeValue = function (degreeTypeValue) {
        this.contents[0] = degreeTypeValue;
        return this;
    };
    DegreeType.schema = {
        name: 'degree-type',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            text: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'degree-type-value',
                    value: { type: 'choices', choices: ['add', 'alter', 'subtract'] },
                },
            },
        ],
    };
    return DegreeType;
}());
exports.DegreeType = DegreeType;
/**
 * The `<degree>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<degree>` element is used to add, alter, or subtract individual notes in the chord. The print-object attribute
 * can be used to keep the degree from printing separately when it has already taken into account in the text attribute
 * of the `<kind>` element.
 *
 * A harmony with a `<kind>` value of other can be spelled explicitly by using a series of `<degree>` elements together
 * with a `<root>`, `<numeral>`, or `<function>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/degree/}
 */
var Degree = /** @class */ (function () {
    function Degree(opts) {
        var _a;
        this.schema = Degree.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Degree.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Degree.schema.contents);
    }
    /** Gets @type {DegreeAttributes['print-object']}. */
    Degree.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {DegreeAttributes['print-object']}. */
    Degree.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {DegreeValue}. */
    Degree.prototype.getDegreeValue = function () {
        return this.contents[0];
    };
    /** Sets @type {DegreeValue}. */
    Degree.prototype.setDegreeValue = function (degreeValue) {
        this.contents[0] = degreeValue;
        return this;
    };
    /** Gets @type {DegreeAlter}. */
    Degree.prototype.getDegreeAlter = function () {
        return this.contents[1];
    };
    /** Sets @type {DegreeAlter}. */
    Degree.prototype.setDegreeAlter = function (degreeAlter) {
        this.contents[1] = degreeAlter;
        return this;
    };
    /** Gets @type {DegreeType}. */
    Degree.prototype.getDegreeType = function () {
        return this.contents[2];
    };
    /** Sets @type {DegreeType}. */
    Degree.prototype.setDegreeType = function (degreeType) {
        this.contents[2] = degreeType;
        return this;
    };
    Degree.schema = {
        name: 'degree',
        attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
        contents: [
            { type: 'required', value: DegreeValue },
            { type: 'required', value: DegreeAlter },
            { type: 'required', value: DegreeType },
        ],
    };
    return Degree;
}());
exports.Degree = Degree;
/**
 * The `<frame-strings>` element
 *
 * Parent element: `<frame>`
 *
 * The `<frame-strings>` element gives the overall size of the frame in vertical lines (strings).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/frame-strings/}
 */
var FrameStrings = /** @class */ (function () {
    function FrameStrings(opts) {
        var _a;
        this.schema = FrameStrings.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, FrameStrings.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(FrameStrings.schema.contents);
    }
    /** Gets @type {number}. */
    FrameStrings.prototype.getLinesSize = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    FrameStrings.prototype.setLinesSize = function (linesSize) {
        this.contents[0] = linesSize;
        return this;
    };
    FrameStrings.schema = {
        name: 'frame-strings',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'lines-size',
                value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
            },
        ],
    };
    return FrameStrings;
}());
exports.FrameStrings = FrameStrings;
/**
 * The `<frame-frets>` element
 *
 * Parent element: `<frame>`
 *
 * The frame-frets element gives the overall size of the frame in horizontal spaces (frets).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/frame-frets/}
 */
var FrameFrets = /** @class */ (function () {
    function FrameFrets(opts) {
        var _a;
        this.schema = FrameFrets.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, FrameFrets.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(FrameFrets.schema.contents);
    }
    /** Gets @type {number}. */
    FrameFrets.prototype.getSpaceSize = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    FrameFrets.prototype.setSpaceSize = function (spaceSize) {
        this.contents[0] = spaceSize;
        return this;
    };
    FrameFrets.schema = {
        name: 'frame-frets',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'space-size',
                value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
            },
        ],
    };
    return FrameFrets;
}());
exports.FrameFrets = FrameFrets;
/**
 * The `<first-fret>` element
 *
 * Parent element: `<frame>`
 *
 * The `<first-fret>` element indicates which fret is shown in the top space of the frame; it is fret 1 if the element
 * is not present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/first-fret/}
 */
var FirstFret = /** @class */ (function () {
    function FirstFret(opts) {
        var _a;
        this.schema = FirstFret.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, FirstFret.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(FirstFret.schema.contents);
    }
    /** Gets @type {FirstFretAttributes['location']}. */
    FirstFret.prototype.getLocation = function () {
        return this.attributes['location'];
    };
    /** Sets @type {FirstFretAttributes['location']}. */
    FirstFret.prototype.setLocation = function (location) {
        this.attributes['location'] = location;
        return this;
    };
    /** Gets @type {FirstFretAttributes['text']}. */
    FirstFret.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {FirstFretAttributes['text']}. */
    FirstFret.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {number}. */
    FirstFret.prototype.getFret = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    FirstFret.prototype.setFret = function (fret) {
        this.contents[0] = fret;
        return this;
    };
    FirstFret.schema = {
        name: 'first-fret',
        attributes: {
            location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
            text: { type: 'optional', value: { type: 'string' } },
        },
        contents: [
            { type: 'label', label: 'fret', value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
        ],
    };
    return FirstFret;
}());
exports.FirstFret = FirstFret;
/**
 * The `<barre>` element
 *
 * Parent element: `<frame-note>`
 *
 * The `<barre>` element indicates placing a finger over multiple strings on a single fret.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/barre/}
 */
var Barre = /** @class */ (function () {
    function Barre(opts) {
        var _a;
        this.schema = Barre.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Barre.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Barre.schema.contents);
    }
    /** Gets @type {BarreAttributes['type']}. */
    Barre.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {BarreAttributes['type']}. */
    Barre.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {BarreAttributes['color']}. */
    Barre.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {BarreAttributes['color']}. */
    Barre.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    Barre.schema = {
        name: 'barre',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
        },
        contents: [],
    };
    return Barre;
}());
exports.Barre = Barre;
/**
 * The `<frame-note>` element
 *
 * Parent element: `<frame>`
 *
 * The frame-note type represents each note included in the frame. An open string will have a fret value of 0, while a
 * muted string will not be associated with a frame-note element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/frame-note/}
 */
var FrameNote = /** @class */ (function () {
    function FrameNote(opts) {
        var _a;
        this.schema = FrameNote.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, FrameNote.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(FrameNote.schema.contents);
    }
    /** Gets @type {String}. */
    FrameNote.prototype.getString = function () {
        return this.contents[0];
    };
    /** Sets @type {String}. */
    FrameNote.prototype.setString = function (string) {
        this.contents[0] = string;
        return this;
    };
    /** Gets @type {Fret}. */
    FrameNote.prototype.getFret = function () {
        return this.contents[1];
    };
    /** Sets @type {Fret}. */
    FrameNote.prototype.setFret = function (fret) {
        this.contents[1] = fret;
        return this;
    };
    /** Gets @type {Fingering | null}. */
    FrameNote.prototype.getFingering = function () {
        return this.contents[2];
    };
    /** Sets @type {Fingering | null}. */
    FrameNote.prototype.setFingering = function (fingering) {
        this.contents[2] = fingering;
        return this;
    };
    /** Gets @type {Barre | null}. */
    FrameNote.prototype.getBarre = function () {
        return this.contents[3];
    };
    /** Sets @type {Barre | null}. */
    FrameNote.prototype.setBarre = function (barre) {
        this.contents[3] = barre;
        return this;
    };
    FrameNote.schema = {
        name: 'frame-note',
        attributes: {},
        contents: [
            { type: 'required', value: String },
            { type: 'required', value: Fret },
            { type: 'optional', value: Fingering },
            { type: 'optional', value: Barre },
        ],
    };
    return FrameNote;
}());
exports.FrameNote = FrameNote;
/**
 * The `<frame>` element
 *
 * Parent element: `<harmony>`
 *
 * The frame type represents a frame or fretboard diagram used together with a chord symbol. The representation is based on the NIFF guitar grid with additional information. The frame type's unplayed attribute indicates what to display above a string that has no associated frame-note element. Typical values are x and the empty string. If the attribute is not present, the display of the unplayed string is application-defined.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/frame/}
 */
var Frame = /** @class */ (function () {
    function Frame(opts) {
        var _a;
        this.schema = Frame.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Frame.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Frame.schema.contents);
    }
    /** Gets @type {FrameAttributes['color']}. */
    Frame.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FrameAttributes['color']}. */
    Frame.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FrameAttributes['default-x']}. */
    Frame.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {FrameAttributes['default-x']}. */
    Frame.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {FrameAttributes['default-y']}. */
    Frame.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {FrameAttributes['default-y']}. */
    Frame.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {FrameAttributes['halign']}. */
    Frame.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {FrameAttributes['halign']}. */
    Frame.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {FrameAttributes['height']}. */
    Frame.prototype.getHeight = function () {
        return this.attributes['height'];
    };
    /** Sets @type {FrameAttributes['height']}. */
    Frame.prototype.setHeight = function (height) {
        this.attributes['height'] = height;
        return this;
    };
    /** Gets @type {FrameAttributes['id']}. */
    Frame.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {FrameAttributes['id']}. */
    Frame.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {FrameAttributes['font-family']}. */
    Frame.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FrameAttributes['font-family']}. */
    Frame.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FrameAttributes['font-size']}. */
    Frame.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FrameAttributes['font-size']}. */
    Frame.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FrameAttributes['font-style']}. */
    Frame.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FrameAttributes['font-style']}. */
    Frame.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FrameAttributes['font-weight']}. */
    Frame.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FrameAttributes['font-weight']}. */
    Frame.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {FrameAttributes['relative-x']}. */
    Frame.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {FrameAttributes['relative-x']}. */
    Frame.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {FrameAttributes['relative-y']}. */
    Frame.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {FrameAttributes['relative-y']}. */
    Frame.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {FrameAttributes['unplayed']}. */
    Frame.prototype.getUnplayed = function () {
        return this.attributes['unplayed'];
    };
    /** Sets @type {FrameAttributes['unplayed']}. */
    Frame.prototype.setUnplayed = function (unplayed) {
        this.attributes['unplayed'] = unplayed;
        return this;
    };
    /** Gets @type {FrameAttributes['valign']}. */
    Frame.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {FrameAttributes['valign']}. */
    Frame.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {FrameAttributes['width']}. */
    Frame.prototype.getWidth = function () {
        return this.attributes['width'];
    };
    /** Sets @type {FrameAttributes['width']}. */
    Frame.prototype.setWidth = function (width) {
        this.attributes['width'] = width;
        return this;
    };
    /** Gets @type {FrameStrings}. */
    Frame.prototype.getFrameStrings = function () {
        return this.contents[0];
    };
    /** Sets @type {FrameStrings}. */
    Frame.prototype.setFrameStrings = function (frameStrings) {
        this.contents[0] = frameStrings;
        return this;
    };
    /** Gets @type {FrameFrets}. */
    Frame.prototype.getFrameFrets = function () {
        return this.contents[1];
    };
    /** Sets @type {FrameFrets}. */
    Frame.prototype.setFrameFrets = function (frameFrets) {
        this.contents[1] = frameFrets;
        return this;
    };
    /** Gets @type {FirstFret | null}. */
    Frame.prototype.getFirstFret = function () {
        return this.contents[2];
    };
    /** Sets @type {FirstFret | null}. */
    Frame.prototype.setFirstFret = function (firstFret) {
        this.contents[2] = firstFret;
        return this;
    };
    /** Gets @type {Array<FrameNote>}. */
    Frame.prototype.getFrameNotes = function () {
        return this.contents[3];
    };
    /** Sets @type {Array<FrameNote>}. */
    Frame.prototype.setFrameNotes = function (frameNotes) {
        this.contents[3] = frameNotes;
        return this;
    };
    Frame.schema = {
        name: 'frame',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            height: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            unplayed: { type: 'optional', value: { type: 'string' } },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom'] } },
            width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [
            { type: 'required', value: FrameStrings },
            { type: 'required', value: FrameFrets },
            { type: 'optional', value: FirstFret },
            { type: 'label', label: 'frame-notes', value: { type: 'oneOrMore', value: FrameNote } },
        ],
    };
    return Frame;
}());
exports.Frame = Frame;
/**
 * The `<harmony>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<harmony>` element represents harmony analysis, including chord symbols in popular music as well as functional
 * harmony analysis in classical music.
 *
 * The print-object attribute controls whether or not anything is printed due to the `<harmony>` element. The print
 * suggestion attributes set the defaults for the harmony, but individual elements can override this with their own
 * values.
 *
 * A `<harmony>` element can contain many stacked chords (e.g. V of II). Each individual chord including a required
 * `<kind>` element is referred to as a harmony-chord. Stacked chords or secondary functions are represented using a
 * sequence of harmony-chords. For example, V of II would be represented by a harmony-chord with a 5 numeral followed by
 * a harmony-chord with a 2 numeral.
 *
 * A `<root>` is a pitch name like C, D, E, while a `<numeral>` is a scale degree like 1, 2, 3. The `<root>` element is
 * generally used with pop chord symbols, while the `<numeral>` element is generally used with classical functional
 * harmony and Nashville numbers. It is an either/or choice to avoid data inconsistency. The `<function>` element, which
 * represents Roman numerals with roman numeral text, has been deprecated as of MusicXML 4.0.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/harmony/}
 */
var Harmony = /** @class */ (function () {
    function Harmony(opts) {
        var _a;
        this.schema = Harmony.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Harmony.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Harmony.schema.contents);
    }
    /** Gets @type {HarmonyAttributes['arrangement']}. */
    Harmony.prototype.getArrangement = function () {
        return this.attributes['arrangement'];
    };
    /** Sets @type {HarmonyAttributes['arrangement']}. */
    Harmony.prototype.setArrangement = function (arrangement) {
        this.attributes['arrangement'] = arrangement;
        return this;
    };
    /** Gets @type {HarmonyAttributes['color']}. */
    Harmony.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {HarmonyAttributes['color']}. */
    Harmony.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {HarmonyAttributes['default-x']}. */
    Harmony.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {HarmonyAttributes['default-x']}. */
    Harmony.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {HarmonyAttributes['default-y']}. */
    Harmony.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {HarmonyAttributes['default-y']}. */
    Harmony.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {HarmonyAttributes['font-family']}. */
    Harmony.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {HarmonyAttributes['font-family']}. */
    Harmony.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {HarmonyAttributes['font-size']}. */
    Harmony.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {HarmonyAttributes['font-size']}. */
    Harmony.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {HarmonyAttributes['font-style']}. */
    Harmony.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {HarmonyAttributes['font-style']}. */
    Harmony.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {HarmonyAttributes['font-weight']}. */
    Harmony.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {HarmonyAttributes['font-weight']}. */
    Harmony.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {HarmonyAttributes['id']}. */
    Harmony.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {HarmonyAttributes['id']}. */
    Harmony.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {HarmonyAttributes['placement']}. */
    Harmony.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {HarmonyAttributes['placement']}. */
    Harmony.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {HarmonyAttributes['print-frame']}. */
    Harmony.prototype.getPrintFrame = function () {
        return this.attributes['print-frame'];
    };
    /** Sets @type {HarmonyAttributes['print-frame']}. */
    Harmony.prototype.setPrintFrame = function (printFrame) {
        this.attributes['print-frame'] = printFrame;
        return this;
    };
    /** Gets @type {HarmonyAttributes['print-object']}. */
    Harmony.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {HarmonyAttributes['print-object']}. */
    Harmony.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {HarmonyAttributes['relative-x']}. */
    Harmony.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {HarmonyAttributes['relative-x']}. */
    Harmony.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {HarmonyAttributes['relative-y']}. */
    Harmony.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {HarmonyAttributes['relative-y']}. */
    Harmony.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {HarmonyAttributes['system']}. */
    Harmony.prototype.getSystem = function () {
        return this.attributes['system'];
    };
    /** Sets @type {HarmonyAttributes['system']}. */
    Harmony.prototype.setSystem = function (system) {
        this.attributes['system'] = system;
        return this;
    };
    /** Gets @type {HarmonyAttributes['type']}. */
    Harmony.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {HarmonyAttributes['type']}. */
    Harmony.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {Array<[Root | Numeral | Function, Kind, Inversion | null, Bass | null, Array<Degree>]>}. */
    Harmony.prototype.getValues = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<[Root | Numeral | Function, Kind, Inversion | null, Bass | null, Array<Degree>]>}. */
    Harmony.prototype.setValues = function (values) {
        this.contents[0] = values;
        return this;
    };
    /** Gets @type {Frame | null}. */
    Harmony.prototype.getFrame = function () {
        return this.contents[1];
    };
    /** Sets @type {Frame | null}. */
    Harmony.prototype.setFrame = function (frame) {
        this.contents[1] = frame;
        return this;
    };
    /** Gets @type {Offset | null}. */
    Harmony.prototype.getOffset = function () {
        return this.contents[2];
    };
    /** Sets @type {Offset | null}. */
    Harmony.prototype.setOffset = function (offset) {
        this.contents[2] = offset;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    Harmony.prototype.getFootnote = function () {
        return this.contents[3];
    };
    /** Sets @type {Footnote | null}. */
    Harmony.prototype.setFootnote = function (footnote) {
        this.contents[3] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    Harmony.prototype.getLevel = function () {
        return this.contents[4];
    };
    /** Sets @type {Level | null}. */
    Harmony.prototype.setLevel = function (level) {
        this.contents[4] = level;
        return this;
    };
    /** Gets @type {Staff | null}. */
    Harmony.prototype.getStaff = function () {
        return this.contents[5];
    };
    /** Sets @type {Staff | null}. */
    Harmony.prototype.setStaff = function (staff) {
        this.contents[5] = staff;
        return this;
    };
    Harmony.schema = {
        name: 'harmony',
        attributes: {
            arrangement: { type: 'optional', value: { type: 'choices', choices: ['horizontal', 'vertical', 'diagonal'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'print-frame': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            system: { type: 'optional', value: { type: 'choices', choices: ['none', 'only-top', 'also-top'] } },
            type: { type: 'optional', value: { type: 'choices', choices: ['alternate', 'explicit', 'implied'] } },
        },
        contents: [
            {
                type: 'label',
                label: 'values',
                value: {
                    type: 'oneOrMore',
                    value: [
                        { type: 'choices', choices: [Root, Numeral, Function] },
                        { type: 'required', value: Kind },
                        { type: 'optional', value: Inversion },
                        { type: 'optional', value: Bass },
                        { type: 'zeroOrMore', value: Degree },
                    ],
                },
            },
            { type: 'optional', value: Frame },
            { type: 'optional', value: Offset },
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
            { type: 'optional', value: Staff },
        ],
    };
    return Harmony;
}());
exports.Harmony = Harmony;
/**
 * The `<prefix>` element
 *
 * Parent element: `<figure>`
 *
 * Values for the `<prefix>` element include plus and the accidental values sharp, flat, natural, double-sharp,
 * flat-flat, and sharp-sharp. The `<prefix>` element may contain additional values for symbols specific to particular
 * figured bass styles.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/prefix/}
 */
var Prefix = /** @class */ (function () {
    function Prefix(opts) {
        var _a;
        this.schema = Prefix.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Prefix.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Prefix.schema.contents);
    }
    /** Gets @type {PrefixAttributes['color']}. */
    Prefix.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {PrefixAttributes['color']}. */
    Prefix.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {PrefixAttributes['default-x']}. */
    Prefix.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {PrefixAttributes['default-x']}. */
    Prefix.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {PrefixAttributes['default-y']}. */
    Prefix.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {PrefixAttributes['default-y']}. */
    Prefix.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {PrefixAttributes['font-family']}. */
    Prefix.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {PrefixAttributes['font-family']}. */
    Prefix.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {PrefixAttributes['font-size']}. */
    Prefix.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {PrefixAttributes['font-size']}. */
    Prefix.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {PrefixAttributes['font-style']}. */
    Prefix.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {PrefixAttributes['font-style']}. */
    Prefix.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {PrefixAttributes['font-weight']}. */
    Prefix.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {PrefixAttributes['font-weight']}. */
    Prefix.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {PrefixAttributes['relative-x']}. */
    Prefix.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {PrefixAttributes['relative-x']}. */
    Prefix.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {PrefixAttributes['relative-y']}. */
    Prefix.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {PrefixAttributes['relative-y']}. */
    Prefix.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    Prefix.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Prefix.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Prefix.schema = {
        name: 'prefix',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Prefix;
}());
exports.Prefix = Prefix;
/**
 * The `<figure>` element
 *
 * Parent element: `<figured-bass>`
 *
 * The `<figure>` element represents a single figure within a `<figured-bass>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/figure-number/}
 */
var FigureNumber = /** @class */ (function () {
    function FigureNumber(opts) {
        var _a;
        this.schema = FigureNumber.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, FigureNumber.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(FigureNumber.schema.contents);
    }
    /** Gets @type {FigureNumberAttributes['color']}. */
    FigureNumber.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FigureNumberAttributes['color']}. */
    FigureNumber.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FigureNumberAttributes['default-x']}. */
    FigureNumber.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {FigureNumberAttributes['default-x']}. */
    FigureNumber.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {FigureNumberAttributes['default-y']}. */
    FigureNumber.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {FigureNumberAttributes['default-y']}. */
    FigureNumber.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {FigureNumberAttributes['font-family']}. */
    FigureNumber.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FigureNumberAttributes['font-family']}. */
    FigureNumber.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FigureNumberAttributes['font-size']}. */
    FigureNumber.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FigureNumberAttributes['font-size']}. */
    FigureNumber.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FigureNumberAttributes['font-style']}. */
    FigureNumber.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FigureNumberAttributes['font-style']}. */
    FigureNumber.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FigureNumberAttributes['font-weight']}. */
    FigureNumber.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FigureNumberAttributes['font-weight']}. */
    FigureNumber.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {FigureNumberAttributes['relative-x']}. */
    FigureNumber.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {FigureNumberAttributes['relative-x']}. */
    FigureNumber.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {FigureNumberAttributes['relative-y']}. */
    FigureNumber.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {FigureNumberAttributes['relative-y']}. */
    FigureNumber.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    FigureNumber.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    FigureNumber.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    FigureNumber.schema = {
        name: 'figure-number',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'string' }],
    };
    return FigureNumber;
}());
exports.FigureNumber = FigureNumber;
/**
 * The `<suffix>` element
 *
 * Parent element: `<figure>`
 *
 * Values for the `<suffix>` element include plus and the accidental values sharp, flat, natural, double-sharp,
 * flat-flat, and sharp-sharp. Suffixes include both symbols that come after the figure number and those that overstrike
 * the figure number. The `<suffix>` values slash, back-slash, and vertical are used for slashed numbers indicating
 * chromatic alteration. The orientation and display of the slash usually depends on the figure number. The `<suffix>`
 * element may contain additional values for symbols specific to particular figured bass styles.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/suffix/}
 */
var Suffix = /** @class */ (function () {
    function Suffix(opts) {
        var _a;
        this.schema = Suffix.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Suffix.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Suffix.schema.contents);
    }
    /** Gets @type {SuffixAttributes['color']}. */
    Suffix.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {SuffixAttributes['color']}. */
    Suffix.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {SuffixAttributes['default-x']}. */
    Suffix.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {SuffixAttributes['default-x']}. */
    Suffix.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {SuffixAttributes['default-y']}. */
    Suffix.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {SuffixAttributes['default-y']}. */
    Suffix.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {SuffixAttributes['font-family']}. */
    Suffix.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {SuffixAttributes['font-family']}. */
    Suffix.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {SuffixAttributes['font-size']}. */
    Suffix.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {SuffixAttributes['font-size']}. */
    Suffix.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {SuffixAttributes['font-style']}. */
    Suffix.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {SuffixAttributes['font-style']}. */
    Suffix.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {SuffixAttributes['font-weight']}. */
    Suffix.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {SuffixAttributes['font-weight']}. */
    Suffix.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {SuffixAttributes['relative-x']}. */
    Suffix.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {SuffixAttributes['relative-x']}. */
    Suffix.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {SuffixAttributes['relative-y']}. */
    Suffix.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {SuffixAttributes['relative-y']}. */
    Suffix.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {string}. */
    Suffix.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Suffix.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Suffix.schema = {
        name: 'suffix',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Suffix;
}());
exports.Suffix = Suffix;
/**
 * The `<figure>` element
 *
 * Parent element: `<figured-bass>`
 *
 * The `<figure>` element represents a single figure within a `<figured-bass>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/figure/}
 */
var Figure = /** @class */ (function () {
    function Figure(opts) {
        var _a;
        this.schema = Figure.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Figure.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Figure.schema.contents);
    }
    /** Gets @type {Prefix | null}. */
    Figure.prototype.getPrefix = function () {
        return this.contents[0];
    };
    /** Sets @type {Prefix | null}. */
    Figure.prototype.setPrefix = function (prefix) {
        this.contents[0] = prefix;
        return this;
    };
    /** Gets @type {FigureNumber | null}. */
    Figure.prototype.getFigureNumber = function () {
        return this.contents[1];
    };
    /** Sets @type {FigureNumber | null}. */
    Figure.prototype.setFigureNumber = function (figureNumber) {
        this.contents[1] = figureNumber;
        return this;
    };
    /** Gets @type {Suffix | null}. */
    Figure.prototype.getSuffix = function () {
        return this.contents[2];
    };
    /** Sets @type {Suffix | null}. */
    Figure.prototype.setSuffix = function (suffix) {
        this.contents[2] = suffix;
        return this;
    };
    /** Gets @type {Extend | null}. */
    Figure.prototype.getExtend = function () {
        return this.contents[3];
    };
    /** Sets @type {Extend | null}. */
    Figure.prototype.setExtend = function (extend) {
        this.contents[3] = extend;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    Figure.prototype.getFootnote = function () {
        return this.contents[4];
    };
    /** Sets @type {Footnote | null}. */
    Figure.prototype.setFootnote = function (footnote) {
        this.contents[4] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    Figure.prototype.getLevel = function () {
        return this.contents[5];
    };
    /** Sets @type {Level | null}. */
    Figure.prototype.setLevel = function (level) {
        this.contents[5] = level;
        return this;
    };
    Figure.schema = {
        name: 'figure',
        attributes: {},
        contents: [
            { type: 'optional', value: Prefix },
            { type: 'optional', value: FigureNumber },
            { type: 'optional', value: Suffix },
            { type: 'optional', value: Extend },
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
        ],
    };
    return Figure;
}());
exports.Figure = Figure;
/**
 * The `<figured-bass>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<figured-bass>` element represents figured bass notation. A `<figured-bass>` element takes its position from the
 * first regular note (not a grace note or chord note) that follows in score order. The optional `<duration>` element is
 * used to indicate changes of figures under a note. Figures are ordered from top to bottom.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/figured-bass/}
 */
var FiguredBass = /** @class */ (function () {
    function FiguredBass(opts) {
        var _a;
        this.schema = FiguredBass.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, FiguredBass.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(FiguredBass.schema.contents);
    }
    /** Gets @type {FiguredBassAttributes['color']}. */
    FiguredBass.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {FiguredBassAttributes['color']}. */
    FiguredBass.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['default-x']}. */
    FiguredBass.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {FiguredBassAttributes['default-x']}. */
    FiguredBass.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['default-y']}. */
    FiguredBass.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {FiguredBassAttributes['default-y']}. */
    FiguredBass.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['font-family']}. */
    FiguredBass.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {FiguredBassAttributes['font-family']}. */
    FiguredBass.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['font-size']}. */
    FiguredBass.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {FiguredBassAttributes['font-size']}. */
    FiguredBass.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['font-style']}. */
    FiguredBass.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {FiguredBassAttributes['font-style']}. */
    FiguredBass.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['font-weight']}. */
    FiguredBass.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {FiguredBassAttributes['font-weight']}. */
    FiguredBass.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['halign']}. */
    FiguredBass.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {FiguredBassAttributes['halign']}. */
    FiguredBass.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['id']}. */
    FiguredBass.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {FiguredBassAttributes['id']}. */
    FiguredBass.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['parentheses']}. */
    FiguredBass.prototype.getParentheses = function () {
        return this.attributes['parentheses'];
    };
    /** Sets @type {FiguredBassAttributes['parentheses']}. */
    FiguredBass.prototype.setParentheses = function (parentheses) {
        this.attributes['parentheses'] = parentheses;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['placement']}. */
    FiguredBass.prototype.getPlacement = function () {
        return this.attributes['placement'];
    };
    /** Sets @type {FiguredBassAttributes['placement']}. */
    FiguredBass.prototype.setPlacement = function (placement) {
        this.attributes['placement'] = placement;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['print-dot']}. */
    FiguredBass.prototype.getPrintDot = function () {
        return this.attributes['print-dot'];
    };
    /** Sets @type {FiguredBassAttributes['print-dot']}. */
    FiguredBass.prototype.setPrintDot = function (printDot) {
        this.attributes['print-dot'] = printDot;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['print-lyric']}. */
    FiguredBass.prototype.getPrintLyric = function () {
        return this.attributes['print-lyric'];
    };
    /** Sets @type {FiguredBassAttributes['print-lyric']}. */
    FiguredBass.prototype.setPrintLyric = function (printLyric) {
        this.attributes['print-lyric'] = printLyric;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['print-object']}. */
    FiguredBass.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {FiguredBassAttributes['print-object']}. */
    FiguredBass.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['print-spacing']}. */
    FiguredBass.prototype.getPrintSpacing = function () {
        return this.attributes['print-spacing'];
    };
    /** Sets @type {FiguredBassAttributes['print-spacing']}. */
    FiguredBass.prototype.setPrintSpacing = function (printSpacing) {
        this.attributes['print-spacing'] = printSpacing;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['relative-x']}. */
    FiguredBass.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {FiguredBassAttributes['relative-x']}. */
    FiguredBass.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['relative-y']}. */
    FiguredBass.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {FiguredBassAttributes['relative-y']}. */
    FiguredBass.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {FiguredBassAttributes['valign']}. */
    FiguredBass.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {FiguredBassAttributes['valign']}. */
    FiguredBass.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {Array<Figure>}. */
    FiguredBass.prototype.getFigures = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Figure>}. */
    FiguredBass.prototype.setFigures = function (figures) {
        this.contents[0] = figures;
        return this;
    };
    /** Gets @type {Duration | null}. */
    FiguredBass.prototype.getDuration = function () {
        return this.contents[1];
    };
    /** Sets @type {Duration | null}. */
    FiguredBass.prototype.setDuration = function (duration) {
        this.contents[1] = duration;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    FiguredBass.prototype.getFootnote = function () {
        return this.contents[2];
    };
    /** Sets @type {Footnote | null}. */
    FiguredBass.prototype.setFootnote = function (footnote) {
        this.contents[2] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    FiguredBass.prototype.getLevel = function () {
        return this.contents[3];
    };
    /** Sets @type {Level | null}. */
    FiguredBass.prototype.setLevel = function (level) {
        this.contents[3] = level;
        return this;
    };
    FiguredBass.schema = {
        name: 'figured-bass',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
            'print-dot': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-lyric': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'print-spacing': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [
            { type: 'label', label: 'figures', value: { type: 'oneOrMore', value: Figure } },
            { type: 'optional', value: Duration },
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
        ],
    };
    return FiguredBass;
}());
exports.FiguredBass = FiguredBass;
/**
 * The `<measure-distance>` element
 *
 * Parent element: `<measure-layout>`
 *
 * The `<measure-distance>` element specifies the horizontal distance from the previous measure. This value is only used
 * for systems where there is horizontal whitespace in the middle of a system, as in systems with codas. To specify the
 * measure width, use the width attribute of the `<measure>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-distance/}
 */
var MeasureDistance = /** @class */ (function () {
    function MeasureDistance(opts) {
        var _a;
        this.schema = MeasureDistance.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MeasureDistance.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MeasureDistance.schema.contents);
    }
    /** Gets @type {number}. */
    MeasureDistance.prototype.getValue = function () {
        return this.contents[0];
    };
    /** Sets @type {number}. */
    MeasureDistance.prototype.setValue = function (value) {
        this.contents[0] = value;
        return this;
    };
    MeasureDistance.schema = {
        name: 'measure-distance',
        attributes: {},
        contents: [
            {
                type: 'label',
                label: 'value',
                value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
        ],
    };
    return MeasureDistance;
}());
exports.MeasureDistance = MeasureDistance;
/**
 * The `<measure-layout>` element
 *
 * Parent element: `<print>`
 *
 * The `<measure-layout>` element includes the horizontal distance from the previous measure. It applies to the current
 * measure only.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-layout/}
 */
var MeasureLayout = /** @class */ (function () {
    function MeasureLayout(opts) {
        var _a;
        this.schema = MeasureLayout.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MeasureLayout.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MeasureLayout.schema.contents);
    }
    /** Gets @type {MeasureDistance | null}. */
    MeasureLayout.prototype.getMeasureDistance = function () {
        return this.contents[0];
    };
    /** Sets @type {MeasureDistance | null}. */
    MeasureLayout.prototype.setMeasureDistance = function (measureDistance) {
        this.contents[0] = measureDistance;
        return this;
    };
    MeasureLayout.schema = {
        name: 'measure-layout',
        attributes: {},
        contents: [{ type: 'optional', value: MeasureDistance }],
    };
    return MeasureLayout;
}());
exports.MeasureLayout = MeasureLayout;
/**
 * The `<measure-numbering>` element
 *
 * Parent element: `<print>`
 *
 * The `<measure-numbering>` element describes how frequently measure numbers are displayed on this part. The text
 * attribute from the `<measure>` element is used for display, or the number attribute if the text attribute is not
 * present. Measures with an implicit attribute set to yes never display a measure number, regardless of the
 * `<measure-numbering>` setting.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-numbering/}
 */
var MeasureNumbering = /** @class */ (function () {
    function MeasureNumbering(opts) {
        var _a;
        this.schema = MeasureNumbering.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MeasureNumbering.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MeasureNumbering.schema.contents);
    }
    /** Gets @type {MeasureNumberingAttributes['color']}. */
    MeasureNumbering.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {MeasureNumberingAttributes['color']}. */
    MeasureNumbering.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['default-x']}. */
    MeasureNumbering.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {MeasureNumberingAttributes['default-x']}. */
    MeasureNumbering.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['default-y']}. */
    MeasureNumbering.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {MeasureNumberingAttributes['default-y']}. */
    MeasureNumbering.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['font-family']}. */
    MeasureNumbering.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {MeasureNumberingAttributes['font-family']}. */
    MeasureNumbering.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['font-size']}. */
    MeasureNumbering.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {MeasureNumberingAttributes['font-size']}. */
    MeasureNumbering.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['font-style']}. */
    MeasureNumbering.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {MeasureNumberingAttributes['font-style']}. */
    MeasureNumbering.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['font-weight']}. */
    MeasureNumbering.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {MeasureNumberingAttributes['font-weight']}. */
    MeasureNumbering.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['halign']}. */
    MeasureNumbering.prototype.getHalign = function () {
        return this.attributes['halign'];
    };
    /** Sets @type {MeasureNumberingAttributes['halign']}. */
    MeasureNumbering.prototype.setHalign = function (halign) {
        this.attributes['halign'] = halign;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['multiple-rest-always']}. */
    MeasureNumbering.prototype.getMultipleRestAlways = function () {
        return this.attributes['multiple-rest-always'];
    };
    /** Sets @type {MeasureNumberingAttributes['multiple-rest-always']}. */
    MeasureNumbering.prototype.setMultipleRestAlways = function (multipleRestAlways) {
        this.attributes['multiple-rest-always'] = multipleRestAlways;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['multiple-rest-range']}. */
    MeasureNumbering.prototype.getMultipleRestRange = function () {
        return this.attributes['multiple-rest-range'];
    };
    /** Sets @type {MeasureNumberingAttributes['multiple-rest-range']}. */
    MeasureNumbering.prototype.setMultipleRestRange = function (multipleRestRange) {
        this.attributes['multiple-rest-range'] = multipleRestRange;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['relative-x']}. */
    MeasureNumbering.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {MeasureNumberingAttributes['relative-x']}. */
    MeasureNumbering.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['relative-y']}. */
    MeasureNumbering.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {MeasureNumberingAttributes['relative-y']}. */
    MeasureNumbering.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['staff']}. */
    MeasureNumbering.prototype.getStaff = function () {
        return this.attributes['staff'];
    };
    /** Sets @type {MeasureNumberingAttributes['staff']}. */
    MeasureNumbering.prototype.setStaff = function (staff) {
        this.attributes['staff'] = staff;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['system']}. */
    MeasureNumbering.prototype.getSystem = function () {
        return this.attributes['system'];
    };
    /** Sets @type {MeasureNumberingAttributes['system']}. */
    MeasureNumbering.prototype.setSystem = function (system) {
        this.attributes['system'] = system;
        return this;
    };
    /** Gets @type {MeasureNumberingAttributes['valign']}. */
    MeasureNumbering.prototype.getValign = function () {
        return this.attributes['valign'];
    };
    /** Sets @type {MeasureNumberingAttributes['valign']}. */
    MeasureNumbering.prototype.setValign = function (valign) {
        this.attributes['valign'] = valign;
        return this;
    };
    /** Gets @type {'none' | 'measure' | 'system'}. */
    MeasureNumbering.prototype.getMeasureNumberValue = function () {
        return this.contents[0];
    };
    /** Sets @type {'none' | 'measure' | 'system'}. */
    MeasureNumbering.prototype.setMeasureNumberValue = function (measureNumberValue) {
        this.contents[0] = measureNumberValue;
        return this;
    };
    MeasureNumbering.schema = {
        name: 'measure-numbering',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
            'multiple-rest-always': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'multiple-rest-range': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            staff: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
            system: {
                type: 'optional',
                value: { type: 'choices', choices: ['none', 'only-top', 'only-bottom', 'also-top', 'also-bottom'] },
            },
            valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'measure-number-value',
                    value: { type: 'choices', choices: ['none', 'measure', 'system'] },
                },
            },
        ],
    };
    return MeasureNumbering;
}());
exports.MeasureNumbering = MeasureNumbering;
/**
 * The `<print>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<print>` element contains general printing parameters, including layout elements. The `<part-name-display>` and
 * `<part-abbreviation-display>` elements may also be used here to change how a part name or abbreviation is displayed
 * over the course of a piece. They take effect when the current measure or a succeeding measure starts a new system.
 *
 * Layout group elements in a `<print>` element only apply to the current page, system, or staff. Music that follows
 * continues to take the default values from the layout determined by the `<defaults>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/print/}
 */
var Print = /** @class */ (function () {
    function Print(opts) {
        var _a;
        this.schema = Print.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Print.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Print.schema.contents);
    }
    /** Gets @type {PrintAttributes['blank-page']}. */
    Print.prototype.getBlankPage = function () {
        return this.attributes['blank-page'];
    };
    /** Sets @type {PrintAttributes['blank-page']}. */
    Print.prototype.setBlankPage = function (blankPage) {
        this.attributes['blank-page'] = blankPage;
        return this;
    };
    /** Gets @type {PrintAttributes['id']}. */
    Print.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {PrintAttributes['id']}. */
    Print.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {PrintAttributes['new-page']}. */
    Print.prototype.getNewPage = function () {
        return this.attributes['new-page'];
    };
    /** Sets @type {PrintAttributes['new-page']}. */
    Print.prototype.setNewPage = function (newPage) {
        this.attributes['new-page'] = newPage;
        return this;
    };
    /** Gets @type {PrintAttributes['new-system']}. */
    Print.prototype.getNewSystem = function () {
        return this.attributes['new-system'];
    };
    /** Sets @type {PrintAttributes['new-system']}. */
    Print.prototype.setNewSystem = function (newSystem) {
        this.attributes['new-system'] = newSystem;
        return this;
    };
    /** Gets @type {PrintAttributes['page-number']}. */
    Print.prototype.getPageNumber = function () {
        return this.attributes['page-number'];
    };
    /** Sets @type {PrintAttributes['page-number']}. */
    Print.prototype.setPageNumber = function (pageNumber) {
        this.attributes['page-number'] = pageNumber;
        return this;
    };
    /** Gets @type {PrintAttributes['staff-spacing']}. */
    Print.prototype.getStaffSpacing = function () {
        return this.attributes['staff-spacing'];
    };
    /** Sets @type {PrintAttributes['staff-spacing']}. */
    Print.prototype.setStaffSpacing = function (staffSpacing) {
        this.attributes['staff-spacing'] = staffSpacing;
        return this;
    };
    /** Gets @type {PageLayout | null}. */
    Print.prototype.getPageLayout = function () {
        return this.contents[0];
    };
    /** Sets @type {PageLayout | null}. */
    Print.prototype.setPageLayout = function (pageLayout) {
        this.contents[0] = pageLayout;
        return this;
    };
    /** Gets @type {SystemLayout | null}. */
    Print.prototype.getSystemLayout = function () {
        return this.contents[1];
    };
    /** Sets @type {SystemLayout | null}. */
    Print.prototype.setSystemLayout = function (systemLayout) {
        this.contents[1] = systemLayout;
        return this;
    };
    /** Gets @type {Array<StaffLayout>}. */
    Print.prototype.getStaffLayouts = function () {
        return this.contents[2];
    };
    /** Sets @type {Array<StaffLayout>}. */
    Print.prototype.setStaffLayouts = function (staffLayouts) {
        this.contents[2] = staffLayouts;
        return this;
    };
    /** Gets @type {MeasureLayout | null}. */
    Print.prototype.getMeasureLayout = function () {
        return this.contents[3];
    };
    /** Sets @type {MeasureLayout | null}. */
    Print.prototype.setMeasureLayout = function (measureLayout) {
        this.contents[3] = measureLayout;
        return this;
    };
    /** Gets @type {MeasureNumbering | null}. */
    Print.prototype.getMeasureNumbering = function () {
        return this.contents[4];
    };
    /** Sets @type {MeasureNumbering | null}. */
    Print.prototype.setMeasureNumbering = function (measureNumbering) {
        this.contents[4] = measureNumbering;
        return this;
    };
    /** Gets @type {PartNameDisplay | null}. */
    Print.prototype.getPartNameDisplay = function () {
        return this.contents[5];
    };
    /** Sets @type {PartNameDisplay | null}. */
    Print.prototype.setPartNameDisplay = function (partNameDisplay) {
        this.contents[5] = partNameDisplay;
        return this;
    };
    /** Gets @type {PartAbbreviationDisplay | null}. */
    Print.prototype.getPartAbbreviationDisplay = function () {
        return this.contents[6];
    };
    /** Sets @type {PartAbbreviationDisplay | null}. */
    Print.prototype.setPartAbbreviationDisplay = function (partAbbreviationDisplay) {
        this.contents[6] = partAbbreviationDisplay;
        return this;
    };
    Print.schema = {
        name: 'print',
        attributes: {
            'blank-page': { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'new-page': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'new-system': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'page-number': { type: 'optional', value: { type: 'string' } },
            'staff-spacing': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [
            { type: 'optional', value: PageLayout },
            { type: 'optional', value: SystemLayout },
            { type: 'label', label: 'staff-layouts', value: { type: 'zeroOrMore', value: StaffLayout } },
            { type: 'optional', value: MeasureLayout },
            { type: 'optional', value: MeasureNumbering },
            { type: 'optional', value: PartNameDisplay },
            { type: 'optional', value: PartAbbreviationDisplay },
        ],
    };
    return Print;
}());
exports.Print = Print;
/**
 * The `<bar-style>` element
 *
 * Parent element: `<barline>`
 *
 * The `<bar-style>` element contains barline style and color information.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bar-style/}
 */
var BarStyle = /** @class */ (function () {
    function BarStyle(opts) {
        var _a;
        this.schema = BarStyle.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, BarStyle.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(BarStyle.schema.contents);
    }
    /** Gets @type {BarStyleAttributes['color']}. */
    BarStyle.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {BarStyleAttributes['color']}. */
    BarStyle.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {'none' | 'dashed' | 'dotted' | 'heavy' | 'heavy-heavy' | 'heavy-light' | 'light-heavy' | 'light-light' | 'regular' | 'short' | 'tick'}. */
    BarStyle.prototype.getBarStyle = function () {
        return this.contents[0];
    };
    /** Sets @type {'none' | 'dashed' | 'dotted' | 'heavy' | 'heavy-heavy' | 'heavy-light' | 'light-heavy' | 'light-light' | 'regular' | 'short' | 'tick'}. */
    BarStyle.prototype.setBarStyle = function (barStyle) {
        this.contents[0] = barStyle;
        return this;
    };
    BarStyle.schema = {
        name: 'bar-style',
        attributes: {
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
        },
        contents: [
            {
                type: 'required',
                value: {
                    type: 'label',
                    label: 'bar-style',
                    value: {
                        type: 'choices',
                        choices: [
                            'none',
                            'dashed',
                            'dotted',
                            'heavy',
                            'heavy-heavy',
                            'heavy-light',
                            'light-heavy',
                            'light-light',
                            'regular',
                            'short',
                            'tick',
                        ],
                    },
                },
            },
        ],
    };
    return BarStyle;
}());
exports.BarStyle = BarStyle;
/**
 * The `<ending>` element
 *
 * Parent element: `<barline>`
 *
 * The `<ending>` element represents multiple (e.g. first and second) endings. The element text is used when the text
 * displayed in the ending is different than what appears in the number attribute.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ending/}
 */
var Ending = /** @class */ (function () {
    function Ending(opts) {
        var _a;
        this.schema = Ending.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Ending.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Ending.schema.contents);
    }
    /** Gets @type {EndingAttributes['number']}. */
    Ending.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {EndingAttributes['number']}. */
    Ending.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {EndingAttributes['type']}. */
    Ending.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {EndingAttributes['type']}. */
    Ending.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {EndingAttributes['color']}. */
    Ending.prototype.getColor = function () {
        return this.attributes['color'];
    };
    /** Sets @type {EndingAttributes['color']}. */
    Ending.prototype.setColor = function (color) {
        this.attributes['color'] = color;
        return this;
    };
    /** Gets @type {EndingAttributes['default-x']}. */
    Ending.prototype.getDefaultX = function () {
        return this.attributes['default-x'];
    };
    /** Sets @type {EndingAttributes['default-x']}. */
    Ending.prototype.setDefaultX = function (defaultX) {
        this.attributes['default-x'] = defaultX;
        return this;
    };
    /** Gets @type {EndingAttributes['default-y']}. */
    Ending.prototype.getDefaultY = function () {
        return this.attributes['default-y'];
    };
    /** Sets @type {EndingAttributes['default-y']}. */
    Ending.prototype.setDefaultY = function (defaultY) {
        this.attributes['default-y'] = defaultY;
        return this;
    };
    /** Gets @type {EndingAttributes['end-length']}. */
    Ending.prototype.getEndLength = function () {
        return this.attributes['end-length'];
    };
    /** Sets @type {EndingAttributes['end-length']}. */
    Ending.prototype.setEndLength = function (endLength) {
        this.attributes['end-length'] = endLength;
        return this;
    };
    /** Gets @type {EndingAttributes['font-family']}. */
    Ending.prototype.getFontFamily = function () {
        return this.attributes['font-family'];
    };
    /** Sets @type {EndingAttributes['font-family']}. */
    Ending.prototype.setFontFamily = function (fontFamily) {
        this.attributes['font-family'] = fontFamily;
        return this;
    };
    /** Gets @type {EndingAttributes['font-size']}. */
    Ending.prototype.getFontSize = function () {
        return this.attributes['font-size'];
    };
    /** Sets @type {EndingAttributes['font-size']}. */
    Ending.prototype.setFontSize = function (fontSize) {
        this.attributes['font-size'] = fontSize;
        return this;
    };
    /** Gets @type {EndingAttributes['font-style']}. */
    Ending.prototype.getFontStyle = function () {
        return this.attributes['font-style'];
    };
    /** Sets @type {EndingAttributes['font-style']}. */
    Ending.prototype.setFontStyle = function (fontStyle) {
        this.attributes['font-style'] = fontStyle;
        return this;
    };
    /** Gets @type {EndingAttributes['font-weight']}. */
    Ending.prototype.getFontWeight = function () {
        return this.attributes['font-weight'];
    };
    /** Sets @type {EndingAttributes['font-weight']}. */
    Ending.prototype.setFontWeight = function (fontWeight) {
        this.attributes['font-weight'] = fontWeight;
        return this;
    };
    /** Gets @type {EndingAttributes['print-object']}. */
    Ending.prototype.getPrintObject = function () {
        return this.attributes['print-object'];
    };
    /** Sets @type {EndingAttributes['print-object']}. */
    Ending.prototype.setPrintObject = function (printObject) {
        this.attributes['print-object'] = printObject;
        return this;
    };
    /** Gets @type {EndingAttributes['relative-x']}. */
    Ending.prototype.getRelativeX = function () {
        return this.attributes['relative-x'];
    };
    /** Sets @type {EndingAttributes['relative-x']}. */
    Ending.prototype.setRelativeX = function (relativeX) {
        this.attributes['relative-x'] = relativeX;
        return this;
    };
    /** Gets @type {EndingAttributes['relative-y']}. */
    Ending.prototype.getRelativeY = function () {
        return this.attributes['relative-y'];
    };
    /** Sets @type {EndingAttributes['relative-y']}. */
    Ending.prototype.setRelativeY = function (relativeY) {
        this.attributes['relative-y'] = relativeY;
        return this;
    };
    /** Gets @type {EndingAttributes['system']}. */
    Ending.prototype.getSystem = function () {
        return this.attributes['system'];
    };
    /** Sets @type {EndingAttributes['system']}. */
    Ending.prototype.setSystem = function (system) {
        this.attributes['system'] = system;
        return this;
    };
    /** Gets @type {EndingAttributes['text-x']}. */
    Ending.prototype.getTextX = function () {
        return this.attributes['text-x'];
    };
    /** Sets @type {EndingAttributes['text-x']}. */
    Ending.prototype.setTextX = function (textX) {
        this.attributes['text-x'] = textX;
        return this;
    };
    /** Gets @type {EndingAttributes['text-y']}. */
    Ending.prototype.getTextY = function () {
        return this.attributes['text-y'];
    };
    /** Sets @type {EndingAttributes['text-y']}. */
    Ending.prototype.setTextY = function (textY) {
        this.attributes['text-y'] = textY;
        return this;
    };
    /** Gets @type {string}. */
    Ending.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Ending.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Ending.schema = {
        name: 'ending',
        attributes: {
            number: {
                type: 'required',
                value: { type: 'regex', pattern: /([ ]*)|([1-9][0-9]*(, ?[1-9][0-9]*)*)/, zero: '' },
            },
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'discontinue'] } },
            color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
            'default-x': {
                type: 'label',
                label: 'default-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'default-y': {
                type: 'label',
                label: 'default-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'end-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
            'font-size': {
                type: 'optional',
                value: {
                    type: 'choices',
                    choices: [
                        { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
                        { type: 'float', min: -Infinity, max: Infinity },
                    ],
                },
            },
            'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
            'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
            'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'relative-x': {
                type: 'label',
                label: 'relative-x',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            'relative-y': {
                type: 'label',
                label: 'relative-y',
                value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            },
            system: { type: 'optional', value: { type: 'choices', choices: ['none', 'only-top', 'also-top'] } },
            'text-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            'text-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Ending;
}());
exports.Ending = Ending;
/**
 * The `<repeat>` element
 *
 * Parent element: `<barline>`
 *
 * The `<repeat>` element represents repeat marks.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/repeat/}
 */
var Repeat = /** @class */ (function () {
    function Repeat(opts) {
        var _a;
        this.schema = Repeat.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Repeat.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Repeat.schema.contents);
    }
    /** Gets @type {RepeatAttributes['direction']}. */
    Repeat.prototype.getDirection = function () {
        return this.attributes['direction'];
    };
    /** Sets @type {RepeatAttributes['direction']}. */
    Repeat.prototype.setDirection = function (direction) {
        this.attributes['direction'] = direction;
        return this;
    };
    /** Gets @type {RepeatAttributes['after-jump']}. */
    Repeat.prototype.getAfterJump = function () {
        return this.attributes['after-jump'];
    };
    /** Sets @type {RepeatAttributes['after-jump']}. */
    Repeat.prototype.setAfterJump = function (afterJump) {
        this.attributes['after-jump'] = afterJump;
        return this;
    };
    /** Gets @type {RepeatAttributes['times']}. */
    Repeat.prototype.getTimes = function () {
        return this.attributes['times'];
    };
    /** Sets @type {RepeatAttributes['times']}. */
    Repeat.prototype.setTimes = function (times) {
        this.attributes['times'] = times;
        return this;
    };
    /** Gets @type {RepeatAttributes['winged']}. */
    Repeat.prototype.getWinged = function () {
        return this.attributes['winged'];
    };
    /** Sets @type {RepeatAttributes['winged']}. */
    Repeat.prototype.setWinged = function (winged) {
        this.attributes['winged'] = winged;
        return this;
    };
    Repeat.schema = {
        name: 'repeat',
        attributes: {
            direction: { type: 'required', value: { type: 'choices', choices: ['backward', 'forward'] } },
            'after-jump': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            times: { type: 'optional', value: { type: 'int', min: 0, max: Infinity } },
            winged: {
                type: 'optional',
                value: { type: 'choices', choices: ['none', 'straight', 'curved', 'double-straight', 'double-curved'] },
            },
        },
        contents: [],
    };
    return Repeat;
}());
exports.Repeat = Repeat;
/**
 * The `<barline>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * If a barline is other than a normal single barline, it should be represented by a `<barline>` element that describes
 * it. This includes information about repeats and multiple endings, as well as line style. Barline data is on the same
 * level as the other musical data in a score - a child of a measure in a partwise score, or a part in a timewise score.
 * This allows for barlines within measures, as in dotted barlines that subdivide measures in complex meters. The two
 * `<fermata>` elements allow for fermatas on both sides of the barline (the lower one inverted).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/barline/}
 */
var Barline = /** @class */ (function () {
    function Barline(opts) {
        var _a;
        this.schema = Barline.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Barline.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Barline.schema.contents);
    }
    /** Gets @type {BarlineAttributes['coda-token']}. */
    Barline.prototype.getCodaToken = function () {
        return this.attributes['coda'];
    };
    /** Sets @type {BarlineAttributes['coda-token']}. */
    Barline.prototype.setCodaToken = function (codaToken) {
        this.attributes['coda'] = codaToken;
        return this;
    };
    /** Gets @type {BarlineAttributes['divisions']}. */
    Barline.prototype.getDivisions = function () {
        return this.attributes['divisions'];
    };
    /** Sets @type {BarlineAttributes['divisions']}. */
    Barline.prototype.setDivisions = function (divisions) {
        this.attributes['divisions'] = divisions;
        return this;
    };
    /** Gets @type {BarlineAttributes['id']}. */
    Barline.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {BarlineAttributes['id']}. */
    Barline.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {BarlineAttributes['location']}. */
    Barline.prototype.getLocation = function () {
        return this.attributes['location'];
    };
    /** Sets @type {BarlineAttributes['location']}. */
    Barline.prototype.setLocation = function (location) {
        this.attributes['location'] = location;
        return this;
    };
    /** Gets @type {BarlineAttributes['segno-token']}. */
    Barline.prototype.getSegnoToken = function () {
        return this.attributes['segno'];
    };
    /** Sets @type {BarlineAttributes['segno-token']}. */
    Barline.prototype.setSegnoToken = function (segnoToken) {
        this.attributes['segno'] = segnoToken;
        return this;
    };
    /** Gets @type {BarStyle | null}. */
    Barline.prototype.getBarStyle = function () {
        return this.contents[0];
    };
    /** Sets @type {BarStyle | null}. */
    Barline.prototype.setBarStyle = function (barStyle) {
        this.contents[0] = barStyle;
        return this;
    };
    /** Gets @type {Footnote | null}. */
    Barline.prototype.getFootnote = function () {
        return this.contents[1];
    };
    /** Sets @type {Footnote | null}. */
    Barline.prototype.setFootnote = function (footnote) {
        this.contents[1] = footnote;
        return this;
    };
    /** Gets @type {Level | null}. */
    Barline.prototype.getLevel = function () {
        return this.contents[2];
    };
    /** Sets @type {Level | null}. */
    Barline.prototype.setLevel = function (level) {
        this.contents[2] = level;
        return this;
    };
    /** Gets @type {WavyLine | null}. */
    Barline.prototype.getWavyLine = function () {
        return this.contents[3];
    };
    /** Sets @type {WavyLine | null}. */
    Barline.prototype.setWavyLine = function (wavyLine) {
        this.contents[3] = wavyLine;
        return this;
    };
    /** Gets @type {Segno | null}. */
    Barline.prototype.getSegno = function () {
        return this.contents[4];
    };
    /** Sets @type {Segno | null}. */
    Barline.prototype.setSegno = function (segno) {
        this.contents[4] = segno;
        return this;
    };
    /** Gets @type {Coda | null}. */
    Barline.prototype.getCoda = function () {
        return this.contents[5];
    };
    /** Sets @type {Coda | null}. */
    Barline.prototype.setCoda = function (coda) {
        this.contents[5] = coda;
        return this;
    };
    /** Gets @type {[] | [Fermata] | [Fermata, Fermata]}. */
    Barline.prototype.getFermatas = function () {
        return this.contents[6];
    };
    /** Sets @type {[] | [Fermata] | [Fermata, Fermata]}. */
    Barline.prototype.setFermatas = function (fermatas) {
        this.contents[6] = fermatas;
        return this;
    };
    /** Gets @type {Ending | null}. */
    Barline.prototype.getEnding = function () {
        return this.contents[7];
    };
    /** Sets @type {Ending | null}. */
    Barline.prototype.setEnding = function (ending) {
        this.contents[7] = ending;
        return this;
    };
    /** Gets @type {Repeat | null}. */
    Barline.prototype.getRepeat = function () {
        return this.contents[8];
    };
    /** Sets @type {Repeat | null}. */
    Barline.prototype.setRepeat = function (repeat) {
        this.contents[8] = repeat;
        return this;
    };
    Barline.schema = {
        name: 'barline',
        attributes: {
            coda: { type: 'label', label: 'coda-token', value: { type: 'optional', value: { type: 'string' } } },
            divisions: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            location: { type: 'optional', value: { type: 'choices', choices: ['right', 'left', 'middle'] } },
            segno: { type: 'label', label: 'segno-token', value: { type: 'optional', value: { type: 'string' } } },
        },
        contents: [
            { type: 'optional', value: BarStyle },
            { type: 'optional', value: Footnote },
            { type: 'optional', value: Level },
            { type: 'optional', value: WavyLine },
            { type: 'optional', value: Segno },
            { type: 'optional', value: Coda },
            { type: 'label', label: 'fermatas', value: { type: 'choices', choices: [[], [Fermata], [Fermata, Fermata]] } },
            { type: 'optional', value: Ending },
            { type: 'optional', value: Repeat },
        ],
    };
    return Barline;
}());
exports.Barline = Barline;
/**
 * The `<feature>` element
 *
 * Parent element: `<grouping>`
 *
 * The `<feature>` element is a part of the <grouping> element used for musical analysis. The type attribute represents
 * the type of the feature and the element content represents its value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/feature/}
 */
var Feature = /** @class */ (function () {
    function Feature(opts) {
        var _a;
        this.schema = Feature.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Feature.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Feature.schema.contents);
    }
    /** Gets @type {FeatureAttributes['type']}. */
    Feature.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {FeatureAttributes['type']}. */
    Feature.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {string}. */
    Feature.prototype.getText = function () {
        return this.contents[0];
    };
    /** Sets @type {string}. */
    Feature.prototype.setText = function (text) {
        this.contents[0] = text;
        return this;
    };
    Feature.schema = {
        name: 'feature',
        attributes: { type: { type: 'optional', value: { type: 'string' } } },
        contents: [{ type: 'required', value: { type: 'string' } }],
    };
    return Feature;
}());
exports.Feature = Feature;
/**
 * The `<grouping>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<grouping>` element is used for musical analysis. When the type attribute is start or single, it usually
 * contains one or more <feature> elements. Feature elements contained within a stop type of grouping may be ignored.
 *
 * This element is flexible to allow for different types of analyses. Future versions of the MusicXML format may add
 * elements that can represent more standardized categories of analysis data, allowing for easier data sharing.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/grouping/}
 */
var Grouping = /** @class */ (function () {
    function Grouping(opts) {
        var _a;
        this.schema = Grouping.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, Grouping.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(Grouping.schema.contents);
    }
    /** Gets @type {GroupingAttributes['type']}. */
    Grouping.prototype.getType = function () {
        return this.attributes['type'];
    };
    /** Sets @type {GroupingAttributes['type']}. */
    Grouping.prototype.setType = function (type) {
        this.attributes['type'] = type;
        return this;
    };
    /** Gets @type {GroupingAttributes['id']}. */
    Grouping.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {GroupingAttributes['id']}. */
    Grouping.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {GroupingAttributes['member-of']}. */
    Grouping.prototype.getMemberOf = function () {
        return this.attributes['member-of'];
    };
    /** Sets @type {GroupingAttributes['member-of']}. */
    Grouping.prototype.setMemberOf = function (memberOf) {
        this.attributes['member-of'] = memberOf;
        return this;
    };
    /** Gets @type {GroupingAttributes['number']}. */
    Grouping.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {GroupingAttributes['number']}. */
    Grouping.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {Array<Feature>}. */
    Grouping.prototype.getFeatures = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Feature>}. */
    Grouping.prototype.setFeatures = function (features) {
        this.contents[0] = features;
        return this;
    };
    Grouping.schema = {
        name: 'grouping',
        attributes: {
            type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'single'] } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            'member-of': { type: 'optional', value: { type: 'string' } },
            number: { type: 'optional', value: { type: 'string' } },
        },
        contents: [{ type: 'label', label: 'features', value: { type: 'zeroOrMore', value: Feature } }],
    };
    return Grouping;
}());
exports.Grouping = Grouping;
/**
 * The `<measure>` element (partwise)
 *
 * Parent element: `<part>` (partwise)
 *
 * The `<measure>` element includes the basic musical data such as `<note>`s within a `<score-partwise version="4.0">` document.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-partwise/}
 */
var MeasurePartwise = /** @class */ (function () {
    function MeasurePartwise(opts) {
        var _a;
        this.schema = MeasurePartwise.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MeasurePartwise.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MeasurePartwise.schema.contents);
    }
    /** Gets @type {MeasurePartwiseAttributes['number']}. */
    MeasurePartwise.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {MeasurePartwiseAttributes['number']}. */
    MeasurePartwise.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {MeasurePartwiseAttributes['id']}. */
    MeasurePartwise.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {MeasurePartwiseAttributes['id']}. */
    MeasurePartwise.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {MeasurePartwiseAttributes['implicit']}. */
    MeasurePartwise.prototype.getImplicit = function () {
        return this.attributes['implicit'];
    };
    /** Sets @type {MeasurePartwiseAttributes['implicit']}. */
    MeasurePartwise.prototype.setImplicit = function (implicit) {
        this.attributes['implicit'] = implicit;
        return this;
    };
    /** Gets @type {MeasurePartwiseAttributes['non-controller']}. */
    MeasurePartwise.prototype.getNonController = function () {
        return this.attributes['non-controller'];
    };
    /** Sets @type {MeasurePartwiseAttributes['non-controller']}. */
    MeasurePartwise.prototype.setNonController = function (nonController) {
        this.attributes['non-controller'] = nonController;
        return this;
    };
    /** Gets @type {MeasurePartwiseAttributes['text']}. */
    MeasurePartwise.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {MeasurePartwiseAttributes['text']}. */
    MeasurePartwise.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {MeasurePartwiseAttributes['width']}. */
    MeasurePartwise.prototype.getWidth = function () {
        return this.attributes['width'];
    };
    /** Sets @type {MeasurePartwiseAttributes['width']}. */
    MeasurePartwise.prototype.setWidth = function (width) {
        this.attributes['width'] = width;
        return this;
    };
    /** Gets @type {Array<Note | Backup | Forward | Direction | Attributes | Harmony | FiguredBass | Print | Sound | Listening | Barline | Grouping | Link | Bookmark>}. */
    MeasurePartwise.prototype.getValues = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Note | Backup | Forward | Direction | Attributes | Harmony | FiguredBass | Print | Sound | Listening | Barline | Grouping | Link | Bookmark>}. */
    MeasurePartwise.prototype.setValues = function (values) {
        this.contents[0] = values;
        return this;
    };
    MeasurePartwise.schema = {
        name: 'measure',
        attributes: {
            number: { type: 'required', value: { type: 'string' } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            implicit: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'non-controller': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            text: {
                type: 'optional',
                value: {
                    type: 'not',
                    include: { type: 'choices', choices: ['yes', { type: 'string' }] },
                    exclude: { type: 'constant', value: '' },
                },
            },
            width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [
            {
                type: 'label',
                label: 'values',
                value: {
                    type: 'zeroOrMore',
                    value: {
                        type: 'choices',
                        choices: [
                            Note,
                            Backup,
                            Forward,
                            Direction,
                            Attributes,
                            Harmony,
                            FiguredBass,
                            Print,
                            Sound,
                            Listening,
                            Barline,
                            Grouping,
                            Link,
                            Bookmark,
                        ],
                    },
                },
            },
        ],
    };
    return MeasurePartwise;
}());
exports.MeasurePartwise = MeasurePartwise;
/**
 * The `<part>` element
 *
 * Parent element: `<score-partwise version="4.0">`
 *
 * The `<part>` element is the top level of musical organization below the `<score-partwise version="4.0">` document element. It
 * contains a sequence of `<measure>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-partwise/}
 */
var PartPartwise = /** @class */ (function () {
    function PartPartwise(opts) {
        var _a;
        this.schema = PartPartwise.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartPartwise.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartPartwise.schema.contents);
    }
    /** Gets @type {PartPartwiseAttributes['id']}. */
    PartPartwise.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {PartPartwiseAttributes['id']}. */
    PartPartwise.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {Array<MeasurePartwise>}. */
    PartPartwise.prototype.getMeasures = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<MeasurePartwise>}. */
    PartPartwise.prototype.setMeasures = function (measures) {
        this.contents[0] = measures;
        return this;
    };
    PartPartwise.schema = {
        name: 'part',
        attributes: { id: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
        contents: [{ type: 'label', label: 'measures', value: { type: 'oneOrMore', value: MeasurePartwise } }],
    };
    return PartPartwise;
}());
exports.PartPartwise = PartPartwise;
/**
 * The `<score-partwise version="4.0">` element
 *
 * Parent elements: None
 *
 * The `<score-partwise version="4.0">` element is the root element for a partwise MusicXML score. It includes score header
 * information followed by a series of `<part>` elements with `<measure>` elements inside.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/score-partwise/}
 */
var ScorePartwise = /** @class */ (function () {
    function ScorePartwise(opts) {
        var _a;
        this.schema = ScorePartwise.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ScorePartwise.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ScorePartwise.schema.contents);
    }
    /** Gets @type {ScorePartwiseAttributes['version']}. */
    ScorePartwise.prototype.getVersion = function () {
        return this.attributes['version'];
    };
    /** Sets @type {ScorePartwiseAttributes['version']}. */
    ScorePartwise.prototype.setVersion = function (version) {
        this.attributes['version'] = version;
        return this;
    };
    /** Gets @type {Work | null}. */
    ScorePartwise.prototype.getWork = function () {
        return this.contents[0];
    };
    /** Sets @type {Work | null}. */
    ScorePartwise.prototype.setWork = function (work) {
        this.contents[0] = work;
        return this;
    };
    /** Gets @type {MovementNumber | null}. */
    ScorePartwise.prototype.getMovementNumber = function () {
        return this.contents[1];
    };
    /** Sets @type {MovementNumber | null}. */
    ScorePartwise.prototype.setMovementNumber = function (movementNumber) {
        this.contents[1] = movementNumber;
        return this;
    };
    /** Gets @type {MovementTitle | null}. */
    ScorePartwise.prototype.getMovementTitle = function () {
        return this.contents[2];
    };
    /** Sets @type {MovementTitle | null}. */
    ScorePartwise.prototype.setMovementTitle = function (movementTitle) {
        this.contents[2] = movementTitle;
        return this;
    };
    /** Gets @type {Identification | null}. */
    ScorePartwise.prototype.getIdentification = function () {
        return this.contents[3];
    };
    /** Sets @type {Identification | null}. */
    ScorePartwise.prototype.setIdentification = function (identification) {
        this.contents[3] = identification;
        return this;
    };
    /** Gets @type {Defaults | null}. */
    ScorePartwise.prototype.getDefaults = function () {
        return this.contents[4];
    };
    /** Sets @type {Defaults | null}. */
    ScorePartwise.prototype.setDefaults = function (defaults) {
        this.contents[4] = defaults;
        return this;
    };
    /** Gets @type {Array<Credit>}. */
    ScorePartwise.prototype.getCredits = function () {
        return this.contents[5];
    };
    /** Sets @type {Array<Credit>}. */
    ScorePartwise.prototype.setCredits = function (credits) {
        this.contents[5] = credits;
        return this;
    };
    /** Gets @type {PartList}. */
    ScorePartwise.prototype.getPartList = function () {
        return this.contents[6];
    };
    /** Sets @type {PartList}. */
    ScorePartwise.prototype.setPartList = function (partList) {
        this.contents[6] = partList;
        return this;
    };
    /** Gets @type {Array<PartPartwise>}. */
    ScorePartwise.prototype.getParts = function () {
        return this.contents[7];
    };
    /** Sets @type {Array<PartPartwise>}. */
    ScorePartwise.prototype.setParts = function (parts) {
        this.contents[7] = parts;
        return this;
    };
    ScorePartwise.schema = {
        name: 'score-partwise',
        attributes: { version: { type: 'constant', value: '4.0' } },
        contents: [
            { type: 'optional', value: Work },
            { type: 'optional', value: MovementNumber },
            { type: 'optional', value: MovementTitle },
            { type: 'optional', value: Identification },
            { type: 'optional', value: Defaults },
            { type: 'label', label: 'credits', value: { type: 'zeroOrMore', value: Credit } },
            { type: 'required', value: PartList },
            { type: 'label', label: 'parts', value: { type: 'oneOrMore', value: PartPartwise } },
        ],
    };
    return ScorePartwise;
}());
exports.ScorePartwise = ScorePartwise;
/**
 * The `<part>` element (timewise)
 *
 * Parent element: `<measure>` (timewise)
 *
 * The `<part>` element includes the basic musical data such as `<note>`s within a `<score-timewise>` document.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-partwise/}
 */
var PartTimewise = /** @class */ (function () {
    function PartTimewise(opts) {
        var _a;
        this.schema = PartTimewise.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, PartTimewise.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(PartTimewise.schema.contents);
    }
    /** Gets @type {PartTimewiseAttributes['id']}. */
    PartTimewise.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {PartTimewiseAttributes['id']}. */
    PartTimewise.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {Array<Note | Backup | Forward | Direction | Attributes | Harmony | FiguredBass | Print | Sound | Listening | Barline | Grouping | Link | Bookmark>}. */
    PartTimewise.prototype.getValues = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<Note | Backup | Forward | Direction | Attributes | Harmony | FiguredBass | Print | Sound | Listening | Barline | Grouping | Link | Bookmark>}. */
    PartTimewise.prototype.setValues = function (values) {
        this.contents[0] = values;
        return this;
    };
    PartTimewise.schema = {
        name: 'part',
        attributes: { id: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
        contents: [
            {
                type: 'label',
                label: 'values',
                value: {
                    type: 'zeroOrMore',
                    value: {
                        type: 'choices',
                        choices: [
                            Note,
                            Backup,
                            Forward,
                            Direction,
                            Attributes,
                            Harmony,
                            FiguredBass,
                            Print,
                            Sound,
                            Listening,
                            Barline,
                            Grouping,
                            Link,
                            Bookmark,
                        ],
                    },
                },
            },
        ],
    };
    return PartTimewise;
}());
exports.PartTimewise = PartTimewise;
/**
 * The `<measure>` element (timewise)
 *
 * Parent element: `<score-timewise>`
 *
 * The `<measure>` element is the top level of musical organization below the `<score-timewise>` document element. It
 * contains a sequence of `<part>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-timewise/}
 */
var MeasureTimewise = /** @class */ (function () {
    function MeasureTimewise(opts) {
        var _a;
        this.schema = MeasureTimewise.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, MeasureTimewise.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(MeasureTimewise.schema.contents);
    }
    /** Gets @type {MeasureTimewiseAttributes['number']}. */
    MeasureTimewise.prototype.getNumber = function () {
        return this.attributes['number'];
    };
    /** Sets @type {MeasureTimewiseAttributes['number']}. */
    MeasureTimewise.prototype.setNumber = function (number) {
        this.attributes['number'] = number;
        return this;
    };
    /** Gets @type {MeasureTimewiseAttributes['id']}. */
    MeasureTimewise.prototype.getId = function () {
        return this.attributes['id'];
    };
    /** Sets @type {MeasureTimewiseAttributes['id']}. */
    MeasureTimewise.prototype.setId = function (id) {
        this.attributes['id'] = id;
        return this;
    };
    /** Gets @type {MeasureTimewiseAttributes['implicit']}. */
    MeasureTimewise.prototype.getImplicit = function () {
        return this.attributes['implicit'];
    };
    /** Sets @type {MeasureTimewiseAttributes['implicit']}. */
    MeasureTimewise.prototype.setImplicit = function (implicit) {
        this.attributes['implicit'] = implicit;
        return this;
    };
    /** Gets @type {MeasureTimewiseAttributes['non-controller']}. */
    MeasureTimewise.prototype.getNonController = function () {
        return this.attributes['non-controller'];
    };
    /** Sets @type {MeasureTimewiseAttributes['non-controller']}. */
    MeasureTimewise.prototype.setNonController = function (nonController) {
        this.attributes['non-controller'] = nonController;
        return this;
    };
    /** Gets @type {MeasureTimewiseAttributes['text']}. */
    MeasureTimewise.prototype.getText = function () {
        return this.attributes['text'];
    };
    /** Sets @type {MeasureTimewiseAttributes['text']}. */
    MeasureTimewise.prototype.setText = function (text) {
        this.attributes['text'] = text;
        return this;
    };
    /** Gets @type {MeasureTimewiseAttributes['width']}. */
    MeasureTimewise.prototype.getWidth = function () {
        return this.attributes['width'];
    };
    /** Sets @type {MeasureTimewiseAttributes['width']}. */
    MeasureTimewise.prototype.setWidth = function (width) {
        this.attributes['width'] = width;
        return this;
    };
    /** Gets @type {Array<PartTimewise>}. */
    MeasureTimewise.prototype.getParts = function () {
        return this.contents[0];
    };
    /** Sets @type {Array<PartTimewise>}. */
    MeasureTimewise.prototype.setParts = function (parts) {
        this.contents[0] = parts;
        return this;
    };
    MeasureTimewise.schema = {
        name: 'measure',
        attributes: {
            number: { type: 'required', value: { type: 'string' } },
            id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
            implicit: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            'non-controller': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
            text: {
                type: 'optional',
                value: {
                    type: 'not',
                    include: { type: 'choices', choices: ['yes', { type: 'string' }] },
                    exclude: { type: 'constant', value: '' },
                },
            },
            width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
        },
        contents: [{ type: 'label', label: 'parts', value: { type: 'oneOrMore', value: PartTimewise } }],
    };
    return MeasureTimewise;
}());
exports.MeasureTimewise = MeasureTimewise;
/**
 * The `<score-timewise>` element
 *
 * Parent elements: None
 *
 * The `<score-timewise>` element is the root element for a timewise MusicXML score. It includes score header
 * information followed by a series of `<measure>` elements with `<part>` elements inside.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/score-timewise/}
 */
var ScoreTimewise = /** @class */ (function () {
    function ScoreTimewise(opts) {
        var _a;
        this.schema = ScoreTimewise.schema;
        this.attributes = operations.merge((opts === null || opts === void 0 ? void 0 : opts.attributes) || {}, ScoreTimewise.schema);
        this.contents = (_a = opts === null || opts === void 0 ? void 0 : opts.contents) !== null && _a !== void 0 ? _a : operations.zero(ScoreTimewise.schema.contents);
    }
    /** Gets @type {ScoreTimewiseAttributes['version']}. */
    ScoreTimewise.prototype.getVersion = function () {
        return this.attributes['version'];
    };
    /** Sets @type {ScoreTimewiseAttributes['version']}. */
    ScoreTimewise.prototype.setVersion = function (version) {
        this.attributes['version'] = version;
        return this;
    };
    /** Gets @type {Work | null}. */
    ScoreTimewise.prototype.getWork = function () {
        return this.contents[0];
    };
    /** Sets @type {Work | null}. */
    ScoreTimewise.prototype.setWork = function (work) {
        this.contents[0] = work;
        return this;
    };
    /** Gets @type {MovementNumber | null}. */
    ScoreTimewise.prototype.getMovementNumber = function () {
        return this.contents[1];
    };
    /** Sets @type {MovementNumber | null}. */
    ScoreTimewise.prototype.setMovementNumber = function (movementNumber) {
        this.contents[1] = movementNumber;
        return this;
    };
    /** Gets @type {MovementTitle | null}. */
    ScoreTimewise.prototype.getMovementTitle = function () {
        return this.contents[2];
    };
    /** Sets @type {MovementTitle | null}. */
    ScoreTimewise.prototype.setMovementTitle = function (movementTitle) {
        this.contents[2] = movementTitle;
        return this;
    };
    /** Gets @type {Identification | null}. */
    ScoreTimewise.prototype.getIdentification = function () {
        return this.contents[3];
    };
    /** Sets @type {Identification | null}. */
    ScoreTimewise.prototype.setIdentification = function (identification) {
        this.contents[3] = identification;
        return this;
    };
    /** Gets @type {Defaults | null}. */
    ScoreTimewise.prototype.getDefaults = function () {
        return this.contents[4];
    };
    /** Sets @type {Defaults | null}. */
    ScoreTimewise.prototype.setDefaults = function (defaults) {
        this.contents[4] = defaults;
        return this;
    };
    /** Gets @type {Array<Credit>}. */
    ScoreTimewise.prototype.getCredits = function () {
        return this.contents[5];
    };
    /** Sets @type {Array<Credit>}. */
    ScoreTimewise.prototype.setCredits = function (credits) {
        this.contents[5] = credits;
        return this;
    };
    /** Gets @type {PartList}. */
    ScoreTimewise.prototype.getPartList = function () {
        return this.contents[6];
    };
    /** Sets @type {PartList}. */
    ScoreTimewise.prototype.setPartList = function (partList) {
        this.contents[6] = partList;
        return this;
    };
    /** Gets @type {Array<MeasureTimewise>}. */
    ScoreTimewise.prototype.getMeasures = function () {
        return this.contents[7];
    };
    /** Sets @type {Array<MeasureTimewise>}. */
    ScoreTimewise.prototype.setMeasures = function (measures) {
        this.contents[7] = measures;
        return this;
    };
    ScoreTimewise.schema = {
        name: 'score-timewise',
        attributes: { version: { type: 'constant', value: '4.0' } },
        contents: [
            { type: 'optional', value: Work },
            { type: 'optional', value: MovementNumber },
            { type: 'optional', value: MovementTitle },
            { type: 'optional', value: Identification },
            { type: 'optional', value: Defaults },
            { type: 'label', label: 'credits', value: { type: 'zeroOrMore', value: Credit } },
            { type: 'required', value: PartList },
            { type: 'label', label: 'measures', value: { type: 'oneOrMore', value: MeasureTimewise } },
        ],
    };
    return ScoreTimewise;
}());
exports.ScoreTimewise = ScoreTimewise;

},{"../lib/operations":"node_modules/@stringsync/musicxml/dist/lib/operations/index.js"}],"node_modules/@stringsync/musicxml/dist/generated/asserts.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isCancel = exports.isCaesura = exports.isBreathMark = exports.isBrassBend = exports.isBracket = exports.isBottomMargin = exports.isBookmark = exports.isBendAlter = exports.isBend = exports.isBeats = exports.isBeater = exports.isBeatUnitTied = exports.isBeatUnitDot = exports.isBeatUnit = exports.isBeatType = exports.isBeatSpec = exports.isBeatRepeat = exports.isBeam = exports.isBassStep = exports.isBassSeparator = exports.isBassAlter = exports.isBass = exports.isBasePitch = exports.isBarre = exports.isBarline = exports.isBarStyle = exports.isBackup = exports.isAttributes = exports.isAssess = exports.isArtificial = exports.isArticulations = exports.isArrowhead = exports.isArrowStyle = exports.isArrowDirection = exports.isArrow = exports.isArpeggiate = exports.isAppearance = exports.isAlternateSwing = exports.isAlternateKey = exports.isAlter = exports.isActualNotes = exports.isAccordionRegistration = exports.isAccordionMiddle = exports.isAccordionLow = exports.isAccordionHigh = exports.isAccord = exports.isAccidentalText = exports.isAccidentalMark = exports.isAccidental = exports.isAccent = void 0;
exports.isElision = exports.isElevation = exports.isEffect = exports.isDynamicsList = exports.isDynamics = exports.isDuration = exports.isDownBow = exports.isDoubleTongue = exports.isDouble = exports.isDot = exports.isDoit = exports.isDivisions = exports.isDistance = exports.isDisplayText = exports.isDisplayStep = exports.isDisplayOctave = exports.isDirective = exports.isDirectionType = exports.isDirection = exports.isDiatonic = exports.isDetachedLegato = exports.isDelayedTurn = exports.isDelayedInvertedTurn = exports.isDegreeValue = exports.isDegreeType = exports.isDegreeAlter = exports.isDegree = exports.isDefaults = exports.isDashes = exports.isDampAll = exports.isDamp = exports.isCuedNote = exports.isCuedGraceNote = exports.isCue = exports.isCreditWords = exports.isCreditType = exports.isCreditToken = exports.isCreditSymbol = exports.isCreditImage = exports.isCredit = exports.isCreator = exports.isConcertScore = exports.isCodas = exports.isCoda = exports.isClefOctaveChange = exports.isClef = exports.isCircularArrow = exports.isChromatic = exports.isChord = exports.isCapo = void 0;
exports.isGroupBarline = exports.isGroupAbbreviationDisplay = exports.isGroupAbbreviation = exports.isGroup = exports.isGrace = exports.isGolpe = exports.isGlyph = exports.isGlissando = exports.isGlass = exports.isFz = exports.isFunction = exports.isFret = exports.isFrameStrings = exports.isFrameNote = exports.isFrameFrets = exports.isFrame = exports.isFp = exports.isForward = exports.isForParts = exports.isForPart = exports.isFootnote = exports.isFlip = exports.isFirstFret = exports.isFirst = exports.isFingernails = exports.isFingering = exports.isFiguredBass = exports.isFigureNumber = exports.isFigure = exports.isFifths = exports.isFfffff = exports.isFffff = exports.isFfff = exports.isFff = exports.isFf = exports.isFermata = exports.isFeature = exports.isFalloff = exports.isF = exports.isEyeglasses = exports.isExtend = exports.isExceptVoice = exports.isEnsemble = exports.isEnding = exports.isEndParagraph = exports.isEndLine = exports.isEncodingDescription = exports.isEncodingDate = exports.isEncoding = exports.isEncoder = void 0;
exports.isLink = exports.isLineWidth = exports.isLineDetail = exports.isLine = exports.isLevel = exports.isLeftMargin = exports.isLaughing = exports.isKind = exports.isKeyStep = exports.isKeyOctave = exports.isKeyAlter = exports.isKeyAccidental = exports.isKey = exports.isIpa = exports.isInvertedVerticalTurn = exports.isInvertedTurn = exports.isInvertedMordent = exports.isInversion = exports.isInterchangeable = exports.isIntelligible = exports.isInstruments = exports.isInstrumentSound = exports.isInstrumentName = exports.isInstrumentLink = exports.isInstrumentChange = exports.isInstrumentAbbreviation = exports.isInstrument = exports.isImage = exports.isIdentification = exports.isHumming = exports.isHoleType = exports.isHoleShape = exports.isHoleClosed = exports.isHole = exports.isHeel = exports.isHaydn = exports.isHarpPedals = exports.isHarmony = exports.isHarmonic = exports.isHarmonMute = exports.isHarmonClosed = exports.isHandbell = exports.isHammerOn = exports.isHalfMuted = exports.isGrouping = exports.isGroupTime = exports.isGroupSymbol = exports.isGroupNameDisplay = exports.isGroupName = exports.isGroupLink = void 0;
exports.isNotations = exports.isNormalType = exports.isNormalNotes = exports.isNormalDot = exports.isNonArpeggiate = exports.isNatural = exports.isN = exports.isMute = exports.isMusicFont = exports.isMultipleRest = exports.isMp = exports.isMovementTitle = exports.isMovementNumber = exports.isMordent = exports.isMode = exports.isMiscellaneousField = exports.isMiscellaneous = exports.isMillimeters = exports.isMidiUnpitched = exports.isMidiProgram = exports.isMidiName = exports.isMidiInstrument = exports.isMidiDevice = exports.isMidiChannel = exports.isMidiBank = exports.isMf = exports.isMetronomeType = exports.isMetronomeTuplet = exports.isMetronomeTied = exports.isMetronomeSpec = exports.isMetronomeRelation = exports.isMetronomeNote = exports.isMetronomeDot = exports.isMetronomeBeam = exports.isMetronomeArrows = exports.isMetronome = exports.isMetal = exports.isMembrane = exports.isMeasureTimewise = exports.isMeasureStyle = exports.isMeasureRepeat = exports.isMeasurePartwise = exports.isMeasureNumbering = exports.isMeasureLayout = exports.isMeasureDistance = exports.isLyricLanguage = exports.isLyricFont = exports.isLyric = exports.isListening = exports.isListen = void 0;
exports.isPedalStep = exports.isPedalAlter = exports.isPedal = exports.isPartTranspose = exports.isPartTimewise = exports.isPartSymbol = exports.isPartPartwise = exports.isPartNameDisplay = exports.isPartName = exports.isPartList = exports.isPartLink = exports.isPartGroup = exports.isPartClef = exports.isPartAbbreviationDisplay = exports.isPartAbbreviation = exports.isPan = exports.isPageWidth = exports.isPageMargins = exports.isPageLayout = exports.isPageHeight = exports.isP = exports.isOtherTechnical = exports.isOtherPlay = exports.isOtherPercussion = exports.isOtherOrnament = exports.isOtherNotation = exports.isOtherListening = exports.isOtherListen = exports.isOtherDynamics = exports.isOtherDirection = exports.isOtherArticulation = exports.isOtherAppearance = exports.isOrnaments = exports.isOpus = exports.isOpenString = exports.isOpen = exports.isOffset = exports.isOctaveShift = exports.isOctaveChange = exports.isOctave = exports.isNumeralRoot = exports.isNumeralMode = exports.isNumeralKey = exports.isNumeralFifths = exports.isNumeralAlter = exports.isNumeral = exports.isNoteheadText = exports.isNotehead = exports.isNoteSize = exports.isNote = void 0;
exports.isSfp = exports.isSffz = exports.isSf = exports.isSenzaMisura = exports.isSemiPitched = exports.isSegnos = exports.isSegno = exports.isSecond = exports.isScoreTimewise = exports.isScorePartwise = exports.isScorePart = exports.isScoreInstrument = exports.isScordatura = exports.isScoop = exports.isSchleifer = exports.isScaling = exports.isRootStep = exports.isRootAlter = exports.isRoot = exports.isRights = exports.isRightMargin = exports.isRfz = exports.isRf = exports.isRest = exports.isRepeat = exports.isRelease = exports.isRelation = exports.isRehearsals = exports.isRehearsal = exports.isPullOff = exports.isPrint = exports.isPrincipalVoice = exports.isPrefix = exports.isPreBend = exports.isPppppp = exports.isPpppp = exports.isPppp = exports.isPpp = exports.isPp = exports.isPluck = exports.isPlop = exports.isPlayer = exports.isPlay = exports.isPitched = exports.isPitch = exports.isPf = exports.isPercussions = exports.isPercussion = exports.isPerMinute = exports.isPedalTuning = void 0;
exports.isSymbol = exports.isSyllabic = exports.isSwingType = exports.isSwingStyle = exports.isSwing = exports.isSupports = exports.isSuffix = exports.isStrongAccent = exports.isStringMute = exports.isString = exports.isStress = exports.isStraight = exports.isStopped = exports.isStickType = exports.isStickMaterial = exports.isStickLocation = exports.isStick = exports.isStep = exports.isStem = exports.isStaves = exports.isStaffType = exports.isStaffTuning = exports.isStaffSize = exports.isStaffLines = exports.isStaffLayout = exports.isStaffDivide = exports.isStaffDistance = exports.isStaffDetails = exports.isStaff = exports.isStaccato = exports.isStaccatissimo = exports.isSpiccato = exports.isSource = exports.isSoundingPitch = exports.isSound = exports.isSolo = exports.isSoftware = exports.isSoftAccent = exports.isSnapPizzicato = exports.isSmear = exports.isSlur = exports.isSlide = exports.isSlashType = exports.isSlashDot = exports.isSlash = exports.isSign = exports.isShake = exports.isSfzp = exports.isSfz = exports.isSfpp = void 0;
exports.isVolume = exports.isVoice = exports.isVirtualName = exports.isVirtualLibrary = exports.isVirtualInstrument = exports.isVerticalTurn = exports.isUpBow = exports.isUnstress = exports.isUnpitched = exports.isType = exports.isTurn = exports.isTupletType = exports.isTupletNumber = exports.isTupletNormal = exports.isTupletDot = exports.isTupletActual = exports.isTuplet = exports.isTuningStep = exports.isTuningOctave = exports.isTuningAlter = exports.isTripleTongue = exports.isTrillMark = exports.isTremolo = exports.isTransposes = exports.isTranspose = exports.isTranditionalKey = exports.isTouchingPitch = exports.isTopSystemDistance = exports.isTopMargin = exports.isTokens = exports.isToe = exports.isTimpani = exports.isTimeSignature = exports.isTimeRelation = exports.isTimeModification = exports.isTime = exports.isTiedNote = exports.isTiedGraceNote = exports.isTied = exports.isTie = exports.isThumbPosition = exports.isText = exports.isTenuto = exports.isTenths = exports.isTechnical = exports.isTap = exports.isSystemMargins = exports.isSystemLayout = exports.isSystemDistance = exports.isSync = void 0;
exports.isWorkTitle = exports.isWorkNumber = exports.isWork = exports.isWords = exports.isWordFont = exports.isWood = exports.isWithBar = exports.isWedge = exports.isWavyLine = exports.isWait = void 0;
var operations = require("../lib/operations");
var elements = require("./elements");
var isAccent = function (value) {
    return operations.validate(value, elements.Accent);
};
exports.isAccent = isAccent;
var isAccidental = function (value) {
    return operations.validate(value, elements.Accidental);
};
exports.isAccidental = isAccidental;
var isAccidentalMark = function (value) {
    return operations.validate(value, elements.AccidentalMark);
};
exports.isAccidentalMark = isAccidentalMark;
var isAccidentalText = function (value) {
    return operations.validate(value, elements.AccidentalText);
};
exports.isAccidentalText = isAccidentalText;
var isAccord = function (value) {
    return operations.validate(value, elements.Accord);
};
exports.isAccord = isAccord;
var isAccordionHigh = function (value) {
    return operations.validate(value, elements.AccordionHigh);
};
exports.isAccordionHigh = isAccordionHigh;
var isAccordionLow = function (value) {
    return operations.validate(value, elements.AccordionLow);
};
exports.isAccordionLow = isAccordionLow;
var isAccordionMiddle = function (value) {
    return operations.validate(value, elements.AccordionMiddle);
};
exports.isAccordionMiddle = isAccordionMiddle;
var isAccordionRegistration = function (value) {
    return operations.validate(value, elements.AccordionRegistration);
};
exports.isAccordionRegistration = isAccordionRegistration;
var isActualNotes = function (value) {
    return operations.validate(value, elements.ActualNotes);
};
exports.isActualNotes = isActualNotes;
var isAlter = function (value) {
    return operations.validate(value, elements.Alter);
};
exports.isAlter = isAlter;
var isAlternateKey = function (value) {
    return operations.validate(value, elements.Key.schema.contents[0]['value']['choices'][1]);
};
exports.isAlternateKey = isAlternateKey;
var isAlternateSwing = function (value) {
    return operations.validate(value, elements.Swing.schema.contents[0]['value']['choices'][1]);
};
exports.isAlternateSwing = isAlternateSwing;
var isAppearance = function (value) {
    return operations.validate(value, elements.Appearance);
};
exports.isAppearance = isAppearance;
var isArpeggiate = function (value) {
    return operations.validate(value, elements.Arpeggiate);
};
exports.isArpeggiate = isArpeggiate;
var isArrow = function (value) {
    return operations.validate(value, elements.Arrow);
};
exports.isArrow = isArrow;
var isArrowDirection = function (value) {
    return operations.validate(value, elements.ArrowDirection);
};
exports.isArrowDirection = isArrowDirection;
var isArrowStyle = function (value) {
    return operations.validate(value, elements.ArrowStyle);
};
exports.isArrowStyle = isArrowStyle;
var isArrowhead = function (value) {
    return operations.validate(value, elements.Arrowhead);
};
exports.isArrowhead = isArrowhead;
var isArticulations = function (value) {
    return operations.validate(value, elements.Articulations);
};
exports.isArticulations = isArticulations;
var isArtificial = function (value) {
    return operations.validate(value, elements.Artificial);
};
exports.isArtificial = isArtificial;
var isAssess = function (value) {
    return operations.validate(value, elements.Assess);
};
exports.isAssess = isAssess;
var isAttributes = function (value) {
    return operations.validate(value, elements.Attributes);
};
exports.isAttributes = isAttributes;
var isBackup = function (value) {
    return operations.validate(value, elements.Backup);
};
exports.isBackup = isBackup;
var isBarStyle = function (value) {
    return operations.validate(value, elements.BarStyle);
};
exports.isBarStyle = isBarStyle;
var isBarline = function (value) {
    return operations.validate(value, elements.Barline);
};
exports.isBarline = isBarline;
var isBarre = function (value) {
    return operations.validate(value, elements.Barre);
};
exports.isBarre = isBarre;
var isBasePitch = function (value) {
    return operations.validate(value, elements.BasePitch);
};
exports.isBasePitch = isBasePitch;
var isBass = function (value) {
    return operations.validate(value, elements.Bass);
};
exports.isBass = isBass;
var isBassAlter = function (value) {
    return operations.validate(value, elements.BassAlter);
};
exports.isBassAlter = isBassAlter;
var isBassSeparator = function (value) {
    return operations.validate(value, elements.BassSeparator);
};
exports.isBassSeparator = isBassSeparator;
var isBassStep = function (value) {
    return operations.validate(value, elements.BassStep);
};
exports.isBassStep = isBassStep;
var isBeam = function (value) {
    return operations.validate(value, elements.Beam);
};
exports.isBeam = isBeam;
var isBeatRepeat = function (value) {
    return operations.validate(value, elements.BeatRepeat);
};
exports.isBeatRepeat = isBeatRepeat;
var isBeatSpec = function (value) {
    return operations.validate(value, elements.Metronome.schema.contents[0]['value']['choices'][0]);
};
exports.isBeatSpec = isBeatSpec;
var isBeatType = function (value) {
    return operations.validate(value, elements.BeatType);
};
exports.isBeatType = isBeatType;
var isBeatUnit = function (value) {
    return operations.validate(value, elements.BeatUnit);
};
exports.isBeatUnit = isBeatUnit;
var isBeatUnitDot = function (value) {
    return operations.validate(value, elements.BeatUnitDot);
};
exports.isBeatUnitDot = isBeatUnitDot;
var isBeatUnitTied = function (value) {
    return operations.validate(value, elements.BeatUnitTied);
};
exports.isBeatUnitTied = isBeatUnitTied;
var isBeater = function (value) {
    return operations.validate(value, elements.Beater);
};
exports.isBeater = isBeater;
var isBeats = function (value) {
    return operations.validate(value, elements.Beats);
};
exports.isBeats = isBeats;
var isBend = function (value) {
    return operations.validate(value, elements.Bend);
};
exports.isBend = isBend;
var isBendAlter = function (value) {
    return operations.validate(value, elements.BendAlter);
};
exports.isBendAlter = isBendAlter;
var isBookmark = function (value) {
    return operations.validate(value, elements.Bookmark);
};
exports.isBookmark = isBookmark;
var isBottomMargin = function (value) {
    return operations.validate(value, elements.BottomMargin);
};
exports.isBottomMargin = isBottomMargin;
var isBracket = function (value) {
    return operations.validate(value, elements.Bracket);
};
exports.isBracket = isBracket;
var isBrassBend = function (value) {
    return operations.validate(value, elements.BrassBend);
};
exports.isBrassBend = isBrassBend;
var isBreathMark = function (value) {
    return operations.validate(value, elements.BreathMark);
};
exports.isBreathMark = isBreathMark;
var isCaesura = function (value) {
    return operations.validate(value, elements.Caesura);
};
exports.isCaesura = isCaesura;
var isCancel = function (value) {
    return operations.validate(value, elements.Cancel);
};
exports.isCancel = isCancel;
var isCapo = function (value) {
    return operations.validate(value, elements.Capo);
};
exports.isCapo = isCapo;
var isChord = function (value) {
    return operations.validate(value, elements.Chord);
};
exports.isChord = isChord;
var isChromatic = function (value) {
    return operations.validate(value, elements.Chromatic);
};
exports.isChromatic = isChromatic;
var isCircularArrow = function (value) {
    return operations.validate(value, elements.CircularArrow);
};
exports.isCircularArrow = isCircularArrow;
var isClef = function (value) {
    return operations.validate(value, elements.Clef);
};
exports.isClef = isClef;
var isClefOctaveChange = function (value) {
    return operations.validate(value, elements.ClefOctaveChange);
};
exports.isClefOctaveChange = isClefOctaveChange;
var isCoda = function (value) {
    return operations.validate(value, elements.Coda);
};
exports.isCoda = isCoda;
var isCodas = function (value) {
    return operations.validate(value, elements.DirectionType.schema.contents[0]['value']['choices'][2]);
};
exports.isCodas = isCodas;
var isConcertScore = function (value) {
    return operations.validate(value, elements.ConcertScore);
};
exports.isConcertScore = isConcertScore;
var isCreator = function (value) {
    return operations.validate(value, elements.Creator);
};
exports.isCreator = isCreator;
var isCredit = function (value) {
    return operations.validate(value, elements.Credit);
};
exports.isCredit = isCredit;
var isCreditImage = function (value) {
    return operations.validate(value, elements.CreditImage);
};
exports.isCreditImage = isCreditImage;
var isCreditSymbol = function (value) {
    return operations.validate(value, elements.CreditSymbol);
};
exports.isCreditSymbol = isCreditSymbol;
var isCreditToken = function (value) {
    return operations.validate(value, elements.Credit.schema.contents[3]['value']['choices'][1]);
};
exports.isCreditToken = isCreditToken;
var isCreditType = function (value) {
    return operations.validate(value, elements.CreditType);
};
exports.isCreditType = isCreditType;
var isCreditWords = function (value) {
    return operations.validate(value, elements.CreditWords);
};
exports.isCreditWords = isCreditWords;
var isCue = function (value) {
    return operations.validate(value, elements.Cue);
};
exports.isCue = isCue;
var isCuedGraceNote = function (value) {
    return operations.validate(value, elements.Note.schema.contents[0]['value']['choices'][3]);
};
exports.isCuedGraceNote = isCuedGraceNote;
var isCuedNote = function (value) {
    return operations.validate(value, elements.Note.schema.contents[0]['value']['choices'][1]);
};
exports.isCuedNote = isCuedNote;
var isDamp = function (value) {
    return operations.validate(value, elements.Damp);
};
exports.isDamp = isDamp;
var isDampAll = function (value) {
    return operations.validate(value, elements.DampAll);
};
exports.isDampAll = isDampAll;
var isDashes = function (value) {
    return operations.validate(value, elements.Dashes);
};
exports.isDashes = isDashes;
var isDefaults = function (value) {
    return operations.validate(value, elements.Defaults);
};
exports.isDefaults = isDefaults;
var isDegree = function (value) {
    return operations.validate(value, elements.Degree);
};
exports.isDegree = isDegree;
var isDegreeAlter = function (value) {
    return operations.validate(value, elements.DegreeAlter);
};
exports.isDegreeAlter = isDegreeAlter;
var isDegreeType = function (value) {
    return operations.validate(value, elements.DegreeType);
};
exports.isDegreeType = isDegreeType;
var isDegreeValue = function (value) {
    return operations.validate(value, elements.DegreeValue);
};
exports.isDegreeValue = isDegreeValue;
var isDelayedInvertedTurn = function (value) {
    return operations.validate(value, elements.DelayedInvertedTurn);
};
exports.isDelayedInvertedTurn = isDelayedInvertedTurn;
var isDelayedTurn = function (value) {
    return operations.validate(value, elements.DelayedTurn);
};
exports.isDelayedTurn = isDelayedTurn;
var isDetachedLegato = function (value) {
    return operations.validate(value, elements.DetachedLegato);
};
exports.isDetachedLegato = isDetachedLegato;
var isDiatonic = function (value) {
    return operations.validate(value, elements.Diatonic);
};
exports.isDiatonic = isDiatonic;
var isDirection = function (value) {
    return operations.validate(value, elements.Direction);
};
exports.isDirection = isDirection;
var isDirectionType = function (value) {
    return operations.validate(value, elements.DirectionType);
};
exports.isDirectionType = isDirectionType;
var isDirective = function (value) {
    return operations.validate(value, elements.Directive);
};
exports.isDirective = isDirective;
var isDisplayOctave = function (value) {
    return operations.validate(value, elements.DisplayOctave);
};
exports.isDisplayOctave = isDisplayOctave;
var isDisplayStep = function (value) {
    return operations.validate(value, elements.DisplayStep);
};
exports.isDisplayStep = isDisplayStep;
var isDisplayText = function (value) {
    return operations.validate(value, elements.DisplayText);
};
exports.isDisplayText = isDisplayText;
var isDistance = function (value) {
    return operations.validate(value, elements.Distance);
};
exports.isDistance = isDistance;
var isDivisions = function (value) {
    return operations.validate(value, elements.Divisions);
};
exports.isDivisions = isDivisions;
var isDoit = function (value) {
    return operations.validate(value, elements.Doit);
};
exports.isDoit = isDoit;
var isDot = function (value) {
    return operations.validate(value, elements.Dot);
};
exports.isDot = isDot;
var isDouble = function (value) {
    return operations.validate(value, elements.Double);
};
exports.isDouble = isDouble;
var isDoubleTongue = function (value) {
    return operations.validate(value, elements.DoubleTongue);
};
exports.isDoubleTongue = isDoubleTongue;
var isDownBow = function (value) {
    return operations.validate(value, elements.DownBow);
};
exports.isDownBow = isDownBow;
var isDuration = function (value) {
    return operations.validate(value, elements.Duration);
};
exports.isDuration = isDuration;
var isDynamics = function (value) {
    return operations.validate(value, elements.Dynamics);
};
exports.isDynamics = isDynamics;
var isDynamicsList = function (value) {
    return operations.validate(value, elements.DirectionType.schema.contents[0]['value']['choices'][5]);
};
exports.isDynamicsList = isDynamicsList;
var isEffect = function (value) {
    return operations.validate(value, elements.Effect);
};
exports.isEffect = isEffect;
var isElevation = function (value) {
    return operations.validate(value, elements.Elevation);
};
exports.isElevation = isElevation;
var isElision = function (value) {
    return operations.validate(value, elements.Elision);
};
exports.isElision = isElision;
var isEncoder = function (value) {
    return operations.validate(value, elements.Encoder);
};
exports.isEncoder = isEncoder;
var isEncoding = function (value) {
    return operations.validate(value, elements.Encoding);
};
exports.isEncoding = isEncoding;
var isEncodingDate = function (value) {
    return operations.validate(value, elements.EncodingDate);
};
exports.isEncodingDate = isEncodingDate;
var isEncodingDescription = function (value) {
    return operations.validate(value, elements.EncodingDescription);
};
exports.isEncodingDescription = isEncodingDescription;
var isEndLine = function (value) {
    return operations.validate(value, elements.EndLine);
};
exports.isEndLine = isEndLine;
var isEndParagraph = function (value) {
    return operations.validate(value, elements.EndParagraph);
};
exports.isEndParagraph = isEndParagraph;
var isEnding = function (value) {
    return operations.validate(value, elements.Ending);
};
exports.isEnding = isEnding;
var isEnsemble = function (value) {
    return operations.validate(value, elements.Ensemble);
};
exports.isEnsemble = isEnsemble;
var isExceptVoice = function (value) {
    return operations.validate(value, elements.ExceptVoice);
};
exports.isExceptVoice = isExceptVoice;
var isExtend = function (value) {
    return operations.validate(value, elements.Extend);
};
exports.isExtend = isExtend;
var isEyeglasses = function (value) {
    return operations.validate(value, elements.Eyeglasses);
};
exports.isEyeglasses = isEyeglasses;
var isF = function (value) {
    return operations.validate(value, elements.F);
};
exports.isF = isF;
var isFalloff = function (value) {
    return operations.validate(value, elements.Falloff);
};
exports.isFalloff = isFalloff;
var isFeature = function (value) {
    return operations.validate(value, elements.Feature);
};
exports.isFeature = isFeature;
var isFermata = function (value) {
    return operations.validate(value, elements.Fermata);
};
exports.isFermata = isFermata;
var isFf = function (value) {
    return operations.validate(value, elements.Ff);
};
exports.isFf = isFf;
var isFff = function (value) {
    return operations.validate(value, elements.Fff);
};
exports.isFff = isFff;
var isFfff = function (value) {
    return operations.validate(value, elements.Ffff);
};
exports.isFfff = isFfff;
var isFffff = function (value) {
    return operations.validate(value, elements.Fffff);
};
exports.isFffff = isFffff;
var isFfffff = function (value) {
    return operations.validate(value, elements.Ffffff);
};
exports.isFfffff = isFfffff;
var isFifths = function (value) {
    return operations.validate(value, elements.Fifths);
};
exports.isFifths = isFifths;
var isFigure = function (value) {
    return operations.validate(value, elements.Figure);
};
exports.isFigure = isFigure;
var isFigureNumber = function (value) {
    return operations.validate(value, elements.FigureNumber);
};
exports.isFigureNumber = isFigureNumber;
var isFiguredBass = function (value) {
    return operations.validate(value, elements.FiguredBass);
};
exports.isFiguredBass = isFiguredBass;
var isFingering = function (value) {
    return operations.validate(value, elements.Fingering);
};
exports.isFingering = isFingering;
var isFingernails = function (value) {
    return operations.validate(value, elements.Fingernails);
};
exports.isFingernails = isFingernails;
var isFirst = function (value) {
    return operations.validate(value, elements.First);
};
exports.isFirst = isFirst;
var isFirstFret = function (value) {
    return operations.validate(value, elements.FirstFret);
};
exports.isFirstFret = isFirstFret;
var isFlip = function (value) {
    return operations.validate(value, elements.Flip);
};
exports.isFlip = isFlip;
var isFootnote = function (value) {
    return operations.validate(value, elements.Footnote);
};
exports.isFootnote = isFootnote;
var isForPart = function (value) {
    return operations.validate(value, elements.ForPart);
};
exports.isForPart = isForPart;
var isForParts = function (value) {
    return operations.validate(value, elements.Attributes.schema.contents[10]['value']['choices'][1]);
};
exports.isForParts = isForParts;
var isForward = function (value) {
    return operations.validate(value, elements.Forward);
};
exports.isForward = isForward;
var isFp = function (value) {
    return operations.validate(value, elements.Fp);
};
exports.isFp = isFp;
var isFrame = function (value) {
    return operations.validate(value, elements.Frame);
};
exports.isFrame = isFrame;
var isFrameFrets = function (value) {
    return operations.validate(value, elements.FrameFrets);
};
exports.isFrameFrets = isFrameFrets;
var isFrameNote = function (value) {
    return operations.validate(value, elements.FrameNote);
};
exports.isFrameNote = isFrameNote;
var isFrameStrings = function (value) {
    return operations.validate(value, elements.FrameStrings);
};
exports.isFrameStrings = isFrameStrings;
var isFret = function (value) {
    return operations.validate(value, elements.Fret);
};
exports.isFret = isFret;
var isFunction = function (value) {
    return operations.validate(value, elements.Function);
};
exports.isFunction = isFunction;
var isFz = function (value) {
    return operations.validate(value, elements.Fz);
};
exports.isFz = isFz;
var isGlass = function (value) {
    return operations.validate(value, elements.Glass);
};
exports.isGlass = isGlass;
var isGlissando = function (value) {
    return operations.validate(value, elements.Glissando);
};
exports.isGlissando = isGlissando;
var isGlyph = function (value) {
    return operations.validate(value, elements.Glyph);
};
exports.isGlyph = isGlyph;
var isGolpe = function (value) {
    return operations.validate(value, elements.Golpe);
};
exports.isGolpe = isGolpe;
var isGrace = function (value) {
    return operations.validate(value, elements.Grace);
};
exports.isGrace = isGrace;
var isGroup = function (value) {
    return operations.validate(value, elements.Group);
};
exports.isGroup = isGroup;
var isGroupAbbreviation = function (value) {
    return operations.validate(value, elements.GroupAbbreviation);
};
exports.isGroupAbbreviation = isGroupAbbreviation;
var isGroupAbbreviationDisplay = function (value) {
    return operations.validate(value, elements.GroupAbbreviationDisplay);
};
exports.isGroupAbbreviationDisplay = isGroupAbbreviationDisplay;
var isGroupBarline = function (value) {
    return operations.validate(value, elements.GroupBarline);
};
exports.isGroupBarline = isGroupBarline;
var isGroupLink = function (value) {
    return operations.validate(value, elements.GroupLink);
};
exports.isGroupLink = isGroupLink;
var isGroupName = function (value) {
    return operations.validate(value, elements.GroupName);
};
exports.isGroupName = isGroupName;
var isGroupNameDisplay = function (value) {
    return operations.validate(value, elements.GroupNameDisplay);
};
exports.isGroupNameDisplay = isGroupNameDisplay;
var isGroupSymbol = function (value) {
    return operations.validate(value, elements.GroupSymbol);
};
exports.isGroupSymbol = isGroupSymbol;
var isGroupTime = function (value) {
    return operations.validate(value, elements.GroupTime);
};
exports.isGroupTime = isGroupTime;
var isGrouping = function (value) {
    return operations.validate(value, elements.Grouping);
};
exports.isGrouping = isGrouping;
var isHalfMuted = function (value) {
    return operations.validate(value, elements.HalfMuted);
};
exports.isHalfMuted = isHalfMuted;
var isHammerOn = function (value) {
    return operations.validate(value, elements.HammerOn);
};
exports.isHammerOn = isHammerOn;
var isHandbell = function (value) {
    return operations.validate(value, elements.Handbell);
};
exports.isHandbell = isHandbell;
var isHarmonClosed = function (value) {
    return operations.validate(value, elements.HarmonClosed);
};
exports.isHarmonClosed = isHarmonClosed;
var isHarmonMute = function (value) {
    return operations.validate(value, elements.HarmonMute);
};
exports.isHarmonMute = isHarmonMute;
var isHarmonic = function (value) {
    return operations.validate(value, elements.Harmonic);
};
exports.isHarmonic = isHarmonic;
var isHarmony = function (value) {
    return operations.validate(value, elements.Harmony);
};
exports.isHarmony = isHarmony;
var isHarpPedals = function (value) {
    return operations.validate(value, elements.HarpPedals);
};
exports.isHarpPedals = isHarpPedals;
var isHaydn = function (value) {
    return operations.validate(value, elements.Haydn);
};
exports.isHaydn = isHaydn;
var isHeel = function (value) {
    return operations.validate(value, elements.Heel);
};
exports.isHeel = isHeel;
var isHole = function (value) {
    return operations.validate(value, elements.Hole);
};
exports.isHole = isHole;
var isHoleClosed = function (value) {
    return operations.validate(value, elements.HoleClosed);
};
exports.isHoleClosed = isHoleClosed;
var isHoleShape = function (value) {
    return operations.validate(value, elements.HoleShape);
};
exports.isHoleShape = isHoleShape;
var isHoleType = function (value) {
    return operations.validate(value, elements.HoleType);
};
exports.isHoleType = isHoleType;
var isHumming = function (value) {
    return operations.validate(value, elements.Humming);
};
exports.isHumming = isHumming;
var isIdentification = function (value) {
    return operations.validate(value, elements.Identification);
};
exports.isIdentification = isIdentification;
var isImage = function (value) {
    return operations.validate(value, elements.Image);
};
exports.isImage = isImage;
var isInstrument = function (value) {
    return operations.validate(value, elements.Instrument);
};
exports.isInstrument = isInstrument;
var isInstrumentAbbreviation = function (value) {
    return operations.validate(value, elements.InstrumentAbbreviation);
};
exports.isInstrumentAbbreviation = isInstrumentAbbreviation;
var isInstrumentChange = function (value) {
    return operations.validate(value, elements.InstrumentChange);
};
exports.isInstrumentChange = isInstrumentChange;
var isInstrumentLink = function (value) {
    return operations.validate(value, elements.InstrumentLink);
};
exports.isInstrumentLink = isInstrumentLink;
var isInstrumentName = function (value) {
    return operations.validate(value, elements.InstrumentName);
};
exports.isInstrumentName = isInstrumentName;
var isInstrumentSound = function (value) {
    return operations.validate(value, elements.InstrumentSound);
};
exports.isInstrumentSound = isInstrumentSound;
var isInstruments = function (value) {
    return operations.validate(value, elements.Instruments);
};
exports.isInstruments = isInstruments;
var isIntelligible = function (value) {
    return operations.validate(value, elements.Lyric.schema.contents[0]['value']['choices'][0]);
};
exports.isIntelligible = isIntelligible;
var isInterchangeable = function (value) {
    return operations.validate(value, elements.Interchangeable);
};
exports.isInterchangeable = isInterchangeable;
var isInversion = function (value) {
    return operations.validate(value, elements.Inversion);
};
exports.isInversion = isInversion;
var isInvertedMordent = function (value) {
    return operations.validate(value, elements.InvertedMordent);
};
exports.isInvertedMordent = isInvertedMordent;
var isInvertedTurn = function (value) {
    return operations.validate(value, elements.InvertedTurn);
};
exports.isInvertedTurn = isInvertedTurn;
var isInvertedVerticalTurn = function (value) {
    return operations.validate(value, elements.InvertedVerticalTurn);
};
exports.isInvertedVerticalTurn = isInvertedVerticalTurn;
var isIpa = function (value) {
    return operations.validate(value, elements.Ipa);
};
exports.isIpa = isIpa;
var isKey = function (value) {
    return operations.validate(value, elements.Key);
};
exports.isKey = isKey;
var isKeyAccidental = function (value) {
    return operations.validate(value, elements.KeyAccidental);
};
exports.isKeyAccidental = isKeyAccidental;
var isKeyAlter = function (value) {
    return operations.validate(value, elements.KeyAlter);
};
exports.isKeyAlter = isKeyAlter;
var isKeyOctave = function (value) {
    return operations.validate(value, elements.KeyOctave);
};
exports.isKeyOctave = isKeyOctave;
var isKeyStep = function (value) {
    return operations.validate(value, elements.KeyStep);
};
exports.isKeyStep = isKeyStep;
var isKind = function (value) {
    return operations.validate(value, elements.Kind);
};
exports.isKind = isKind;
var isLaughing = function (value) {
    return operations.validate(value, elements.Laughing);
};
exports.isLaughing = isLaughing;
var isLeftMargin = function (value) {
    return operations.validate(value, elements.LeftMargin);
};
exports.isLeftMargin = isLeftMargin;
var isLevel = function (value) {
    return operations.validate(value, elements.Level);
};
exports.isLevel = isLevel;
var isLine = function (value) {
    return operations.validate(value, elements.Line);
};
exports.isLine = isLine;
var isLineDetail = function (value) {
    return operations.validate(value, elements.LineDetail);
};
exports.isLineDetail = isLineDetail;
var isLineWidth = function (value) {
    return operations.validate(value, elements.LineWidth);
};
exports.isLineWidth = isLineWidth;
var isLink = function (value) {
    return operations.validate(value, elements.Link);
};
exports.isLink = isLink;
var isListen = function (value) {
    return operations.validate(value, elements.Listen);
};
exports.isListen = isListen;
var isListening = function (value) {
    return operations.validate(value, elements.Listening);
};
exports.isListening = isListening;
var isLyric = function (value) {
    return operations.validate(value, elements.Lyric);
};
exports.isLyric = isLyric;
var isLyricFont = function (value) {
    return operations.validate(value, elements.LyricFont);
};
exports.isLyricFont = isLyricFont;
var isLyricLanguage = function (value) {
    return operations.validate(value, elements.LyricLanguage);
};
exports.isLyricLanguage = isLyricLanguage;
var isMeasureDistance = function (value) {
    return operations.validate(value, elements.MeasureDistance);
};
exports.isMeasureDistance = isMeasureDistance;
var isMeasureLayout = function (value) {
    return operations.validate(value, elements.MeasureLayout);
};
exports.isMeasureLayout = isMeasureLayout;
var isMeasureNumbering = function (value) {
    return operations.validate(value, elements.MeasureNumbering);
};
exports.isMeasureNumbering = isMeasureNumbering;
var isMeasurePartwise = function (value) {
    return operations.validate(value, elements.MeasurePartwise);
};
exports.isMeasurePartwise = isMeasurePartwise;
var isMeasureRepeat = function (value) {
    return operations.validate(value, elements.MeasureRepeat);
};
exports.isMeasureRepeat = isMeasureRepeat;
var isMeasureStyle = function (value) {
    return operations.validate(value, elements.MeasureStyle);
};
exports.isMeasureStyle = isMeasureStyle;
var isMeasureTimewise = function (value) {
    return operations.validate(value, elements.MeasureTimewise);
};
exports.isMeasureTimewise = isMeasureTimewise;
var isMembrane = function (value) {
    return operations.validate(value, elements.Membrane);
};
exports.isMembrane = isMembrane;
var isMetal = function (value) {
    return operations.validate(value, elements.Metal);
};
exports.isMetal = isMetal;
var isMetronome = function (value) {
    return operations.validate(value, elements.Metronome);
};
exports.isMetronome = isMetronome;
var isMetronomeArrows = function (value) {
    return operations.validate(value, elements.MetronomeArrows);
};
exports.isMetronomeArrows = isMetronomeArrows;
var isMetronomeBeam = function (value) {
    return operations.validate(value, elements.MetronomeBeam);
};
exports.isMetronomeBeam = isMetronomeBeam;
var isMetronomeDot = function (value) {
    return operations.validate(value, elements.MetronomeDot);
};
exports.isMetronomeDot = isMetronomeDot;
var isMetronomeNote = function (value) {
    return operations.validate(value, elements.MetronomeNote);
};
exports.isMetronomeNote = isMetronomeNote;
var isMetronomeRelation = function (value) {
    return operations.validate(value, elements.MetronomeRelation);
};
exports.isMetronomeRelation = isMetronomeRelation;
var isMetronomeSpec = function (value) {
    return operations.validate(value, elements.Metronome.schema.contents[0]['value']['choices'][1]);
};
exports.isMetronomeSpec = isMetronomeSpec;
var isMetronomeTied = function (value) {
    return operations.validate(value, elements.MetronomeTied);
};
exports.isMetronomeTied = isMetronomeTied;
var isMetronomeTuplet = function (value) {
    return operations.validate(value, elements.MetronomeTuplet);
};
exports.isMetronomeTuplet = isMetronomeTuplet;
var isMetronomeType = function (value) {
    return operations.validate(value, elements.MetronomeType);
};
exports.isMetronomeType = isMetronomeType;
var isMf = function (value) {
    return operations.validate(value, elements.Mf);
};
exports.isMf = isMf;
var isMidiBank = function (value) {
    return operations.validate(value, elements.MidiBank);
};
exports.isMidiBank = isMidiBank;
var isMidiChannel = function (value) {
    return operations.validate(value, elements.MidiChannel);
};
exports.isMidiChannel = isMidiChannel;
var isMidiDevice = function (value) {
    return operations.validate(value, elements.MidiDevice);
};
exports.isMidiDevice = isMidiDevice;
var isMidiInstrument = function (value) {
    return operations.validate(value, elements.MidiInstrument);
};
exports.isMidiInstrument = isMidiInstrument;
var isMidiName = function (value) {
    return operations.validate(value, elements.MidiName);
};
exports.isMidiName = isMidiName;
var isMidiProgram = function (value) {
    return operations.validate(value, elements.MidiProgram);
};
exports.isMidiProgram = isMidiProgram;
var isMidiUnpitched = function (value) {
    return operations.validate(value, elements.MidiUnpitched);
};
exports.isMidiUnpitched = isMidiUnpitched;
var isMillimeters = function (value) {
    return operations.validate(value, elements.Millimeters);
};
exports.isMillimeters = isMillimeters;
var isMiscellaneous = function (value) {
    return operations.validate(value, elements.Miscellaneous);
};
exports.isMiscellaneous = isMiscellaneous;
var isMiscellaneousField = function (value) {
    return operations.validate(value, elements.MiscellaneousField);
};
exports.isMiscellaneousField = isMiscellaneousField;
var isMode = function (value) {
    return operations.validate(value, elements.Mode);
};
exports.isMode = isMode;
var isMordent = function (value) {
    return operations.validate(value, elements.Mordent);
};
exports.isMordent = isMordent;
var isMovementNumber = function (value) {
    return operations.validate(value, elements.MovementNumber);
};
exports.isMovementNumber = isMovementNumber;
var isMovementTitle = function (value) {
    return operations.validate(value, elements.MovementTitle);
};
exports.isMovementTitle = isMovementTitle;
var isMp = function (value) {
    return operations.validate(value, elements.Mp);
};
exports.isMp = isMp;
var isMultipleRest = function (value) {
    return operations.validate(value, elements.MultipleRest);
};
exports.isMultipleRest = isMultipleRest;
var isMusicFont = function (value) {
    return operations.validate(value, elements.MusicFont);
};
exports.isMusicFont = isMusicFont;
var isMute = function (value) {
    return operations.validate(value, elements.Mute);
};
exports.isMute = isMute;
var isN = function (value) {
    return operations.validate(value, elements.N);
};
exports.isN = isN;
var isNatural = function (value) {
    return operations.validate(value, elements.Natural);
};
exports.isNatural = isNatural;
var isNonArpeggiate = function (value) {
    return operations.validate(value, elements.NonArpeggiate);
};
exports.isNonArpeggiate = isNonArpeggiate;
var isNormalDot = function (value) {
    return operations.validate(value, elements.NormalDot);
};
exports.isNormalDot = isNormalDot;
var isNormalNotes = function (value) {
    return operations.validate(value, elements.NormalNotes);
};
exports.isNormalNotes = isNormalNotes;
var isNormalType = function (value) {
    return operations.validate(value, elements.NormalType);
};
exports.isNormalType = isNormalType;
var isNotations = function (value) {
    return operations.validate(value, elements.Notations);
};
exports.isNotations = isNotations;
var isNote = function (value) {
    return operations.validate(value, elements.Note);
};
exports.isNote = isNote;
var isNoteSize = function (value) {
    return operations.validate(value, elements.NoteSize);
};
exports.isNoteSize = isNoteSize;
var isNotehead = function (value) {
    return operations.validate(value, elements.Notehead);
};
exports.isNotehead = isNotehead;
var isNoteheadText = function (value) {
    return operations.validate(value, elements.NoteheadText);
};
exports.isNoteheadText = isNoteheadText;
var isNumeral = function (value) {
    return operations.validate(value, elements.Numeral);
};
exports.isNumeral = isNumeral;
var isNumeralAlter = function (value) {
    return operations.validate(value, elements.NumeralAlter);
};
exports.isNumeralAlter = isNumeralAlter;
var isNumeralFifths = function (value) {
    return operations.validate(value, elements.NumeralFifths);
};
exports.isNumeralFifths = isNumeralFifths;
var isNumeralKey = function (value) {
    return operations.validate(value, elements.NumeralKey);
};
exports.isNumeralKey = isNumeralKey;
var isNumeralMode = function (value) {
    return operations.validate(value, elements.NumeralMode);
};
exports.isNumeralMode = isNumeralMode;
var isNumeralRoot = function (value) {
    return operations.validate(value, elements.NumeralRoot);
};
exports.isNumeralRoot = isNumeralRoot;
var isOctave = function (value) {
    return operations.validate(value, elements.Octave);
};
exports.isOctave = isOctave;
var isOctaveChange = function (value) {
    return operations.validate(value, elements.OctaveChange);
};
exports.isOctaveChange = isOctaveChange;
var isOctaveShift = function (value) {
    return operations.validate(value, elements.OctaveShift);
};
exports.isOctaveShift = isOctaveShift;
var isOffset = function (value) {
    return operations.validate(value, elements.Offset);
};
exports.isOffset = isOffset;
var isOpen = function (value) {
    return operations.validate(value, elements.Open);
};
exports.isOpen = isOpen;
var isOpenString = function (value) {
    return operations.validate(value, elements.OpenString);
};
exports.isOpenString = isOpenString;
var isOpus = function (value) {
    return operations.validate(value, elements.Opus);
};
exports.isOpus = isOpus;
var isOrnaments = function (value) {
    return operations.validate(value, elements.Ornaments);
};
exports.isOrnaments = isOrnaments;
var isOtherAppearance = function (value) {
    return operations.validate(value, elements.OtherAppearance);
};
exports.isOtherAppearance = isOtherAppearance;
var isOtherArticulation = function (value) {
    return operations.validate(value, elements.OtherArticulation);
};
exports.isOtherArticulation = isOtherArticulation;
var isOtherDirection = function (value) {
    return operations.validate(value, elements.OtherDirection);
};
exports.isOtherDirection = isOtherDirection;
var isOtherDynamics = function (value) {
    return operations.validate(value, elements.OtherDynamics);
};
exports.isOtherDynamics = isOtherDynamics;
var isOtherListen = function (value) {
    return operations.validate(value, elements.OtherListen);
};
exports.isOtherListen = isOtherListen;
var isOtherListening = function (value) {
    return operations.validate(value, elements.OtherListening);
};
exports.isOtherListening = isOtherListening;
var isOtherNotation = function (value) {
    return operations.validate(value, elements.OtherNotation);
};
exports.isOtherNotation = isOtherNotation;
var isOtherOrnament = function (value) {
    return operations.validate(value, elements.OtherOrnament);
};
exports.isOtherOrnament = isOtherOrnament;
var isOtherPercussion = function (value) {
    return operations.validate(value, elements.OtherPercussion);
};
exports.isOtherPercussion = isOtherPercussion;
var isOtherPlay = function (value) {
    return operations.validate(value, elements.OtherPlay);
};
exports.isOtherPlay = isOtherPlay;
var isOtherTechnical = function (value) {
    return operations.validate(value, elements.OtherTechnical);
};
exports.isOtherTechnical = isOtherTechnical;
var isP = function (value) {
    return operations.validate(value, elements.P);
};
exports.isP = isP;
var isPageHeight = function (value) {
    return operations.validate(value, elements.PageHeight);
};
exports.isPageHeight = isPageHeight;
var isPageLayout = function (value) {
    return operations.validate(value, elements.PageLayout);
};
exports.isPageLayout = isPageLayout;
var isPageMargins = function (value) {
    return operations.validate(value, elements.PageMargins);
};
exports.isPageMargins = isPageMargins;
var isPageWidth = function (value) {
    return operations.validate(value, elements.PageWidth);
};
exports.isPageWidth = isPageWidth;
var isPan = function (value) {
    return operations.validate(value, elements.Pan);
};
exports.isPan = isPan;
var isPartAbbreviation = function (value) {
    return operations.validate(value, elements.PartAbbreviation);
};
exports.isPartAbbreviation = isPartAbbreviation;
var isPartAbbreviationDisplay = function (value) {
    return operations.validate(value, elements.PartAbbreviationDisplay);
};
exports.isPartAbbreviationDisplay = isPartAbbreviationDisplay;
var isPartClef = function (value) {
    return operations.validate(value, elements.PartClef);
};
exports.isPartClef = isPartClef;
var isPartGroup = function (value) {
    return operations.validate(value, elements.PartGroup);
};
exports.isPartGroup = isPartGroup;
var isPartLink = function (value) {
    return operations.validate(value, elements.PartLink);
};
exports.isPartLink = isPartLink;
var isPartList = function (value) {
    return operations.validate(value, elements.PartList);
};
exports.isPartList = isPartList;
var isPartName = function (value) {
    return operations.validate(value, elements.PartName);
};
exports.isPartName = isPartName;
var isPartNameDisplay = function (value) {
    return operations.validate(value, elements.PartNameDisplay);
};
exports.isPartNameDisplay = isPartNameDisplay;
var isPartPartwise = function (value) {
    return operations.validate(value, elements.PartPartwise);
};
exports.isPartPartwise = isPartPartwise;
var isPartSymbol = function (value) {
    return operations.validate(value, elements.PartSymbol);
};
exports.isPartSymbol = isPartSymbol;
var isPartTimewise = function (value) {
    return operations.validate(value, elements.PartTimewise);
};
exports.isPartTimewise = isPartTimewise;
var isPartTranspose = function (value) {
    return operations.validate(value, elements.PartTranspose);
};
exports.isPartTranspose = isPartTranspose;
var isPedal = function (value) {
    return operations.validate(value, elements.Pedal);
};
exports.isPedal = isPedal;
var isPedalAlter = function (value) {
    return operations.validate(value, elements.PedalAlter);
};
exports.isPedalAlter = isPedalAlter;
var isPedalStep = function (value) {
    return operations.validate(value, elements.PedalStep);
};
exports.isPedalStep = isPedalStep;
var isPedalTuning = function (value) {
    return operations.validate(value, elements.PedalTuning);
};
exports.isPedalTuning = isPedalTuning;
var isPerMinute = function (value) {
    return operations.validate(value, elements.PerMinute);
};
exports.isPerMinute = isPerMinute;
var isPercussion = function (value) {
    return operations.validate(value, elements.Percussion);
};
exports.isPercussion = isPercussion;
var isPercussions = function (value) {
    return operations.validate(value, elements.DirectionType.schema.contents[0]['value']['choices'][19]);
};
exports.isPercussions = isPercussions;
var isPf = function (value) {
    return operations.validate(value, elements.Pf);
};
exports.isPf = isPf;
var isPitch = function (value) {
    return operations.validate(value, elements.Pitch);
};
exports.isPitch = isPitch;
var isPitched = function (value) {
    return operations.validate(value, elements.Pitched);
};
exports.isPitched = isPitched;
var isPlay = function (value) {
    return operations.validate(value, elements.Play);
};
exports.isPlay = isPlay;
var isPlayer = function (value) {
    return operations.validate(value, elements.Player);
};
exports.isPlayer = isPlayer;
var isPlop = function (value) {
    return operations.validate(value, elements.Plop);
};
exports.isPlop = isPlop;
var isPluck = function (value) {
    return operations.validate(value, elements.Pluck);
};
exports.isPluck = isPluck;
var isPp = function (value) {
    return operations.validate(value, elements.Pp);
};
exports.isPp = isPp;
var isPpp = function (value) {
    return operations.validate(value, elements.Ppp);
};
exports.isPpp = isPpp;
var isPppp = function (value) {
    return operations.validate(value, elements.Pppp);
};
exports.isPppp = isPppp;
var isPpppp = function (value) {
    return operations.validate(value, elements.Ppppp);
};
exports.isPpppp = isPpppp;
var isPppppp = function (value) {
    return operations.validate(value, elements.Pppppp);
};
exports.isPppppp = isPppppp;
var isPreBend = function (value) {
    return operations.validate(value, elements.PreBend);
};
exports.isPreBend = isPreBend;
var isPrefix = function (value) {
    return operations.validate(value, elements.Prefix);
};
exports.isPrefix = isPrefix;
var isPrincipalVoice = function (value) {
    return operations.validate(value, elements.PrincipalVoice);
};
exports.isPrincipalVoice = isPrincipalVoice;
var isPrint = function (value) {
    return operations.validate(value, elements.Print);
};
exports.isPrint = isPrint;
var isPullOff = function (value) {
    return operations.validate(value, elements.PullOff);
};
exports.isPullOff = isPullOff;
var isRehearsal = function (value) {
    return operations.validate(value, elements.Rehearsal);
};
exports.isRehearsal = isRehearsal;
var isRehearsals = function (value) {
    return operations.validate(value, elements.DirectionType.schema.contents[0]['value']['choices'][0]);
};
exports.isRehearsals = isRehearsals;
var isRelation = function (value) {
    return operations.validate(value, elements.Relation);
};
exports.isRelation = isRelation;
var isRelease = function (value) {
    return operations.validate(value, elements.Release);
};
exports.isRelease = isRelease;
var isRepeat = function (value) {
    return operations.validate(value, elements.Repeat);
};
exports.isRepeat = isRepeat;
var isRest = function (value) {
    return operations.validate(value, elements.Rest);
};
exports.isRest = isRest;
var isRf = function (value) {
    return operations.validate(value, elements.Rf);
};
exports.isRf = isRf;
var isRfz = function (value) {
    return operations.validate(value, elements.Rfz);
};
exports.isRfz = isRfz;
var isRightMargin = function (value) {
    return operations.validate(value, elements.RightMargin);
};
exports.isRightMargin = isRightMargin;
var isRights = function (value) {
    return operations.validate(value, elements.Rights);
};
exports.isRights = isRights;
var isRoot = function (value) {
    return operations.validate(value, elements.Root);
};
exports.isRoot = isRoot;
var isRootAlter = function (value) {
    return operations.validate(value, elements.RootAlter);
};
exports.isRootAlter = isRootAlter;
var isRootStep = function (value) {
    return operations.validate(value, elements.RootStep);
};
exports.isRootStep = isRootStep;
var isScaling = function (value) {
    return operations.validate(value, elements.Scaling);
};
exports.isScaling = isScaling;
var isSchleifer = function (value) {
    return operations.validate(value, elements.Schleifer);
};
exports.isSchleifer = isSchleifer;
var isScoop = function (value) {
    return operations.validate(value, elements.Scoop);
};
exports.isScoop = isScoop;
var isScordatura = function (value) {
    return operations.validate(value, elements.Scordatura);
};
exports.isScordatura = isScordatura;
var isScoreInstrument = function (value) {
    return operations.validate(value, elements.ScoreInstrument);
};
exports.isScoreInstrument = isScoreInstrument;
var isScorePart = function (value) {
    return operations.validate(value, elements.ScorePart);
};
exports.isScorePart = isScorePart;
var isScorePartwise = function (value) {
    return operations.validate(value, elements.ScorePartwise);
};
exports.isScorePartwise = isScorePartwise;
var isScoreTimewise = function (value) {
    return operations.validate(value, elements.ScoreTimewise);
};
exports.isScoreTimewise = isScoreTimewise;
var isSecond = function (value) {
    return operations.validate(value, elements.Second);
};
exports.isSecond = isSecond;
var isSegno = function (value) {
    return operations.validate(value, elements.Segno);
};
exports.isSegno = isSegno;
var isSegnos = function (value) {
    return operations.validate(value, elements.DirectionType.schema.contents[0]['value']['choices'][1]);
};
exports.isSegnos = isSegnos;
var isSemiPitched = function (value) {
    return operations.validate(value, elements.SemiPitched);
};
exports.isSemiPitched = isSemiPitched;
var isSenzaMisura = function (value) {
    return operations.validate(value, elements.SenzaMisura);
};
exports.isSenzaMisura = isSenzaMisura;
var isSf = function (value) {
    return operations.validate(value, elements.Sf);
};
exports.isSf = isSf;
var isSffz = function (value) {
    return operations.validate(value, elements.Sffz);
};
exports.isSffz = isSffz;
var isSfp = function (value) {
    return operations.validate(value, elements.Sfp);
};
exports.isSfp = isSfp;
var isSfpp = function (value) {
    return operations.validate(value, elements.Sfpp);
};
exports.isSfpp = isSfpp;
var isSfz = function (value) {
    return operations.validate(value, elements.Sfz);
};
exports.isSfz = isSfz;
var isSfzp = function (value) {
    return operations.validate(value, elements.Sfzp);
};
exports.isSfzp = isSfzp;
var isShake = function (value) {
    return operations.validate(value, elements.Shake);
};
exports.isShake = isShake;
var isSign = function (value) {
    return operations.validate(value, elements.Sign);
};
exports.isSign = isSign;
var isSlash = function (value) {
    return operations.validate(value, elements.Slash);
};
exports.isSlash = isSlash;
var isSlashDot = function (value) {
    return operations.validate(value, elements.SlashDot);
};
exports.isSlashDot = isSlashDot;
var isSlashType = function (value) {
    return operations.validate(value, elements.SlashType);
};
exports.isSlashType = isSlashType;
var isSlide = function (value) {
    return operations.validate(value, elements.Slide);
};
exports.isSlide = isSlide;
var isSlur = function (value) {
    return operations.validate(value, elements.Slur);
};
exports.isSlur = isSlur;
var isSmear = function (value) {
    return operations.validate(value, elements.Smear);
};
exports.isSmear = isSmear;
var isSnapPizzicato = function (value) {
    return operations.validate(value, elements.SnapPizzicato);
};
exports.isSnapPizzicato = isSnapPizzicato;
var isSoftAccent = function (value) {
    return operations.validate(value, elements.SoftAccent);
};
exports.isSoftAccent = isSoftAccent;
var isSoftware = function (value) {
    return operations.validate(value, elements.Software);
};
exports.isSoftware = isSoftware;
var isSolo = function (value) {
    return operations.validate(value, elements.Solo);
};
exports.isSolo = isSolo;
var isSound = function (value) {
    return operations.validate(value, elements.Sound);
};
exports.isSound = isSound;
var isSoundingPitch = function (value) {
    return operations.validate(value, elements.SoundingPitch);
};
exports.isSoundingPitch = isSoundingPitch;
var isSource = function (value) {
    return operations.validate(value, elements.Source);
};
exports.isSource = isSource;
var isSpiccato = function (value) {
    return operations.validate(value, elements.Spiccato);
};
exports.isSpiccato = isSpiccato;
var isStaccatissimo = function (value) {
    return operations.validate(value, elements.Staccatissimo);
};
exports.isStaccatissimo = isStaccatissimo;
var isStaccato = function (value) {
    return operations.validate(value, elements.Staccato);
};
exports.isStaccato = isStaccato;
var isStaff = function (value) {
    return operations.validate(value, elements.Staff);
};
exports.isStaff = isStaff;
var isStaffDetails = function (value) {
    return operations.validate(value, elements.StaffDetails);
};
exports.isStaffDetails = isStaffDetails;
var isStaffDistance = function (value) {
    return operations.validate(value, elements.StaffDistance);
};
exports.isStaffDistance = isStaffDistance;
var isStaffDivide = function (value) {
    return operations.validate(value, elements.StaffDivide);
};
exports.isStaffDivide = isStaffDivide;
var isStaffLayout = function (value) {
    return operations.validate(value, elements.StaffLayout);
};
exports.isStaffLayout = isStaffLayout;
var isStaffLines = function (value) {
    return operations.validate(value, elements.StaffLines);
};
exports.isStaffLines = isStaffLines;
var isStaffSize = function (value) {
    return operations.validate(value, elements.StaffSize);
};
exports.isStaffSize = isStaffSize;
var isStaffTuning = function (value) {
    return operations.validate(value, elements.StaffTuning);
};
exports.isStaffTuning = isStaffTuning;
var isStaffType = function (value) {
    return operations.validate(value, elements.StaffType);
};
exports.isStaffType = isStaffType;
var isStaves = function (value) {
    return operations.validate(value, elements.Staves);
};
exports.isStaves = isStaves;
var isStem = function (value) {
    return operations.validate(value, elements.Stem);
};
exports.isStem = isStem;
var isStep = function (value) {
    return operations.validate(value, elements.Step);
};
exports.isStep = isStep;
var isStick = function (value) {
    return operations.validate(value, elements.Stick);
};
exports.isStick = isStick;
var isStickLocation = function (value) {
    return operations.validate(value, elements.StickLocation);
};
exports.isStickLocation = isStickLocation;
var isStickMaterial = function (value) {
    return operations.validate(value, elements.StickMaterial);
};
exports.isStickMaterial = isStickMaterial;
var isStickType = function (value) {
    return operations.validate(value, elements.StickType);
};
exports.isStickType = isStickType;
var isStopped = function (value) {
    return operations.validate(value, elements.Stopped);
};
exports.isStopped = isStopped;
var isStraight = function (value) {
    return operations.validate(value, elements.Straight);
};
exports.isStraight = isStraight;
var isStress = function (value) {
    return operations.validate(value, elements.Stress);
};
exports.isStress = isStress;
var isString = function (value) {
    return operations.validate(value, elements.String);
};
exports.isString = isString;
var isStringMute = function (value) {
    return operations.validate(value, elements.StringMute);
};
exports.isStringMute = isStringMute;
var isStrongAccent = function (value) {
    return operations.validate(value, elements.StrongAccent);
};
exports.isStrongAccent = isStrongAccent;
var isSuffix = function (value) {
    return operations.validate(value, elements.Suffix);
};
exports.isSuffix = isSuffix;
var isSupports = function (value) {
    return operations.validate(value, elements.Supports);
};
exports.isSupports = isSupports;
var isSwing = function (value) {
    return operations.validate(value, elements.Swing);
};
exports.isSwing = isSwing;
var isSwingStyle = function (value) {
    return operations.validate(value, elements.SwingStyle);
};
exports.isSwingStyle = isSwingStyle;
var isSwingType = function (value) {
    return operations.validate(value, elements.SwingType);
};
exports.isSwingType = isSwingType;
var isSyllabic = function (value) {
    return operations.validate(value, elements.Syllabic);
};
exports.isSyllabic = isSyllabic;
var isSymbol = function (value) {
    return operations.validate(value, elements.Symbol);
};
exports.isSymbol = isSymbol;
var isSync = function (value) {
    return operations.validate(value, elements.Sync);
};
exports.isSync = isSync;
var isSystemDistance = function (value) {
    return operations.validate(value, elements.SystemDistance);
};
exports.isSystemDistance = isSystemDistance;
var isSystemLayout = function (value) {
    return operations.validate(value, elements.SystemLayout);
};
exports.isSystemLayout = isSystemLayout;
var isSystemMargins = function (value) {
    return operations.validate(value, elements.SystemMargins);
};
exports.isSystemMargins = isSystemMargins;
var isTap = function (value) {
    return operations.validate(value, elements.Tap);
};
exports.isTap = isTap;
var isTechnical = function (value) {
    return operations.validate(value, elements.Technical);
};
exports.isTechnical = isTechnical;
var isTenths = function (value) {
    return operations.validate(value, elements.Tenths);
};
exports.isTenths = isTenths;
var isTenuto = function (value) {
    return operations.validate(value, elements.Tenuto);
};
exports.isTenuto = isTenuto;
var isText = function (value) {
    return operations.validate(value, elements.Text);
};
exports.isText = isText;
var isThumbPosition = function (value) {
    return operations.validate(value, elements.ThumbPosition);
};
exports.isThumbPosition = isThumbPosition;
var isTie = function (value) {
    return operations.validate(value, elements.Tie);
};
exports.isTie = isTie;
var isTied = function (value) {
    return operations.validate(value, elements.Tied);
};
exports.isTied = isTied;
var isTiedGraceNote = function (value) {
    return operations.validate(value, elements.Note.schema.contents[0]['value']['choices'][2]);
};
exports.isTiedGraceNote = isTiedGraceNote;
var isTiedNote = function (value) {
    return operations.validate(value, elements.Note.schema.contents[0]['value']['choices'][0]);
};
exports.isTiedNote = isTiedNote;
var isTime = function (value) {
    return operations.validate(value, elements.Time);
};
exports.isTime = isTime;
var isTimeModification = function (value) {
    return operations.validate(value, elements.TimeModification);
};
exports.isTimeModification = isTimeModification;
var isTimeRelation = function (value) {
    return operations.validate(value, elements.TimeRelation);
};
exports.isTimeRelation = isTimeRelation;
var isTimeSignature = function (value) {
    return operations.validate(value, elements.Time.schema.contents[0]['value']['choices'][0]);
};
exports.isTimeSignature = isTimeSignature;
var isTimpani = function (value) {
    return operations.validate(value, elements.Timpani);
};
exports.isTimpani = isTimpani;
var isToe = function (value) {
    return operations.validate(value, elements.Toe);
};
exports.isToe = isToe;
var isTokens = function (value) {
    return operations.validate(value, elements.DirectionType.schema.contents[0]['value']['choices'][3]);
};
exports.isTokens = isTokens;
var isTopMargin = function (value) {
    return operations.validate(value, elements.TopMargin);
};
exports.isTopMargin = isTopMargin;
var isTopSystemDistance = function (value) {
    return operations.validate(value, elements.TopSystemDistance);
};
exports.isTopSystemDistance = isTopSystemDistance;
var isTouchingPitch = function (value) {
    return operations.validate(value, elements.TouchingPitch);
};
exports.isTouchingPitch = isTouchingPitch;
var isTranditionalKey = function (value) {
    return operations.validate(value, elements.Key.schema.contents[0]['value']['choices'][0]);
};
exports.isTranditionalKey = isTranditionalKey;
var isTranspose = function (value) {
    return operations.validate(value, elements.Transpose);
};
exports.isTranspose = isTranspose;
var isTransposes = function (value) {
    return operations.validate(value, elements.Attributes.schema.contents[10]['value']['choices'][0]);
};
exports.isTransposes = isTransposes;
var isTremolo = function (value) {
    return operations.validate(value, elements.Tremolo);
};
exports.isTremolo = isTremolo;
var isTrillMark = function (value) {
    return operations.validate(value, elements.TrillMark);
};
exports.isTrillMark = isTrillMark;
var isTripleTongue = function (value) {
    return operations.validate(value, elements.TripleTongue);
};
exports.isTripleTongue = isTripleTongue;
var isTuningAlter = function (value) {
    return operations.validate(value, elements.TuningAlter);
};
exports.isTuningAlter = isTuningAlter;
var isTuningOctave = function (value) {
    return operations.validate(value, elements.TuningOctave);
};
exports.isTuningOctave = isTuningOctave;
var isTuningStep = function (value) {
    return operations.validate(value, elements.TuningStep);
};
exports.isTuningStep = isTuningStep;
var isTuplet = function (value) {
    return operations.validate(value, elements.Tuplet);
};
exports.isTuplet = isTuplet;
var isTupletActual = function (value) {
    return operations.validate(value, elements.TupletActual);
};
exports.isTupletActual = isTupletActual;
var isTupletDot = function (value) {
    return operations.validate(value, elements.TupletDot);
};
exports.isTupletDot = isTupletDot;
var isTupletNormal = function (value) {
    return operations.validate(value, elements.TupletNormal);
};
exports.isTupletNormal = isTupletNormal;
var isTupletNumber = function (value) {
    return operations.validate(value, elements.TupletNumber);
};
exports.isTupletNumber = isTupletNumber;
var isTupletType = function (value) {
    return operations.validate(value, elements.TupletType);
};
exports.isTupletType = isTupletType;
var isTurn = function (value) {
    return operations.validate(value, elements.Turn);
};
exports.isTurn = isTurn;
var isType = function (value) {
    return operations.validate(value, elements.Type);
};
exports.isType = isType;
var isUnpitched = function (value) {
    return operations.validate(value, elements.Unpitched);
};
exports.isUnpitched = isUnpitched;
var isUnstress = function (value) {
    return operations.validate(value, elements.Unstress);
};
exports.isUnstress = isUnstress;
var isUpBow = function (value) {
    return operations.validate(value, elements.UpBow);
};
exports.isUpBow = isUpBow;
var isVerticalTurn = function (value) {
    return operations.validate(value, elements.VerticalTurn);
};
exports.isVerticalTurn = isVerticalTurn;
var isVirtualInstrument = function (value) {
    return operations.validate(value, elements.VirtualInstrument);
};
exports.isVirtualInstrument = isVirtualInstrument;
var isVirtualLibrary = function (value) {
    return operations.validate(value, elements.VirtualLibrary);
};
exports.isVirtualLibrary = isVirtualLibrary;
var isVirtualName = function (value) {
    return operations.validate(value, elements.VirtualName);
};
exports.isVirtualName = isVirtualName;
var isVoice = function (value) {
    return operations.validate(value, elements.Voice);
};
exports.isVoice = isVoice;
var isVolume = function (value) {
    return operations.validate(value, elements.Volume);
};
exports.isVolume = isVolume;
var isWait = function (value) {
    return operations.validate(value, elements.Wait);
};
exports.isWait = isWait;
var isWavyLine = function (value) {
    return operations.validate(value, elements.WavyLine);
};
exports.isWavyLine = isWavyLine;
var isWedge = function (value) {
    return operations.validate(value, elements.Wedge);
};
exports.isWedge = isWedge;
var isWithBar = function (value) {
    return operations.validate(value, elements.WithBar);
};
exports.isWithBar = isWithBar;
var isWood = function (value) {
    return operations.validate(value, elements.Wood);
};
exports.isWood = isWood;
var isWordFont = function (value) {
    return operations.validate(value, elements.WordFont);
};
exports.isWordFont = isWordFont;
var isWords = function (value) {
    return operations.validate(value, elements.Words);
};
exports.isWords = isWords;
var isWork = function (value) {
    return operations.validate(value, elements.Work);
};
exports.isWork = isWork;
var isWorkNumber = function (value) {
    return operations.validate(value, elements.WorkNumber);
};
exports.isWorkNumber = isWorkNumber;
var isWorkTitle = function (value) {
    return operations.validate(value, elements.WorkTitle);
};
exports.isWorkTitle = isWorkTitle;

},{"../lib/operations":"node_modules/@stringsync/musicxml/dist/lib/operations/index.js","./elements":"node_modules/@stringsync/musicxml/dist/generated/elements.js"}],"node_modules/@stringsync/musicxml/dist/lib/resolutions/resolutions.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.none = exports.zero = exports.resolved = void 0;
var resolved = function (value) { return ({ type: 'resolved', value: value }); };
exports.resolved = resolved;
var zero = function (value) { return ({ type: 'zero', value: value }); };
exports.zero = zero;
var none = function () { return ({ type: 'none', value: undefined }); };
exports.none = none;

},{}],"node_modules/@stringsync/musicxml/dist/lib/resolutions/types.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],"node_modules/@stringsync/musicxml/dist/lib/resolutions/index.js":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./resolutions"), exports);
__exportStar(require("./types"), exports);

},{"./resolutions":"node_modules/@stringsync/musicxml/dist/lib/resolutions/resolutions.js","./types":"node_modules/@stringsync/musicxml/dist/lib/resolutions/types.js"}],"node_modules/@stringsync/musicxml/dist/lib/xml/parsePrimitive.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePrimitive = void 0;
var MusicXMLError_1 = require("../../MusicXMLError");
var operations = require("../operations");
var resolutions = require("../resolutions");
var util = require("../util");
var parsePrimitive = function (value, child) {
    var resolution = resolve(value, child);
    switch (resolution.type) {
        case 'resolved':
        case 'zero':
            return resolution.value;
        default:
            return operations.zero(child);
    }
};
exports.parsePrimitive = parsePrimitive;
var check = function (value, child) {
    return operations.validate(value, child) ? resolutions.resolved(value) : resolutions.none();
};
var resolve = function (value, child) {
    if (util.isString(child)) {
        return check(value, child);
    }
    if (util.isNumber(child)) {
        return check(value, child);
    }
    if (util.isDescriptor(child)) {
        switch (child.type) {
            case 'string':
                return check(value, child);
            case 'regex':
                return check(value, child);
            case 'int':
                return check(parseInt(value, 10), child);
            case 'float':
                return check(parseFloat(value), child);
            case 'constant':
                return check(value, child);
            case 'date':
                return check(new Date(value), child);
            case 'choices':
                for (var _i = 0, _a = child.choices; _i < _a.length; _i++) {
                    var choice = _a[_i];
                    var res = resolve(value, choice);
                    if (res.type === 'resolved') {
                        return res;
                    }
                }
                return { type: 'none', value: undefined };
            case 'optional':
            case 'required':
            case 'label':
                return check(resolve(value, child.value).value, child);
            case 'not':
                return check(resolve(value, child.include).value, child);
        }
    }
    throw new MusicXMLError_1.MusicXMLError('cannot decode string', { value: value, child: child });
};

},{"../../MusicXMLError":"node_modules/@stringsync/musicxml/dist/MusicXMLError.js","../operations":"node_modules/@stringsync/musicxml/dist/lib/operations/index.js","../resolutions":"node_modules/@stringsync/musicxml/dist/lib/resolutions/index.js","../util":"node_modules/@stringsync/musicxml/dist/lib/util/index.js"}],"node_modules/@stringsync/musicxml/dist/lib/xml/conform.js":[function(require,module,exports) {
"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.conform = void 0;
var MusicXMLError_1 = require("../../MusicXMLError");
var operations = require("../operations");
var resolutions = require("../resolutions");
var util = require("../util");
var parsePrimitive_1 = require("./parsePrimitive");
var conform = function (nodes, child) {
    return resolve(util.Cursor.from(nodes), child);
};
exports.conform = conform;
var resolve = function (cursor, child) {
    if (cursor.done()) {
        return resolutions.zero(operations.zero(child));
    }
    if (util.isString(child)) {
        return resolveConstant(cursor, child);
    }
    if (util.isNumber(child)) {
        return resolveConstant(cursor, child);
    }
    if (util.isDescriptor(child)) {
        switch (child.type) {
            case 'label':
                return resolve(cursor, child.value);
            case 'optional':
            case 'required':
                return resolveRequirement(cursor, child);
            case 'choices':
                return resolveChoices(cursor, child);
            case 'zeroOrMore':
            case 'oneOrMore':
                return resolveMulti(cursor, child);
            case 'constant':
                return resolveConstant(cursor, child.value);
            case 'string':
            case 'int':
            case 'float':
                return resolvePrimitive(cursor, child);
            case 'date':
                return resolveDate(cursor, child);
        }
    }
    if (util.isXMLElementCtor(child)) {
        return resolveElement(cursor, child);
    }
    if (util.isFunction(child)) {
        return resolve(cursor, child());
    }
    if (util.isArray(child)) {
        return resolveArray(cursor, child);
    }
    throw new MusicXMLError_1.MusicXMLError('cannot handle child', { child: child });
};
var resolveRequirement = function (cursor, descriptor) {
    var probeCursor = cursor.dup();
    var resolution = resolve(probeCursor, descriptor.value);
    switch (resolution.type) {
        case 'none':
            return resolutions.zero(operations.zero(descriptor));
        case 'zero':
            return resolution;
        case 'resolved':
            cursor.sync(probeCursor);
            return resolution;
    }
};
var resolvePrimitive = function (cursor, descriptor) {
    var element = cursor.get();
    if (element.type === 'text') {
        cursor.next();
        return resolutions.resolved((0, parsePrimitive_1.parsePrimitive)(element.text, descriptor));
    }
    else {
        return resolutions.zero(operations.zero(descriptor));
    }
};
var resolveConstant = function (cursor, child) {
    var element = cursor.get();
    if (element.type === 'text' && element.text === child.toString()) {
        cursor.next();
        return resolutions.resolved(child);
    }
    else {
        return resolutions.zero(child);
    }
};
var resolveChoices = function (cursor, descriptor) {
    var results = new Array();
    for (var _i = 0, _a = descriptor.choices; _i < _a.length; _i++) {
        var choice = _a[_i];
        var probeCursor = cursor.dup();
        var resolution = resolve(probeCursor, choice);
        results.push({ resolution: resolution, cursor: probeCursor });
    }
    var resolvedResults = results.filter(function (result) { return result.resolution.type === 'resolved'; });
    var maxResolvedIndex = Math.max.apply(Math, __spreadArray([cursor.getIndex()], resolvedResults.map(function (result) { return result.cursor.getIndex(); }), false));
    var cursorDidNotMove = cursor.getIndex() === maxResolvedIndex;
    if (cursorDidNotMove) {
        return resolutions.zero(operations.zero(descriptor));
    }
    for (var _b = 0, resolvedResults_1 = resolvedResults; _b < resolvedResults_1.length; _b++) {
        var result = resolvedResults_1[_b];
        if (maxResolvedIndex === result.cursor.getIndex()) {
            cursor.sync(result.cursor);
            return result.resolution;
        }
    }
    return resolutions.zero(operations.zero(descriptor));
};
var resolveMulti = function (cursor, descriptor) {
    var value = new Array();
    var shouldResolve = true;
    while (shouldResolve) {
        var probeCursor = cursor.dup();
        var resolution = resolve(probeCursor, descriptor.value);
        if (resolution.type === 'resolved') {
            cursor.sync(probeCursor);
            value.push(resolution.value);
        }
        else {
            shouldResolve = false;
        }
        if (cursor.done()) {
            shouldResolve = false;
        }
    }
    if (operations.validate(value, descriptor)) {
        return resolutions.resolved(value);
    }
    else {
        return resolutions.zero(operations.zero(descriptor));
    }
};
var resolveContent = function (cursor, descriptors) {
    var content = new Array();
    for (var _i = 0, descriptors_1 = descriptors; _i < descriptors_1.length; _i++) {
        var descriptor = descriptors_1[_i];
        var resolution = resolve(cursor, descriptor);
        switch (resolution.type) {
            case 'none':
                content.push(operations.zero(descriptor));
                break;
            case 'resolved':
            case 'zero':
                content.push(resolution.value);
        }
    }
    return content;
};
var resolveElement = function (cursor, ctor) {
    var node = cursor.get();
    if (node.type === 'element' && node.name === ctor.schema.name) {
        cursor.next();
        var attributes = {};
        for (var _i = 0, _a = Object.entries(node.attributes); _i < _a.length; _i++) {
            var _b = _a[_i], name_1 = _b[0], value = _b[1];
            if (name_1 in ctor.schema.attributes) {
                var descriptor = ctor.schema.attributes[name_1];
                attributes[name_1] = (0, parsePrimitive_1.parsePrimitive)(value, descriptor);
            }
        }
        var contents = resolveContent(util.Cursor.from(node.children), ctor.schema.contents);
        return resolutions.resolved(new ctor({ attributes: attributes, contents: contents }));
    }
    return resolutions.none();
};
var resolveArray = function (cursor, children) {
    var value = new Array();
    var probeCursor = cursor.dup();
    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
        var child = children_1[_i];
        var resolution = resolve(probeCursor, child);
        switch (resolution.type) {
            case 'none':
                return resolution;
            case 'zero':
            case 'resolved':
                value.push(resolution.value);
        }
    }
    if (cursor.getIndex() === probeCursor.getIndex()) {
        return resolutions.none();
    }
    cursor.sync(probeCursor);
    return resolutions.resolved(value);
};
var isValidDateString = function (str) {
    var timestamp = Date.parse(str);
    return !isNaN(timestamp);
};
var resolveDate = function (cursor, descriptor) {
    var node = cursor.get();
    if (node.type === 'text' && isValidDateString(node.text)) {
        return resolutions.resolved(new Date(node.text));
    }
    return resolutions.zero(operations.zero(descriptor));
};

},{"../../MusicXMLError":"node_modules/@stringsync/musicxml/dist/MusicXMLError.js","../operations":"node_modules/@stringsync/musicxml/dist/lib/operations/index.js","../resolutions":"node_modules/@stringsync/musicxml/dist/lib/resolutions/index.js","../util":"node_modules/@stringsync/musicxml/dist/lib/util/index.js","./parsePrimitive":"node_modules/@stringsync/musicxml/dist/lib/xml/parsePrimitive.js"}],"node_modules/@stringsync/musicxml/dist/lib/xml/getDefaultDeclaration.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultDeclaration = void 0;
var getDefaultDeclaration = function () { return ({
    attributes: { version: '1.0', encoding: 'UTF-8' },
}); };
exports.getDefaultDeclaration = getDefaultDeclaration;

},{}],"node_modules/events/events.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }
  var handler = events[type];
  if (handler === undefined) return false;
  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners = events[type];
  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events !== undefined) {
    var evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    }
    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
},{}],"node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],"node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};
},{}],"node_modules/process-nextick-args/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


},{"process":"node_modules/process/browser.js"}],"node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/readable-stream/lib/internal/streams/stream-browser.js":[function(require,module,exports) {
module.exports = require('events').EventEmitter;

},{"events":"node_modules/events/events.js"}],"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/isarray/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/readable-stream/node_modules/safe-buffer/index.js":[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"node_modules/buffer/index.js"}],"node_modules/core-util-is/lib/util.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('buffer').Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":"node_modules/buffer/index.js"}],"node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/readable-stream/lib/internal/streams/BufferList.js":[function(require,module,exports) {

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/readable-stream/lib/internal/streams/destroy.js":[function(require,module,exports) {
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        pna.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        pna.nextTick(emitErrorNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, _this, err);
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":"node_modules/process-nextick-args/index.js"}],"node_modules/util-deprecate/browser.js":[function(require,module,exports) {
var global = arguments[3];

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

},{}],"node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports) {
var process = require("process");

var global = arguments[3];
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/
var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !true && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');
util.inherits(Writable, Stream);
function nop() {}
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }
  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};
function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
};
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
},{"process-nextick-args":"node_modules/process-nextick-args/index.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js","util-deprecate":"node_modules/util-deprecate/browser.js","./internal/streams/stream":"node_modules/readable-stream/lib/internal/streams/stream-browser.js","safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js","./internal/streams/destroy":"node_modules/readable-stream/lib/internal/streams/destroy.js","./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"process-nextick-args":"node_modules/process-nextick-args/index.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_readable":"node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"node_modules/readable-stream/lib/_stream_writable.js"}],"node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js"}],"node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, { hasUnpiped: false });
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"process-nextick-args":"node_modules/process-nextick-args/index.js","isarray":"node_modules/isarray/index.js","events":"node_modules/events/events.js","./internal/streams/stream":"node_modules/readable-stream/lib/internal/streams/stream-browser.js","safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js","./internal/streams/BufferList":"node_modules/readable-stream/lib/internal/streams/BufferList.js","./internal/streams/destroy":"node_modules/readable-stream/lib/internal/streams/destroy.js","./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","string_decoder/":"node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js","process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/readable-stream/readable-browser.js":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_readable.js":"node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_writable.js":"node_modules/readable-stream/lib/_stream_writable.js","./lib/_stream_duplex.js":"node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_transform.js":"node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_passthrough.js":"node_modules/readable-stream/lib/_stream_passthrough.js"}],"node_modules/readable-stream/writable-browser.js":[function(require,module,exports) {
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":"node_modules/readable-stream/lib/_stream_writable.js"}],"node_modules/readable-stream/duplex-browser.js":[function(require,module,exports) {
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":"node_modules/readable-stream/lib/_stream_duplex.js"}],"node_modules/readable-stream/transform.js":[function(require,module,exports) {
module.exports = require('./readable').Transform

},{"./readable":"node_modules/readable-stream/readable-browser.js"}],"node_modules/readable-stream/passthrough.js":[function(require,module,exports) {
module.exports = require('./readable').PassThrough

},{"./readable":"node_modules/readable-stream/readable-browser.js"}],"node_modules/stream-browserify/index.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":"node_modules/events/events.js","inherits":"node_modules/inherits/inherits_browser.js","readable-stream/readable.js":"node_modules/readable-stream/readable-browser.js","readable-stream/writable.js":"node_modules/readable-stream/writable-browser.js","readable-stream/duplex.js":"node_modules/readable-stream/duplex-browser.js","readable-stream/transform.js":"node_modules/readable-stream/transform.js","readable-stream/passthrough.js":"node_modules/readable-stream/passthrough.js"}],"node_modules/safe-buffer/index.js":[function(require,module,exports) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"node_modules/buffer/index.js"}],"node_modules/string_decoder/lib/string_decoder.js":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"node_modules/safe-buffer/index.js"}],"node_modules/sax/lib/sax.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = require('stream').Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = require('string_decoder').StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})(typeof exports === 'undefined' ? this.sax = {} : exports)

},{"stream":"node_modules/stream-browserify/index.js","string_decoder":"node_modules/string_decoder/lib/string_decoder.js","buffer":"node_modules/buffer/index.js"}],"node_modules/xml-js/lib/array-helper.js":[function(require,module,exports) {
module.exports = {

  isArray: function(value) {
    if (Array.isArray) {
      return Array.isArray(value);
    }
    // fallback for older browsers like  IE 8
    return Object.prototype.toString.call( value ) === '[object Array]';
  }

};

},{}],"node_modules/xml-js/lib/options-helper.js":[function(require,module,exports) {
var isArray = require('./array-helper').isArray;

module.exports = {

  copyOptions: function (options) {
    var key, copy = {};
    for (key in options) {
      if (options.hasOwnProperty(key)) {
        copy[key] = options[key];
      }
    }
    return copy;
  },

  ensureFlagExists: function (item, options) {
    if (!(item in options) || typeof options[item] !== 'boolean') {
      options[item] = false;
    }
  },

  ensureSpacesExists: function (options) {
    if (!('spaces' in options) || (typeof options.spaces !== 'number' && typeof options.spaces !== 'string')) {
      options.spaces = 0;
    }
  },

  ensureAlwaysArrayExists: function (options) {
    if (!('alwaysArray' in options) || (typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray))) {
      options.alwaysArray = false;
    }
  },

  ensureKeyExists: function (key, options) {
    if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {
      options[key + 'Key'] = options.compact ? '_' + key : key;
    }
  },

  checkFnExists: function (key, options) {
    return key + 'Fn' in options;
  }

};

},{"./array-helper":"node_modules/xml-js/lib/array-helper.js"}],"node_modules/xml-js/lib/xml2js.js":[function(require,module,exports) {
var sax = require('sax');
var expat /*= require('node-expat');*/ = { on: function () { }, parse: function () { } };
var helper = require('./options-helper');
var isArray = require('./array-helper').isArray;

var options;
var pureJsParser = true;
var currentElement;

function validateOptions(userOptions) {
  options = helper.copyOptions(userOptions);
  helper.ensureFlagExists('ignoreDeclaration', options);
  helper.ensureFlagExists('ignoreInstruction', options);
  helper.ensureFlagExists('ignoreAttributes', options);
  helper.ensureFlagExists('ignoreText', options);
  helper.ensureFlagExists('ignoreComment', options);
  helper.ensureFlagExists('ignoreCdata', options);
  helper.ensureFlagExists('ignoreDoctype', options);
  helper.ensureFlagExists('compact', options);
  helper.ensureFlagExists('alwaysChildren', options);
  helper.ensureFlagExists('addParent', options);
  helper.ensureFlagExists('trim', options);
  helper.ensureFlagExists('nativeType', options);
  helper.ensureFlagExists('nativeTypeAttributes', options);
  helper.ensureFlagExists('sanitize', options);
  helper.ensureFlagExists('instructionHasAttributes', options);
  helper.ensureFlagExists('captureSpacesBetweenElements', options);
  helper.ensureAlwaysArrayExists(options);
  helper.ensureKeyExists('declaration', options);
  helper.ensureKeyExists('instruction', options);
  helper.ensureKeyExists('attributes', options);
  helper.ensureKeyExists('text', options);
  helper.ensureKeyExists('comment', options);
  helper.ensureKeyExists('cdata', options);
  helper.ensureKeyExists('doctype', options);
  helper.ensureKeyExists('type', options);
  helper.ensureKeyExists('name', options);
  helper.ensureKeyExists('elements', options);
  helper.ensureKeyExists('parent', options);
  helper.checkFnExists('doctype', options);
  helper.checkFnExists('instruction', options);
  helper.checkFnExists('cdata', options);
  helper.checkFnExists('comment', options);
  helper.checkFnExists('text', options);
  helper.checkFnExists('instructionName', options);
  helper.checkFnExists('elementName', options);
  helper.checkFnExists('attributeName', options);
  helper.checkFnExists('attributeValue', options);
  helper.checkFnExists('attributes', options);
  return options;
}

function nativeType(value) {
  var nValue = Number(value);
  if (!isNaN(nValue)) {
    return nValue;
  }
  var bValue = value.toLowerCase();
  if (bValue === 'true') {
    return true;
  } else if (bValue === 'false') {
    return false;
  }
  return value;
}

function addField(type, value) {
  var key;
  if (options.compact) {
    if (
      !currentElement[options[type + 'Key']] &&
      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)
    ) {
      currentElement[options[type + 'Key']] = [];
    }
    if (currentElement[options[type + 'Key']] && !isArray(currentElement[options[type + 'Key']])) {
      currentElement[options[type + 'Key']] = [currentElement[options[type + 'Key']]];
    }
    if (type + 'Fn' in options && typeof value === 'string') {
      value = options[type + 'Fn'](value, currentElement);
    }
    if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          if ('instructionFn' in options) {
            value[key] = options.instructionFn(value[key], key, currentElement);
          } else {
            var temp = value[key];
            delete value[key];
            value[options.instructionNameFn(key, temp, currentElement)] = temp;
          }
        }
      }
    }
    if (isArray(currentElement[options[type + 'Key']])) {
      currentElement[options[type + 'Key']].push(value);
    } else {
      currentElement[options[type + 'Key']] = value;
    }
  } else {
    if (!currentElement[options.elementsKey]) {
      currentElement[options.elementsKey] = [];
    }
    var element = {};
    element[options.typeKey] = type;
    if (type === 'instruction') {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          break;
        }
      }
      element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;
      if (options.instructionHasAttributes) {
        element[options.attributesKey] = value[key][options.attributesKey];
        if ('instructionFn' in options) {
          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
        }
      } else {
        if ('instructionFn' in options) {
          value[key] = options.instructionFn(value[key], key, currentElement);
        }
        element[options.instructionKey] = value[key];
      }
    } else {
      if (type + 'Fn' in options) {
        value = options[type + 'Fn'](value, currentElement);
      }
      element[options[type + 'Key']] = value;
    }
    if (options.addParent) {
      element[options.parentKey] = currentElement;
    }
    currentElement[options.elementsKey].push(element);
  }
}

function manipulateAttributes(attributes) {
  if ('attributesFn' in options && attributes) {
    attributes = options.attributesFn(attributes, currentElement);
  }
  if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {
    var key;
    for (key in attributes) {
      if (attributes.hasOwnProperty(key)) {
        if (options.trim) attributes[key] = attributes[key].trim();
        if (options.nativeTypeAttributes) {
          attributes[key] = nativeType(attributes[key]);
        }
        if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
        if ('attributeNameFn' in options) {
          var temp = attributes[key];
          delete attributes[key];
          attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
        }
      }
    }
  }
  return attributes;
}

function onInstruction(instruction) {
  var attributes = {};
  if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {
    var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
    var match;
    while ((match = attrsRegExp.exec(instruction.body)) !== null) {
      attributes[match[1]] = match[2] || match[3] || match[4];
    }
    attributes = manipulateAttributes(attributes);
  }
  if (instruction.name.toLowerCase() === 'xml') {
    if (options.ignoreDeclaration) {
      return;
    }
    currentElement[options.declarationKey] = {};
    if (Object.keys(attributes).length) {
      currentElement[options.declarationKey][options.attributesKey] = attributes;
    }
    if (options.addParent) {
      currentElement[options.declarationKey][options.parentKey] = currentElement;
    }
  } else {
    if (options.ignoreInstruction) {
      return;
    }
    if (options.trim) {
      instruction.body = instruction.body.trim();
    }
    var value = {};
    if (options.instructionHasAttributes && Object.keys(attributes).length) {
      value[instruction.name] = {};
      value[instruction.name][options.attributesKey] = attributes;
    } else {
      value[instruction.name] = instruction.body;
    }
    addField('instruction', value);
  }
}

function onStartElement(name, attributes) {
  var element;
  if (typeof name === 'object') {
    attributes = name.attributes;
    name = name.name;
  }
  attributes = manipulateAttributes(attributes);
  if ('elementNameFn' in options) {
    name = options.elementNameFn(name, currentElement);
  }
  if (options.compact) {
    element = {};
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = {};
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          element[options.attributesKey][key] = attributes[key];
        }
      }
    }
    if (
      !(name in currentElement) &&
      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)
    ) {
      currentElement[name] = [];
    }
    if (currentElement[name] && !isArray(currentElement[name])) {
      currentElement[name] = [currentElement[name]];
    }
    if (isArray(currentElement[name])) {
      currentElement[name].push(element);
    } else {
      currentElement[name] = element;
    }
  } else {
    if (!currentElement[options.elementsKey]) {
      currentElement[options.elementsKey] = [];
    }
    element = {};
    element[options.typeKey] = 'element';
    element[options.nameKey] = name;
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = attributes;
    }
    if (options.alwaysChildren) {
      element[options.elementsKey] = [];
    }
    currentElement[options.elementsKey].push(element);
  }
  element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent
  currentElement = element;
}

function onText(text) {
  if (options.ignoreText) {
    return;
  }
  if (!text.trim() && !options.captureSpacesBetweenElements) {
    return;
  }
  if (options.trim) {
    text = text.trim();
  }
  if (options.nativeType) {
    text = nativeType(text);
  }
  if (options.sanitize) {
    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }
  addField('text', text);
}

function onComment(comment) {
  if (options.ignoreComment) {
    return;
  }
  if (options.trim) {
    comment = comment.trim();
  }
  addField('comment', comment);
}

function onEndElement(name) {
  var parentElement = currentElement[options.parentKey];
  if (!options.addParent) {
    delete currentElement[options.parentKey];
  }
  currentElement = parentElement;
}

function onCdata(cdata) {
  if (options.ignoreCdata) {
    return;
  }
  if (options.trim) {
    cdata = cdata.trim();
  }
  addField('cdata', cdata);
}

function onDoctype(doctype) {
  if (options.ignoreDoctype) {
    return;
  }
  doctype = doctype.replace(/^ /, '');
  if (options.trim) {
    doctype = doctype.trim();
  }
  addField('doctype', doctype);
}

function onError(error) {
  error.note = error; //console.error(error);
}

module.exports = function (xml, userOptions) {

  var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser('UTF-8');
  var result = {};
  currentElement = result;

  options = validateOptions(userOptions);

  if (pureJsParser) {
    parser.opt = {strictEntities: true};
    parser.onopentag = onStartElement;
    parser.ontext = onText;
    parser.oncomment = onComment;
    parser.onclosetag = onEndElement;
    parser.onerror = onError;
    parser.oncdata = onCdata;
    parser.ondoctype = onDoctype;
    parser.onprocessinginstruction = onInstruction;
  } else {
    parser.on('startElement', onStartElement);
    parser.on('text', onText);
    parser.on('comment', onComment);
    parser.on('endElement', onEndElement);
    parser.on('error', onError);
    //parser.on('startCdata', onStartCdata);
    //parser.on('endCdata', onEndCdata);
    //parser.on('entityDecl', onEntityDecl);
  }

  if (pureJsParser) {
    parser.write(xml).close();
  } else {
    if (!parser.parse(xml)) {
      throw new Error('XML parsing error: ' + parser.getError());
    }
  }

  if (result[options.elementsKey]) {
    var temp = result[options.elementsKey];
    delete result[options.elementsKey];
    result[options.elementsKey] = temp;
    delete result.text;
  }

  return result;

};

},{"sax":"node_modules/sax/lib/sax.js","./options-helper":"node_modules/xml-js/lib/options-helper.js","./array-helper":"node_modules/xml-js/lib/array-helper.js"}],"node_modules/xml-js/lib/xml2json.js":[function(require,module,exports) {
var helper = require('./options-helper');
var xml2js = require('./xml2js');

function validateOptions (userOptions) {
  var options = helper.copyOptions(userOptions);
  helper.ensureSpacesExists(options);
  return options;
}

module.exports = function(xml, userOptions) {
  var options, js, json, parentKey;
  options = validateOptions(userOptions);
  js = xml2js(xml, options);
  parentKey = 'compact' in options && options.compact ? '_parent' : 'parent';
  // parentKey = ptions.compact ? '_parent' : 'parent'; // consider this
  if ('addParent' in options && options.addParent) {
    json = JSON.stringify(js, function (k, v) { return k === parentKey? '_' : v; }, options.spaces);
  } else {
    json = JSON.stringify(js, null, options.spaces);
  }
  return json.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
};

},{"./options-helper":"node_modules/xml-js/lib/options-helper.js","./xml2js":"node_modules/xml-js/lib/xml2js.js"}],"node_modules/xml-js/lib/js2xml.js":[function(require,module,exports) {
var helper = require('./options-helper');
var isArray = require('./array-helper').isArray;

var currentElement, currentElementName;

function validateOptions(userOptions) {
  var options = helper.copyOptions(userOptions);
  helper.ensureFlagExists('ignoreDeclaration', options);
  helper.ensureFlagExists('ignoreInstruction', options);
  helper.ensureFlagExists('ignoreAttributes', options);
  helper.ensureFlagExists('ignoreText', options);
  helper.ensureFlagExists('ignoreComment', options);
  helper.ensureFlagExists('ignoreCdata', options);
  helper.ensureFlagExists('ignoreDoctype', options);
  helper.ensureFlagExists('compact', options);
  helper.ensureFlagExists('indentText', options);
  helper.ensureFlagExists('indentCdata', options);
  helper.ensureFlagExists('indentAttributes', options);
  helper.ensureFlagExists('indentInstruction', options);
  helper.ensureFlagExists('fullTagEmptyElement', options);
  helper.ensureFlagExists('noQuotesForNativeAttributes', options);
  helper.ensureSpacesExists(options);
  if (typeof options.spaces === 'number') {
    options.spaces = Array(options.spaces + 1).join(' ');
  }
  helper.ensureKeyExists('declaration', options);
  helper.ensureKeyExists('instruction', options);
  helper.ensureKeyExists('attributes', options);
  helper.ensureKeyExists('text', options);
  helper.ensureKeyExists('comment', options);
  helper.ensureKeyExists('cdata', options);
  helper.ensureKeyExists('doctype', options);
  helper.ensureKeyExists('type', options);
  helper.ensureKeyExists('name', options);
  helper.ensureKeyExists('elements', options);
  helper.checkFnExists('doctype', options);
  helper.checkFnExists('instruction', options);
  helper.checkFnExists('cdata', options);
  helper.checkFnExists('comment', options);
  helper.checkFnExists('text', options);
  helper.checkFnExists('instructionName', options);
  helper.checkFnExists('elementName', options);
  helper.checkFnExists('attributeName', options);
  helper.checkFnExists('attributeValue', options);
  helper.checkFnExists('attributes', options);
  helper.checkFnExists('fullTagEmptyElement', options);
  return options;
}

function writeIndentation(options, depth, firstLine) {
  return (!firstLine && options.spaces ? '\n' : '') + Array(depth + 1).join(options.spaces);
}

function writeAttributes(attributes, options, depth) {
  if (options.ignoreAttributes) {
    return '';
  }
  if ('attributesFn' in options) {
    attributes = options.attributesFn(attributes, currentElementName, currentElement);
  }
  var key, attr, attrName, quote, result = [];
  for (key in attributes) {
    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {
      quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '"';
      attr = '' + attributes[key]; // ensure number and boolean are converted to String
      attr = attr.replace(/"/g, '&quot;');
      attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
      result.push((options.spaces && options.indentAttributes? writeIndentation(options, depth+1, false) : ' '));
      result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
    }
  }
  if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
    result.push(writeIndentation(options, depth, false));
  }
  return result.join('');
}

function writeDeclaration(declaration, options, depth) {
  currentElement = declaration;
  currentElementName = 'xml';
  return options.ignoreDeclaration ? '' :  '<?' + 'xml' + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';
}

function writeInstruction(instruction, options, depth) {
  if (options.ignoreInstruction) {
    return '';
  }
  var key;
  for (key in instruction) {
    if (instruction.hasOwnProperty(key)) {
      break;
    }
  }
  var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
  if (typeof instruction[key] === 'object') {
    currentElement = instruction;
    currentElementName = instructionName;
    return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';
  } else {
    var instructionValue = instruction[key] ? instruction[key] : '';
    if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
    return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';
  }
}

function writeComment(comment, options) {
  return options.ignoreComment ? '' : '<!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + '-->';
}

function writeCdata(cdata, options) {
  return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';
}

function writeDoctype(doctype, options) {
  return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + '>';
}

function writeText(text, options) {
  if (options.ignoreText) return '';
  text = '' + text; // ensure Number and Boolean are converted to String
  text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization
  text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  return 'textFn' in options ? options.textFn(text, currentElementName, currentElement) : text;
}

function hasContent(element, options) {
  var i;
  if (element.elements && element.elements.length) {
    for (i = 0; i < element.elements.length; ++i) {
      switch (element.elements[i][options.typeKey]) {
      case 'text':
        if (options.indentText) {
          return true;
        }
        break; // skip to next key
      case 'cdata':
        if (options.indentCdata) {
          return true;
        }
        break; // skip to next key
      case 'instruction':
        if (options.indentInstruction) {
          return true;
        }
        break; // skip to next key
      case 'doctype':
      case 'comment':
      case 'element':
        return true;
      default:
        return true;
      }
    }
  }
  return false;
}

function writeElement(element, options, depth) {
  currentElement = element;
  currentElementName = element.name;
  var xml = [], elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;
  xml.push('<' + elementName);
  if (element[options.attributesKey]) {
    xml.push(writeAttributes(element[options.attributesKey], options, depth));
  }
  var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
  if (!withClosingTag) {
    if ('fullTagEmptyElementFn' in options) {
      withClosingTag = options.fullTagEmptyElementFn(element.name, element);
    } else {
      withClosingTag = options.fullTagEmptyElement;
    }
  }
  if (withClosingTag) {
    xml.push('>');
    if (element[options.elementsKey] && element[options.elementsKey].length) {
      xml.push(writeElements(element[options.elementsKey], options, depth + 1));
      currentElement = element;
      currentElementName = element.name;
    }
    xml.push(options.spaces && hasContent(element, options) ? '\n' + Array(depth + 1).join(options.spaces) : '');
    xml.push('</' + elementName + '>');
  } else {
    xml.push('/>');
  }
  return xml.join('');
}

function writeElements(elements, options, depth, firstLine) {
  return elements.reduce(function (xml, element) {
    var indent = writeIndentation(options, depth, firstLine && !xml);
    switch (element.type) {
    case 'element': return xml + indent + writeElement(element, options, depth);
    case 'comment': return xml + indent + writeComment(element[options.commentKey], options);
    case 'doctype': return xml + indent + writeDoctype(element[options.doctypeKey], options);
    case 'cdata': return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);
    case 'text': return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);
    case 'instruction':
      var instruction = {};
      instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
      return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);
    }
  }, '');
}

function hasContentCompact(element, options, anyContent) {
  var key;
  for (key in element) {
    if (element.hasOwnProperty(key)) {
      switch (key) {
      case options.parentKey:
      case options.attributesKey:
        break; // skip to next key
      case options.textKey:
        if (options.indentText || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.cdataKey:
        if (options.indentCdata || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.instructionKey:
        if (options.indentInstruction || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.doctypeKey:
      case options.commentKey:
        return true;
      default:
        return true;
      }
    }
  }
  return false;
}

function writeElementCompact(element, name, options, depth, indent) {
  currentElement = element;
  currentElementName = name;
  var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;
  if (typeof element === 'undefined' || element === null || element === '') {
    return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';
  }
  var xml = [];
  if (name) {
    xml.push('<' + elementName);
    if (typeof element !== 'object') {
      xml.push('>' + writeText(element,options) + '</' + elementName + '>');
      return xml.join('');
    }
    if (element[options.attributesKey]) {
      xml.push(writeAttributes(element[options.attributesKey], options, depth));
    }
    var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
    if (!withClosingTag) {
      if ('fullTagEmptyElementFn' in options) {
        withClosingTag = options.fullTagEmptyElementFn(name, element);
      } else {
        withClosingTag = options.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml.push('>');
    } else {
      xml.push('/>');
      return xml.join('');
    }
  }
  xml.push(writeElementsCompact(element, options, depth + 1, false));
  currentElement = element;
  currentElementName = name;
  if (name) {
    xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');
  }
  return xml.join('');
}

function writeElementsCompact(element, options, depth, firstLine) {
  var i, key, nodes, xml = [];
  for (key in element) {
    if (element.hasOwnProperty(key)) {
      nodes = isArray(element[key]) ? element[key] : [element[key]];
      for (i = 0; i < nodes.length; ++i) {
        switch (key) {
        case options.declarationKey: xml.push(writeDeclaration(nodes[i], options, depth)); break;
        case options.instructionKey: xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth)); break;
        case options.attributesKey: case options.parentKey: break; // skip
        case options.textKey: xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options)); break;
        case options.cdataKey: xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options)); break;
        case options.doctypeKey: xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options)); break;
        case options.commentKey: xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options)); break;
        default: xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
        }
        firstLine = firstLine && !xml.length;
      }
    }
  }
  return xml.join('');
}

module.exports = function (js, options) {
  options = validateOptions(options);
  var xml = [];
  currentElement = js;
  currentElementName = '_root_';
  if (options.compact) {
    xml.push(writeElementsCompact(js, options, 0, true));
  } else {
    if (js[options.declarationKey]) {
      xml.push(writeDeclaration(js[options.declarationKey], options, 0));
    }
    if (js[options.elementsKey] && js[options.elementsKey].length) {
      xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
    }
  }
  return xml.join('');
};

},{"./options-helper":"node_modules/xml-js/lib/options-helper.js","./array-helper":"node_modules/xml-js/lib/array-helper.js"}],"node_modules/xml-js/lib/json2xml.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var js2xml = require('./js2xml.js');

module.exports = function (json, options) {
  if (json instanceof Buffer) {
    json = json.toString();
  }
  var js = null;
  if (typeof (json) === 'string') {
    try {
      js = JSON.parse(json);
    } catch (e) {
      throw new Error('The JSON structure is invalid');
    }
  } else {
    js = json;
  }
  return js2xml(js, options);
};

},{"./js2xml.js":"node_modules/xml-js/lib/js2xml.js","buffer":"node_modules/buffer/index.js"}],"node_modules/xml-js/lib/index.js":[function(require,module,exports) {
/*jslint node:true */

var xml2js = require('./xml2js');
var xml2json = require('./xml2json');
var js2xml = require('./js2xml');
var json2xml = require('./json2xml');

module.exports = {
  xml2js: xml2js,
  xml2json: xml2json,
  js2xml: js2xml,
  json2xml: json2xml
};

},{"./xml2js":"node_modules/xml-js/lib/xml2js.js","./xml2json":"node_modules/xml-js/lib/xml2json.js","./js2xml":"node_modules/xml-js/lib/js2xml.js","./json2xml":"node_modules/xml-js/lib/json2xml.js"}],"node_modules/@stringsync/musicxml/dist/lib/xml/parse.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
var xmlJs = require("xml-js");
var MusicXMLError_1 = require("../../MusicXMLError");
var IGNORE_ELEMENT_TYPES = ['comment', 'instruction'];
var parse = function (xml) {
    var xmlJsElements = xmlJs.xml2js(xml);
    return {
        declaration: xmlJsElements.declaration,
        nodes: toRawXMLNodes(xmlJsElements.elements || []),
    };
};
exports.parse = parse;
var toPlainAttributes = function (attributes) {
    // The keys are sorted so that it deterministically gets serialzed by xmlJs.js2xml.
    // See https://github.com/nashwaan/xml-js/blob/f0376f265c4f299100fb4766828ebf066a0edeec/lib/js2xml.js#L62
    // and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in:
    // >A for...in loop iterates over the properties of an object in an arbitrary order
    return Object.keys(attributes)
        .sort()
        .reduce(function (plainAttributes, key) {
        plainAttributes[key] = attributes[key].toString();
        return plainAttributes;
    }, {});
};
var toRawXMLNodes = function (elements) {
    return elements.filter(function (element) { return !IGNORE_ELEMENT_TYPES.includes(element.type || ''); }).map(toRawXMLNode);
};
var toRawXMLNode = function (node) {
    var _a, _b, _c;
    switch (node.type) {
        case 'element':
            return {
                type: 'element',
                name: node.name || 'unknown',
                attributes: node.attributes ? toPlainAttributes(node.attributes) : {},
                children: toRawXMLNodes(node.elements || []),
            };
        case 'text':
            return {
                type: 'text',
                text: ((_a = node.text) === null || _a === void 0 ? void 0 : _a.toString()) || '',
            };
        case 'doctype':
            return {
                type: 'doctype',
                doctype: ((_b = node.doctype) === null || _b === void 0 ? void 0 : _b.toString()) || '',
            };
        case 'cdata':
            // We don't need to preserve cdata, see https://stackoverflow.com/a/61626192.
            return {
                type: 'text',
                text: ((_c = node.cdata) === null || _c === void 0 ? void 0 : _c.toString()) || '',
            };
        default:
            throw new MusicXMLError_1.MusicXMLError('cannot parse element', { element: node });
    }
};

},{"xml-js":"node_modules/xml-js/lib/index.js","../../MusicXMLError":"node_modules/@stringsync/musicxml/dist/MusicXMLError.js"}],"node_modules/@stringsync/musicxml/dist/lib/xml/serializePrimitive.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializePrimitive = void 0;
var MusicXMLError_1 = require("../../MusicXMLError");
var operations = require("../operations");
var resolutions = require("../resolutions");
var util = require("../util");
var serializePrimitive = function (value, child) {
    value = operations.validate(value, child) ? value : operations.zero(child);
    if (util.isString(child)) {
        return resolutions.resolved(value);
    }
    if (util.isNumber(child)) {
        return resolutions.resolved(value.toString());
    }
    if (util.isDescriptor(child)) {
        switch (child.type) {
            case 'string':
                return resolutions.resolved(value);
            case 'regex':
                return resolutions.resolved(value);
            case 'int':
                return resolutions.resolved(Math.round(value).toString());
            case 'float':
                return resolutions.resolved(value.toString());
            case 'constant':
                return resolutions.resolved(String(value));
            case 'date':
                var yyyy = value.getFullYear().toString();
                var mm = (value.getMonth() + 1).toString().padStart(2, '0');
                var dd = value.getDate().toString().padStart(2, '0');
                return resolutions.resolved("".concat(yyyy, "-").concat(mm, "-").concat(dd));
            case 'choices':
                return resolutions.resolved(String(value));
            case 'label':
                return (0, exports.serializePrimitive)(value, child.value);
            case 'optional':
                return util.isNull(value) ? { type: 'none', value: undefined } : resolutions.resolved(String(value));
            case 'required':
                return resolutions.resolved(String(value));
            case 'not':
                return resolutions.resolved(String(value));
        }
    }
    throw new MusicXMLError_1.MusicXMLError('cannot encode string', { value: value, child: child });
};
exports.serializePrimitive = serializePrimitive;

},{"../../MusicXMLError":"node_modules/@stringsync/musicxml/dist/MusicXMLError.js","../operations":"node_modules/@stringsync/musicxml/dist/lib/operations/index.js","../resolutions":"node_modules/@stringsync/musicxml/dist/lib/resolutions/index.js","../util":"node_modules/@stringsync/musicxml/dist/lib/util/index.js"}],"node_modules/@stringsync/musicxml/dist/lib/xml/serialize.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serialize = void 0;
var MusicXMLError_1 = require("../../MusicXMLError");
var operations = require("../operations");
var util = require("../util");
var serializePrimitive_1 = require("./serializePrimitive");
var serialize = function (element) {
    var attributes = {};
    for (var _i = 0, _a = Object.keys(element.attributes); _i < _a.length; _i++) {
        var key = _a[_i];
        var resolution = (0, serializePrimitive_1.serializePrimitive)(element.attributes[key], element.schema.attributes[key]);
        if (resolution.type !== 'none') {
            attributes[key] = resolution.value;
        }
    }
    var children = resolve(element.contents, element.schema.contents);
    return { type: 'element', name: element.schema.name, attributes: attributes, children: children };
};
exports.serialize = serialize;
var resolve = function (value, child) {
    if (util.isString(child)) {
        var resolution = (0, serializePrimitive_1.serializePrimitive)(value, child);
        return resolution.type === 'none' ? [] : [{ type: 'text', text: resolution.value }];
    }
    if (util.isNumber(child)) {
        var resolution = (0, serializePrimitive_1.serializePrimitive)(value, child);
        return resolution.type === 'none' ? [] : [{ type: 'text', text: resolution.value }];
    }
    if (util.isDescriptor(child)) {
        switch (child.type) {
            case 'string':
            case 'int':
            case 'float':
            case 'constant':
            case 'regex':
            case 'date':
                var resolution = (0, serializePrimitive_1.serializePrimitive)(value, child);
                return resolution.type === 'none' ? [] : [{ type: 'text', text: resolution.value }];
            case 'optional':
                return util.isNull(value) ? [] : resolve(value, child.value);
            case 'required':
            case 'label':
                return resolve(value, child.value);
            case 'zeroOrMore':
            case 'oneOrMore':
                return operations.validate(value, child)
                    ? value.flatMap(function (v) { return resolve(v, child.value); })
                    : operations.zero(child).flatMap(function (v) { return resolve(v, child.value); });
            case 'choices':
                for (var _i = 0, _a = child.choices; _i < _a.length; _i++) {
                    var choice = _a[_i];
                    if (operations.validate(value, choice)) {
                        return resolve(value, choice);
                    }
                }
                return resolve(operations.zero(child), child);
            case 'not':
                return resolve(operations.validate(value, child) ? value : operations.zero(child), child.include);
        }
    }
    if (util.isXMLElementCtor(child)) {
        return operations.validate(value, child) ? [(0, exports.serialize)(value)] : [(0, exports.serialize)(operations.zero(child))];
    }
    if (util.isArray(child)) {
        return operations.validate(value, child)
            ? value.flatMap(function (v, ndx) { return resolve(v, child[ndx]); })
            : operations.zero(child).flatMap(function (v, ndx) { return resolve(v, child[ndx]); });
    }
    throw new MusicXMLError_1.MusicXMLError('cannot convert to raw XML element', { value: value, child: child });
};

},{"../../MusicXMLError":"node_modules/@stringsync/musicxml/dist/MusicXMLError.js","../operations":"node_modules/@stringsync/musicxml/dist/lib/operations/index.js","../util":"node_modules/@stringsync/musicxml/dist/lib/util/index.js","./serializePrimitive":"node_modules/@stringsync/musicxml/dist/lib/xml/serializePrimitive.js"}],"node_modules/@stringsync/musicxml/dist/lib/xml/toString.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toString = void 0;
var xmlJs = require("xml-js");
var toString = function (xmlDocument) {
    var xmlJsElements = xmlDocument.nodes.map(toXmlJsElement);
    return xmlJs.js2xml({ declaration: xmlDocument.declaration, elements: xmlJsElements }, { spaces: 2 });
};
exports.toString = toString;
var toXmlJsElement = function (element) {
    switch (element.type) {
        case 'element':
            return {
                type: 'element',
                name: element.name,
                attributes: element.attributes,
                elements: element.children.map(toXmlJsElement),
            };
        case 'text':
            return {
                type: 'text',
                text: element.text,
            };
        case 'doctype':
            return {
                type: 'doctype',
                doctype: element.doctype,
            };
    }
};

},{"xml-js":"node_modules/xml-js/lib/index.js"}],"node_modules/@stringsync/musicxml/dist/lib/xml/types.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],"node_modules/@stringsync/musicxml/dist/lib/xml/index.js":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./conform"), exports);
__exportStar(require("./getDefaultDeclaration"), exports);
__exportStar(require("./parse"), exports);
__exportStar(require("./serialize"), exports);
__exportStar(require("./toString"), exports);
__exportStar(require("./types"), exports);

},{"./conform":"node_modules/@stringsync/musicxml/dist/lib/xml/conform.js","./getDefaultDeclaration":"node_modules/@stringsync/musicxml/dist/lib/xml/getDefaultDeclaration.js","./parse":"node_modules/@stringsync/musicxml/dist/lib/xml/parse.js","./serialize":"node_modules/@stringsync/musicxml/dist/lib/xml/serialize.js","./toString":"node_modules/@stringsync/musicxml/dist/lib/xml/toString.js","./types":"node_modules/@stringsync/musicxml/dist/lib/xml/types.js"}],"node_modules/@stringsync/musicxml/dist/MusicXML.js":[function(require,module,exports) {
"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MusicXML = void 0;
var elements = require("./generated/elements");
var schema = require("./lib/schema");
var xml = require("./lib/xml");
var MusicXMLError_1 = require("./MusicXMLError");
/**
 * The MusicXML class manages data in a MusicXML document.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/}
 */
var MusicXML = /** @class */ (function () {
    function MusicXML(opts) {
        this.root = opts.root;
        this.index = opts.index;
        this.xmlDocument = opts.xmlDocument;
    }
    /**
     * Parses an XML string into a {@link MusicXML} object.
     *
     * This method expects exactly one top level `<score-partwise version="4.0">` or `<score-timewise>` element in the XML document
     * string. If you need a blank {@link MusicXML} object, use {@link MusicXML.createPartwise} or
     * {@link MusicXML.createTimewise} instead.
     *
     * @param {string} xmlStr an XML document as a string
     * @returns {MusicXML} a {@link MusicXML} object
     */
    MusicXML.parse = function (xmlStr) {
        var descriptor = schema.t.choices(elements.ScorePartwise, elements.ScoreTimewise);
        var xmlDocument = xml.parse(xmlStr);
        var resolutions = xmlDocument.nodes.map(function (node) { return xml.conform([node], descriptor); });
        var resolved = resolutions.filter(function (resolution) { return resolution.type === 'resolved'; });
        if (resolved.length !== 1) {
            throw new MusicXMLError_1.MusicXMLError('invalid music xml document, expected an xml document with exactly one top level <score-partwise version="4.0"> or <score-timewise> element', {
                rootElementNames: xmlDocument.nodes
                    .filter(function (node) { return node.type === 'element'; })
                    .map(function (node) { return node.name; }),
            });
        }
        var root = resolved[0].value;
        var index = resolutions.findIndex(function (resolution) { return resolution.type === 'resolved'; });
        return new MusicXML({ root: root, index: index, xmlDocument: xmlDocument });
    };
    /**
     * Creates a {@link MusicXML} object with a {@link elements.ScorePartwise} as the root.
     *
     * @returns {MusicXML} a {@link MusicXML} object
     */
    MusicXML.createPartwise = function () {
        var root = new elements.ScorePartwise();
        var index = 0;
        var nodes = [xml.serialize(root)];
        var declaration = xml.getDefaultDeclaration();
        var xmlDocument = { declaration: declaration, nodes: nodes };
        return new MusicXML({ root: root, index: index, xmlDocument: xmlDocument });
    };
    /**
     * Creates a {@link MusicXML} object with a {@link elements.ScoreTimewise} as the root.
     *
     * @returns {MusicXML} a {@link MusicXML} object
     */
    MusicXML.createTimewise = function () {
        var root = new elements.ScoreTimewise();
        var index = 0;
        var nodes = [xml.serialize(root)];
        var declaration = xml.getDefaultDeclaration();
        var xmlDocument = { declaration: declaration, nodes: nodes };
        return new MusicXML({ root: root, index: index, xmlDocument: xmlDocument });
    };
    /**
     * Gets the root of this {@link MusicXML} object.
     *
     * @returns {elements.ScorePartwise|elements.ScoreTimewise} the root of this {@link MusicXML} object
     */
    MusicXML.prototype.getRoot = function () {
        return this.root;
    };
    /**
     * Serializes this {@link MusicXML} object into a string.
     *
     * @returns {string} the string representation of this {@link MusicXML} object
     */
    MusicXML.prototype.serialize = function () {
        var node = xml.serialize(this.root);
        var nodes = __spreadArray([], this.xmlDocument.nodes, true);
        nodes[this.index] = node;
        var declaration = this.xmlDocument.declaration;
        var xmlDocument = { declaration: declaration, nodes: nodes };
        return xml.toString(xmlDocument);
    };
    return MusicXML;
}());
exports.MusicXML = MusicXML;

},{"./generated/elements":"node_modules/@stringsync/musicxml/dist/generated/elements.js","./lib/schema":"node_modules/@stringsync/musicxml/dist/lib/schema/index.js","./lib/xml":"node_modules/@stringsync/musicxml/dist/lib/xml/index.js","./MusicXMLError":"node_modules/@stringsync/musicxml/dist/MusicXMLError.js"}],"node_modules/@stringsync/musicxml/dist/index.js":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.elements = exports.asserts = void 0;
exports.asserts = require("./generated/asserts");
exports.elements = require("./generated/elements");
__exportStar(require("./MusicXML"), exports);

},{"./generated/asserts":"node_modules/@stringsync/musicxml/dist/generated/asserts.js","./generated/elements":"node_modules/@stringsync/musicxml/dist/generated/elements.js","./MusicXML":"node_modules/@stringsync/musicxml/dist/MusicXML.js"}],"src/test.js":[function(require,module,exports) {
"use strict";

var _musicxml = require("@stringsync/musicxml");
function show_score() {
  var score = _musicxml.MusicXML.createPartwise();
  var root = score.getRoot();
  console.log(score.serialize());
  var note = new _musicxml.elements.Note();
  var measure = new _musicxml.elements.MeasurePartwise({
    attributes: {
      number: '1',
      implicit: 'no'
    }
  });
  var part = new _musicxml.elements.PartPartwise([measure]);
  root.setParts([part]);
  console.log(score.serialize()); // output same as above
}
show_score();
},{"@stringsync/musicxml":"node_modules/@stringsync/musicxml/dist/index.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "54165" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","src/test.js"], null)
//# sourceMappingURL=/test.abb54c3b.js.map